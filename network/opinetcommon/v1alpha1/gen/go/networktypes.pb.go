// Copyright (c) 2023 AMD Inc.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: networktypes.proto

package _go

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// security rule action is one of the below
type SecurityRuleAction int32

const (
	// no action
	// (-- api-linter: core::0126::unspecified=disabled
	//     aip.dev/not-precedent: NONE means no action. --)
	SecurityRuleAction_SECURITY_RULE_ACTION_NONE SecurityRuleAction = 0
	// allow
	SecurityRuleAction_SECURITY_RULE_ACTION_ALLOW SecurityRuleAction = 1
	// deny
	SecurityRuleAction_SECURITY_RULE_ACTION_DENY SecurityRuleAction = 2
)

// Enum value maps for SecurityRuleAction.
var (
	SecurityRuleAction_name = map[int32]string{
		0: "SECURITY_RULE_ACTION_NONE",
		1: "SECURITY_RULE_ACTION_ALLOW",
		2: "SECURITY_RULE_ACTION_DENY",
	}
	SecurityRuleAction_value = map[string]int32{
		"SECURITY_RULE_ACTION_NONE":  0,
		"SECURITY_RULE_ACTION_ALLOW": 1,
		"SECURITY_RULE_ACTION_DENY":  2,
	}
)

func (x SecurityRuleAction) Enum() *SecurityRuleAction {
	p := new(SecurityRuleAction)
	*p = x
	return p
}

func (x SecurityRuleAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SecurityRuleAction) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[0].Descriptor()
}

func (SecurityRuleAction) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[0]
}

func (x SecurityRuleAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SecurityRuleAction.Descriptor instead.
func (SecurityRuleAction) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{0}
}

// IP address families
type IpAf int32

const (
	// unspecified
	IpAf_IP_AF_UNSPECIFIED IpAf = 0
	// ipv4
	IpAf_IP_AF_INET IpAf = 1
	// ipv6
	IpAf_IP_AF_INET6 IpAf = 2
)

// Enum value maps for IpAf.
var (
	IpAf_name = map[int32]string{
		0: "IP_AF_UNSPECIFIED",
		1: "IP_AF_INET",
		2: "IP_AF_INET6",
	}
	IpAf_value = map[string]int32{
		"IP_AF_UNSPECIFIED": 0,
		"IP_AF_INET":        1,
		"IP_AF_INET6":       2,
	}
)

func (x IpAf) Enum() *IpAf {
	p := new(IpAf)
	*p = x
	return p
}

func (x IpAf) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IpAf) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[1].Descriptor()
}

func (IpAf) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[1]
}

func (x IpAf) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IpAf.Descriptor instead.
func (IpAf) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{1}
}

// encap types in the network
type EncapType int32

const (
	// no encap
	EncapType_ENCAP_TYPE_UNSPECIFIED EncapType = 0
	// 802.1q
	EncapType_ENCAP_TYPE_DOT1Q EncapType = 1
	// MPLS over UDP
	EncapType_ENCAP_TYPE_MPLS_OVER_UDP EncapType = 2
	// VXLAN
	EncapType_ENCAP_TYPE_VXLAN EncapType = 3
	// NVGRE
	EncapType_ENCAP_TYPE_NVGRE EncapType = 4
)

// Enum value maps for EncapType.
var (
	EncapType_name = map[int32]string{
		0: "ENCAP_TYPE_UNSPECIFIED",
		1: "ENCAP_TYPE_DOT1Q",
		2: "ENCAP_TYPE_MPLS_OVER_UDP",
		3: "ENCAP_TYPE_VXLAN",
		4: "ENCAP_TYPE_NVGRE",
	}
	EncapType_value = map[string]int32{
		"ENCAP_TYPE_UNSPECIFIED":   0,
		"ENCAP_TYPE_DOT1Q":         1,
		"ENCAP_TYPE_MPLS_OVER_UDP": 2,
		"ENCAP_TYPE_VXLAN":         3,
		"ENCAP_TYPE_NVGRE":         4,
	}
)

func (x EncapType) Enum() *EncapType {
	p := new(EncapType)
	*p = x
	return p
}

func (x EncapType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EncapType) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[2].Descriptor()
}

func (EncapType) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[2]
}

func (x EncapType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EncapType.Descriptor instead.
func (EncapType) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{2}
}

// route type
type RouteType int32

const (
	// unspecified
	RouteType_ROUTE_TYPE_UNSPECIFIED RouteType = 0
	// other
	RouteType_ROUTE_TYPE_OTHER RouteType = 1
	// reject
	RouteType_ROUTE_TYPE_REJECT RouteType = 2
	// local
	RouteType_ROUTE_TYPE_LOCAL RouteType = 3
	// remote
	RouteType_ROUTE_TYPE_REMOTE RouteType = 4
)

// Enum value maps for RouteType.
var (
	RouteType_name = map[int32]string{
		0: "ROUTE_TYPE_UNSPECIFIED",
		1: "ROUTE_TYPE_OTHER",
		2: "ROUTE_TYPE_REJECT",
		3: "ROUTE_TYPE_LOCAL",
		4: "ROUTE_TYPE_REMOTE",
	}
	RouteType_value = map[string]int32{
		"ROUTE_TYPE_UNSPECIFIED": 0,
		"ROUTE_TYPE_OTHER":       1,
		"ROUTE_TYPE_REJECT":      2,
		"ROUTE_TYPE_LOCAL":       3,
		"ROUTE_TYPE_REMOTE":      4,
	}
)

func (x RouteType) Enum() *RouteType {
	p := new(RouteType)
	*p = x
	return p
}

func (x RouteType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteType) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[3].Descriptor()
}

func (RouteType) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[3]
}

func (x RouteType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteType.Descriptor instead.
func (RouteType) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{3}
}

// route protocols
type RouteProtocol int32

const (
	// unspecified
	RouteProtocol_ROUTE_PROTOCOL_UNSPECIFIED RouteProtocol = 0
	// local
	RouteProtocol_ROUTE_PROTOCOL_LOCAL RouteProtocol = 1
	// static
	RouteProtocol_ROUTE_PROTOCOL_STATIC RouteProtocol = 2
	// bgp (dynamic)
	RouteProtocol_ROUTE_PROTOCOL_BGP RouteProtocol = 3
)

// Enum value maps for RouteProtocol.
var (
	RouteProtocol_name = map[int32]string{
		0: "ROUTE_PROTOCOL_UNSPECIFIED",
		1: "ROUTE_PROTOCOL_LOCAL",
		2: "ROUTE_PROTOCOL_STATIC",
		3: "ROUTE_PROTOCOL_BGP",
	}
	RouteProtocol_value = map[string]int32{
		"ROUTE_PROTOCOL_UNSPECIFIED": 0,
		"ROUTE_PROTOCOL_LOCAL":       1,
		"ROUTE_PROTOCOL_STATIC":      2,
		"ROUTE_PROTOCOL_BGP":         3,
	}
)

func (x RouteProtocol) Enum() *RouteProtocol {
	p := new(RouteProtocol)
	*p = x
	return p
}

func (x RouteProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[4].Descriptor()
}

func (RouteProtocol) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[4]
}

func (x RouteProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteProtocol.Descriptor instead.
func (RouteProtocol) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{4}
}

// admin state of control plane objects
type AdminState int32

const (
	// unspecified
	AdminState_ADMIN_STATE_UNSPECIFIED AdminState = 0
	// enable
	AdminState_ADMIN_STATE_ENABLE AdminState = 1
	// disable
	AdminState_ADMIN_STATE_DISABLE AdminState = 2
)

// Enum value maps for AdminState.
var (
	AdminState_name = map[int32]string{
		0: "ADMIN_STATE_UNSPECIFIED",
		1: "ADMIN_STATE_ENABLE",
		2: "ADMIN_STATE_DISABLE",
	}
	AdminState_value = map[string]int32{
		"ADMIN_STATE_UNSPECIFIED": 0,
		"ADMIN_STATE_ENABLE":      1,
		"ADMIN_STATE_DISABLE":     2,
	}
)

func (x AdminState) Enum() *AdminState {
	p := new(AdminState)
	*p = x
	return p
}

func (x AdminState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AdminState) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[5].Descriptor()
}

func (AdminState) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[5]
}

func (x AdminState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AdminState.Descriptor instead.
func (AdminState) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{5}
}

// direction in which policy is enforced
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
type PolicyDir int32

const (
	// unspecified
	PolicyDir_POLICY_DIR_UNSPECIFIED PolicyDir = 0
	// ingress (towards vnic from network)
	PolicyDir_POLICY_DIR_INGRESS PolicyDir = 1
	// egress (from vnic to network)
	PolicyDir_POLICY_DIR_EGRESS PolicyDir = 2
)

// Enum value maps for PolicyDir.
var (
	PolicyDir_name = map[int32]string{
		0: "POLICY_DIR_UNSPECIFIED",
		1: "POLICY_DIR_INGRESS",
		2: "POLICY_DIR_EGRESS",
	}
	PolicyDir_value = map[string]int32{
		"POLICY_DIR_UNSPECIFIED": 0,
		"POLICY_DIR_INGRESS":     1,
		"POLICY_DIR_EGRESS":      2,
	}
)

func (x PolicyDir) Enum() *PolicyDir {
	p := new(PolicyDir)
	*p = x
	return p
}

func (x PolicyDir) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyDir) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[6].Descriptor()
}

func (PolicyDir) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[6]
}

func (x PolicyDir) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyDir.Descriptor instead.
func (PolicyDir) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{6}
}

// WildcardMatch options
type WildcardMatch int32

const (
	// wouldn't match anything
	// (-- api-linter: core::0126::unspecified=disabled
	//     aip.dev/not-precedent: NONE means don't match anything. --)
	WildcardMatch_MATCH_NONE WildcardMatch = 0
	// match everything
	WildcardMatch_MATCH_ANY WildcardMatch = 256
)

// Enum value maps for WildcardMatch.
var (
	WildcardMatch_name = map[int32]string{
		0:   "MATCH_NONE",
		256: "MATCH_ANY",
	}
	WildcardMatch_value = map[string]int32{
		"MATCH_NONE": 0,
		"MATCH_ANY":  256,
	}
)

func (x WildcardMatch) Enum() *WildcardMatch {
	p := new(WildcardMatch)
	*p = x
	return p
}

func (x WildcardMatch) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WildcardMatch) Descriptor() protoreflect.EnumDescriptor {
	return file_networktypes_proto_enumTypes[7].Descriptor()
}

func (WildcardMatch) Type() protoreflect.EnumType {
	return &file_networktypes_proto_enumTypes[7]
}

func (x WildcardMatch) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WildcardMatch.Descriptor instead.
func (WildcardMatch) EnumDescriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{7}
}

// IP Address object
type IPAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP Address family
	Af IpAf `protobuf:"varint,1,opt,name=af,proto3,enum=opi_api.network.opinetcommon.v1alpha1.IpAf" json:"af,omitempty"`
	// IP address family
	//
	// Types that are assignable to V4OrV6:
	//	*IPAddress_V4Addr
	//	*IPAddress_V6Addr
	V4OrV6 isIPAddress_V4OrV6 `protobuf_oneof:"v4_or_v6"`
}

func (x *IPAddress) Reset() {
	*x = IPAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPAddress) ProtoMessage() {}

func (x *IPAddress) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPAddress.ProtoReflect.Descriptor instead.
func (*IPAddress) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{0}
}

func (x *IPAddress) GetAf() IpAf {
	if x != nil {
		return x.Af
	}
	return IpAf_IP_AF_UNSPECIFIED
}

func (m *IPAddress) GetV4OrV6() isIPAddress_V4OrV6 {
	if m != nil {
		return m.V4OrV6
	}
	return nil
}

func (x *IPAddress) GetV4Addr() uint32 {
	if x, ok := x.GetV4OrV6().(*IPAddress_V4Addr); ok {
		return x.V4Addr
	}
	return 0
}

func (x *IPAddress) GetV6Addr() []byte {
	if x, ok := x.GetV4OrV6().(*IPAddress_V6Addr); ok {
		return x.V6Addr
	}
	return nil
}

type isIPAddress_V4OrV6 interface {
	isIPAddress_V4OrV6()
}

type IPAddress_V4Addr struct {
	// IPv4 address
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: must use fixed32 --)
	V4Addr uint32 `protobuf:"fixed32,2,opt,name=v4_addr,json=v4Addr,proto3,oneof"`
}

type IPAddress_V6Addr struct {
	// IPv6 address
	V6Addr []byte `protobuf:"bytes,3,opt,name=v6_addr,json=v6Addr,proto3,oneof"`
}

func (*IPAddress_V4Addr) isIPAddress_V4OrV6() {}

func (*IPAddress_V6Addr) isIPAddress_V4OrV6() {}

// IP Prefix object
type IPPrefix struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP prefix address
	Addr *IPAddress `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// IP Prefix length (range:0-128)
	Len int32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
}

func (x *IPPrefix) Reset() {
	*x = IPPrefix{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPPrefix) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPPrefix) ProtoMessage() {}

func (x *IPPrefix) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPPrefix.ProtoReflect.Descriptor instead.
func (*IPPrefix) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{1}
}

func (x *IPPrefix) GetAddr() *IPAddress {
	if x != nil {
		return x.Addr
	}
	return nil
}

func (x *IPPrefix) GetLen() int32 {
	if x != nil {
		return x.Len
	}
	return 0
}

// IPv4 Prefix
type IPv4Prefix struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IPv4 address portion
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: must use fixed32 --)
	Addr uint32 `protobuf:"fixed32,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// prefix length; range:0-32
	Len int32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
}

func (x *IPv4Prefix) Reset() {
	*x = IPv4Prefix{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPv4Prefix) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPv4Prefix) ProtoMessage() {}

func (x *IPv4Prefix) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPv4Prefix.ProtoReflect.Descriptor instead.
func (*IPv4Prefix) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{2}
}

func (x *IPv4Prefix) GetAddr() uint32 {
	if x != nil {
		return x.Addr
	}
	return 0
}

func (x *IPv4Prefix) GetLen() int32 {
	if x != nil {
		return x.Len
	}
	return 0
}

// IPv6 Prefix
type IPv6Prefix struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IPv6 address bytes
	Addr []byte `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// prefix length: range:0-128
	Len int32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
}

func (x *IPv6Prefix) Reset() {
	*x = IPv6Prefix{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPv6Prefix) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPv6Prefix) ProtoMessage() {}

func (x *IPv6Prefix) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPv6Prefix.ProtoReflect.Descriptor instead.
func (*IPv6Prefix) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{3}
}

func (x *IPv6Prefix) GetAddr() []byte {
	if x != nil {
		return x.Addr
	}
	return nil
}

func (x *IPv6Prefix) GetLen() int32 {
	if x != nil {
		return x.Len
	}
	return 0
}

// tag values for various encap types
type EncapVal struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Val:
	//	*EncapVal_VlanId
	//	*EncapVal_MplsTag
	//	*EncapVal_Vnid
	//	*EncapVal_Vsid
	Val isEncapVal_Val `protobuf_oneof:"val"`
}

func (x *EncapVal) Reset() {
	*x = EncapVal{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncapVal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncapVal) ProtoMessage() {}

func (x *EncapVal) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncapVal.ProtoReflect.Descriptor instead.
func (*EncapVal) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{4}
}

func (m *EncapVal) GetVal() isEncapVal_Val {
	if m != nil {
		return m.Val
	}
	return nil
}

func (x *EncapVal) GetVlanId() int32 {
	if x, ok := x.GetVal().(*EncapVal_VlanId); ok {
		return x.VlanId
	}
	return 0
}

func (x *EncapVal) GetMplsTag() int32 {
	if x, ok := x.GetVal().(*EncapVal_MplsTag); ok {
		return x.MplsTag
	}
	return 0
}

func (x *EncapVal) GetVnid() int32 {
	if x, ok := x.GetVal().(*EncapVal_Vnid); ok {
		return x.Vnid
	}
	return 0
}

func (x *EncapVal) GetVsid() int32 {
	if x, ok := x.GetVal().(*EncapVal_Vsid); ok {
		return x.Vsid
	}
	return 0
}

type isEncapVal_Val interface {
	isEncapVal_Val()
}

type EncapVal_VlanId struct {
	// vlan id for DOT1Q
	VlanId int32 `protobuf:"varint,1,opt,name=vlan_id,json=vlanId,proto3,oneof"`
}

type EncapVal_MplsTag struct {
	// MPLS tag/slot for MPLS over UDP
	MplsTag int32 `protobuf:"varint,2,opt,name=mpls_tag,json=mplsTag,proto3,oneof"`
}

type EncapVal_Vnid struct {
	// VXLAN VNID (24bit value)
	Vnid int32 `protobuf:"varint,3,opt,name=vnid,proto3,oneof"`
}

type EncapVal_Vsid struct {
	// NVGRE VSID
	Vsid int32 `protobuf:"varint,5,opt,name=vsid,proto3,oneof"`
}

func (*EncapVal_VlanId) isEncapVal_Val() {}

func (*EncapVal_MplsTag) isEncapVal_Val() {}

func (*EncapVal_Vnid) isEncapVal_Val() {}

func (*EncapVal_Vsid) isEncapVal_Val() {}

// fabric encap
type Encap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// encyp type
	Type EncapType `protobuf:"varint,1,opt,name=type,proto3,enum=opi_api.network.opinetcommon.v1alpha1.EncapType" json:"type,omitempty"`
	// encap value
	Value *EncapVal `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Encap) Reset() {
	*x = Encap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Encap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Encap) ProtoMessage() {}

func (x *Encap) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Encap.ProtoReflect.Descriptor instead.
func (*Encap) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{5}
}

func (x *Encap) GetType() EncapType {
	if x != nil {
		return x.Type
	}
	return EncapType_ENCAP_TYPE_UNSPECIFIED
}

func (x *Encap) GetValue() *EncapVal {
	if x != nil {
		return x.Value
	}
	return nil
}

// PortRange object has low and high end of the port ranges
type PortRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// range:0-65535
	PortLow int32 `protobuf:"varint,1,opt,name=port_low,json=portLow,proto3" json:"port_low,omitempty"`
	// range:0-65535
	PortHigh int32 `protobuf:"varint,2,opt,name=port_high,json=portHigh,proto3" json:"port_high,omitempty"`
}

func (x *PortRange) Reset() {
	*x = PortRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PortRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortRange) ProtoMessage() {}

func (x *PortRange) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortRange.ProtoReflect.Descriptor instead.
func (*PortRange) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{6}
}

func (x *PortRange) GetPortLow() int32 {
	if x != nil {
		return x.PortLow
	}
	return 0
}

func (x *PortRange) GetPortHigh() int32 {
	if x != nil {
		return x.PortHigh
	}
	return 0
}

// IP Range
type IPRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// starting IP address
	Low *IPAddress `protobuf:"bytes,1,opt,name=low,proto3" json:"low,omitempty"`
	// ending IP address
	High *IPAddress `protobuf:"bytes,2,opt,name=high,proto3" json:"high,omitempty"`
}

func (x *IPRange) Reset() {
	*x = IPRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPRange) ProtoMessage() {}

func (x *IPRange) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPRange.ProtoReflect.Descriptor instead.
func (*IPRange) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{7}
}

func (x *IPRange) GetLow() *IPAddress {
	if x != nil {
		return x.Low
	}
	return nil
}

func (x *IPRange) GetHigh() *IPAddress {
	if x != nil {
		return x.High
	}
	return nil
}

// AddressRange represents an IPv4 or IPv6 address range
type AddressRange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Range:
	//	*AddressRange_Ipv4Range
	//	*AddressRange_Ipv6Range
	Range isAddressRange_Range `protobuf_oneof:"range"`
}

func (x *AddressRange) Reset() {
	*x = AddressRange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AddressRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressRange) ProtoMessage() {}

func (x *AddressRange) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressRange.ProtoReflect.Descriptor instead.
func (*AddressRange) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{8}
}

func (m *AddressRange) GetRange() isAddressRange_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (x *AddressRange) GetIpv4Range() *IPRange {
	if x, ok := x.GetRange().(*AddressRange_Ipv4Range); ok {
		return x.Ipv4Range
	}
	return nil
}

func (x *AddressRange) GetIpv6Range() *IPRange {
	if x, ok := x.GetRange().(*AddressRange_Ipv6Range); ok {
		return x.Ipv6Range
	}
	return nil
}

type isAddressRange_Range interface {
	isAddressRange_Range()
}

type AddressRange_Ipv4Range struct {
	// IPv4 address range
	Ipv4Range *IPRange `protobuf:"bytes,1,opt,name=ipv4_range,json=ipv4Range,proto3,oneof"`
}

type AddressRange_Ipv6Range struct {
	// IPv6 address range
	Ipv6Range *IPRange `protobuf:"bytes,2,opt,name=ipv6_range,json=ipv6Range,proto3,oneof"`
}

func (*AddressRange_Ipv4Range) isAddressRange_Range() {}

func (*AddressRange_Ipv6Range) isAddressRange_Range() {}

// IPEntry represents any form of IP address/prefix/range/tag etc.
type IPEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to IpEntry:
	//	*IPEntry_Prefix
	//	*IPEntry_Range
	//	*IPEntry_Tag
	IpEntry isIPEntry_IpEntry `protobuf_oneof:"ip_entry"`
}

func (x *IPEntry) Reset() {
	*x = IPEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPEntry) ProtoMessage() {}

func (x *IPEntry) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPEntry.ProtoReflect.Descriptor instead.
func (*IPEntry) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{9}
}

func (m *IPEntry) GetIpEntry() isIPEntry_IpEntry {
	if m != nil {
		return m.IpEntry
	}
	return nil
}

func (x *IPEntry) GetPrefix() *IPPrefix {
	if x, ok := x.GetIpEntry().(*IPEntry_Prefix); ok {
		return x.Prefix
	}
	return nil
}

func (x *IPEntry) GetRange() *AddressRange {
	if x, ok := x.GetIpEntry().(*IPEntry_Range); ok {
		return x.Range
	}
	return nil
}

func (x *IPEntry) GetTag() int32 {
	if x, ok := x.GetIpEntry().(*IPEntry_Tag); ok {
		return x.Tag
	}
	return 0
}

type isIPEntry_IpEntry interface {
	isIPEntry_IpEntry()
}

type IPEntry_Prefix struct {
	// IP prefix
	Prefix *IPPrefix `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}

type IPEntry_Range struct {
	// IP range
	Range *AddressRange `protobuf:"bytes,2,opt,name=range,proto3,oneof"`
}

type IPEntry_Tag struct {
	// tag that represents IP addres/pfx/range, range:1-4294967294
	Tag int32 `protobuf:"varint,3,opt,name=tag,proto3,oneof"`
}

func (*IPEntry_Prefix) isIPEntry_IpEntry() {}

func (*IPEntry_Range) isIPEntry_IpEntry() {}

func (*IPEntry_Tag) isIPEntry_IpEntry() {}

// IPList is a list of IPEntry objects
type IPList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// list of ip entries (prefix, range)
	IpEntries []*IPEntry `protobuf:"bytes,1,rep,name=ip_entries,json=ipEntries,proto3" json:"ip_entries,omitempty"`
}

func (x *IPList) Reset() {
	*x = IPList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IPList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPList) ProtoMessage() {}

func (x *IPList) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPList.ProtoReflect.Descriptor instead.
func (*IPList) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{10}
}

func (x *IPList) GetIpEntries() []*IPEntry {
	if x != nil {
		return x.IpEntries
	}
	return nil
}

// L3 rule match criteria
type RuleL3Match struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP protocol match MUST be specified even if it is wildcard
	//
	// Types that are assignable to Protomatch:
	//	*RuleL3Match_ProtoNum
	//	*RuleL3Match_ProtoWildCard
	Protomatch isRuleL3Match_Protomatch `protobuf_oneof:"protomatch"`
	// Types that are assignable to Srcmatch:
	//	*RuleL3Match_SrcPrefix
	//	*RuleL3Match_SrcRange
	//	*RuleL3Match_SrcTag
	//	*RuleL3Match_SrcIpList
	Srcmatch isRuleL3Match_Srcmatch `protobuf_oneof:"srcmatch"`
	// Types that are assignable to Dstmatch:
	//	*RuleL3Match_DstPrefix
	//	*RuleL3Match_DstRange
	//	*RuleL3Match_DstTag
	//	*RuleL3Match_DstIpList
	Dstmatch isRuleL3Match_Dstmatch `protobuf_oneof:"dstmatch"`
}

func (x *RuleL3Match) Reset() {
	*x = RuleL3Match{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RuleL3Match) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuleL3Match) ProtoMessage() {}

func (x *RuleL3Match) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuleL3Match.ProtoReflect.Descriptor instead.
func (*RuleL3Match) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{11}
}

func (m *RuleL3Match) GetProtomatch() isRuleL3Match_Protomatch {
	if m != nil {
		return m.Protomatch
	}
	return nil
}

func (x *RuleL3Match) GetProtoNum() int32 {
	if x, ok := x.GetProtomatch().(*RuleL3Match_ProtoNum); ok {
		return x.ProtoNum
	}
	return 0
}

func (x *RuleL3Match) GetProtoWildCard() WildcardMatch {
	if x, ok := x.GetProtomatch().(*RuleL3Match_ProtoWildCard); ok {
		return x.ProtoWildCard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *RuleL3Match) GetSrcmatch() isRuleL3Match_Srcmatch {
	if m != nil {
		return m.Srcmatch
	}
	return nil
}

func (x *RuleL3Match) GetSrcPrefix() *IPPrefix {
	if x, ok := x.GetSrcmatch().(*RuleL3Match_SrcPrefix); ok {
		return x.SrcPrefix
	}
	return nil
}

func (x *RuleL3Match) GetSrcRange() *AddressRange {
	if x, ok := x.GetSrcmatch().(*RuleL3Match_SrcRange); ok {
		return x.SrcRange
	}
	return nil
}

func (x *RuleL3Match) GetSrcTag() int32 {
	if x, ok := x.GetSrcmatch().(*RuleL3Match_SrcTag); ok {
		return x.SrcTag
	}
	return 0
}

func (x *RuleL3Match) GetSrcIpList() *IPList {
	if x, ok := x.GetSrcmatch().(*RuleL3Match_SrcIpList); ok {
		return x.SrcIpList
	}
	return nil
}

func (m *RuleL3Match) GetDstmatch() isRuleL3Match_Dstmatch {
	if m != nil {
		return m.Dstmatch
	}
	return nil
}

func (x *RuleL3Match) GetDstPrefix() *IPPrefix {
	if x, ok := x.GetDstmatch().(*RuleL3Match_DstPrefix); ok {
		return x.DstPrefix
	}
	return nil
}

func (x *RuleL3Match) GetDstRange() *AddressRange {
	if x, ok := x.GetDstmatch().(*RuleL3Match_DstRange); ok {
		return x.DstRange
	}
	return nil
}

func (x *RuleL3Match) GetDstTag() int32 {
	if x, ok := x.GetDstmatch().(*RuleL3Match_DstTag); ok {
		return x.DstTag
	}
	return 0
}

func (x *RuleL3Match) GetDstIpList() *IPList {
	if x, ok := x.GetDstmatch().(*RuleL3Match_DstIpList); ok {
		return x.DstIpList
	}
	return nil
}

type isRuleL3Match_Protomatch interface {
	isRuleL3Match_Protomatch()
}

type RuleL3Match_ProtoNum struct {
	// protocol number
	ProtoNum int32 `protobuf:"varint,1,opt,name=proto_num,json=protoNum,proto3,oneof"`
}

type RuleL3Match_ProtoWildCard struct {
	// match ANY protocol
	ProtoWildCard WildcardMatch `protobuf:"varint,2,opt,name=proto_wild_card,json=protoWildCard,proto3,enum=opi_api.network.opinetcommon.v1alpha1.WildcardMatch,oneof"`
}

func (*RuleL3Match_ProtoNum) isRuleL3Match_Protomatch() {}

func (*RuleL3Match_ProtoWildCard) isRuleL3Match_Protomatch() {}

type isRuleL3Match_Srcmatch interface {
	isRuleL3Match_Srcmatch()
}

type RuleL3Match_SrcPrefix struct {
	// ip prefix
	SrcPrefix *IPPrefix `protobuf:"bytes,3,opt,name=src_prefix,json=srcPrefix,proto3,oneof"`
}

type RuleL3Match_SrcRange struct {
	// source ip address range
	SrcRange *AddressRange `protobuf:"bytes,4,opt,name=src_range,json=srcRange,proto3,oneof"`
}

type RuleL3Match_SrcTag struct {
	// source tag for the range (range:1-429496729)
	SrcTag int32 `protobuf:"varint,5,opt,name=src_tag,json=srcTag,proto3,oneof"`
}

type RuleL3Match_SrcIpList struct {
	// ip list
	SrcIpList *IPList `protobuf:"bytes,6,opt,name=src_ip_list,json=srcIpList,proto3,oneof"`
}

func (*RuleL3Match_SrcPrefix) isRuleL3Match_Srcmatch() {}

func (*RuleL3Match_SrcRange) isRuleL3Match_Srcmatch() {}

func (*RuleL3Match_SrcTag) isRuleL3Match_Srcmatch() {}

func (*RuleL3Match_SrcIpList) isRuleL3Match_Srcmatch() {}

type isRuleL3Match_Dstmatch interface {
	isRuleL3Match_Dstmatch()
}

type RuleL3Match_DstPrefix struct {
	// ip prefix
	DstPrefix *IPPrefix `protobuf:"bytes,7,opt,name=dst_prefix,json=dstPrefix,proto3,oneof"`
}

type RuleL3Match_DstRange struct {
	// destination ip range
	DstRange *AddressRange `protobuf:"bytes,8,opt,name=dst_range,json=dstRange,proto3,oneof"`
}

type RuleL3Match_DstTag struct {
	// destination tag (range:1-429496729)
	DstTag int32 `protobuf:"varint,9,opt,name=dst_tag,json=dstTag,proto3,oneof"`
}

type RuleL3Match_DstIpList struct {
	// ip list
	DstIpList *IPList `protobuf:"bytes,10,opt,name=dst_ip_list,json=dstIpList,proto3,oneof"`
}

func (*RuleL3Match_DstPrefix) isRuleL3Match_Dstmatch() {}

func (*RuleL3Match_DstRange) isRuleL3Match_Dstmatch() {}

func (*RuleL3Match_DstTag) isRuleL3Match_Dstmatch() {}

func (*RuleL3Match_DstIpList) isRuleL3Match_Dstmatch() {}

// TCP/UDP rule match criteria
type PortMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// source port range
	SrcPortRange *PortRange `protobuf:"bytes,1,opt,name=src_port_range,json=srcPortRange,proto3" json:"src_port_range,omitempty"`
	// destination port range
	DstPortRange *PortRange `protobuf:"bytes,2,opt,name=dst_port_range,json=dstPortRange,proto3" json:"dst_port_range,omitempty"`
}

func (x *PortMatch) Reset() {
	*x = PortMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PortMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortMatch) ProtoMessage() {}

func (x *PortMatch) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortMatch.ProtoReflect.Descriptor instead.
func (*PortMatch) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{12}
}

func (x *PortMatch) GetSrcPortRange() *PortRange {
	if x != nil {
		return x.SrcPortRange
	}
	return nil
}

func (x *PortMatch) GetDstPortRange() *PortRange {
	if x != nil {
		return x.DstPortRange
	}
	return nil
}

// ICMPv4/ICMPv6 rule match criteria
type ICMPMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ICMP type
	//
	// Types that are assignable to Typematch:
	//	*ICMPMatch_Type
	//	*ICMPMatch_TypeWildcard
	Typematch isICMPMatch_Typematch `protobuf_oneof:"typematch"`
	// ICMP code
	//
	// Types that are assignable to Codematch:
	//	*ICMPMatch_Code
	//	*ICMPMatch_CodeWildcard
	Codematch isICMPMatch_Codematch `protobuf_oneof:"codematch"`
}

func (x *ICMPMatch) Reset() {
	*x = ICMPMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ICMPMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ICMPMatch) ProtoMessage() {}

func (x *ICMPMatch) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ICMPMatch.ProtoReflect.Descriptor instead.
func (*ICMPMatch) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{13}
}

func (m *ICMPMatch) GetTypematch() isICMPMatch_Typematch {
	if m != nil {
		return m.Typematch
	}
	return nil
}

func (x *ICMPMatch) GetType() int32 {
	if x, ok := x.GetTypematch().(*ICMPMatch_Type); ok {
		return x.Type
	}
	return 0
}

func (x *ICMPMatch) GetTypeWildcard() WildcardMatch {
	if x, ok := x.GetTypematch().(*ICMPMatch_TypeWildcard); ok {
		return x.TypeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

func (m *ICMPMatch) GetCodematch() isICMPMatch_Codematch {
	if m != nil {
		return m.Codematch
	}
	return nil
}

func (x *ICMPMatch) GetCode() int32 {
	if x, ok := x.GetCodematch().(*ICMPMatch_Code); ok {
		return x.Code
	}
	return 0
}

func (x *ICMPMatch) GetCodeWildcard() WildcardMatch {
	if x, ok := x.GetCodematch().(*ICMPMatch_CodeWildcard); ok {
		return x.CodeWildcard
	}
	return WildcardMatch_MATCH_NONE
}

type isICMPMatch_Typematch interface {
	isICMPMatch_Typematch()
}

type ICMPMatch_Type struct {
	// match any ICMP type
	Type int32 `protobuf:"varint,1,opt,name=type,proto3,oneof"`
}

type ICMPMatch_TypeWildcard struct {
	// match any ICMP type
	TypeWildcard WildcardMatch `protobuf:"varint,2,opt,name=type_wildcard,json=typeWildcard,proto3,enum=opi_api.network.opinetcommon.v1alpha1.WildcardMatch,oneof"`
}

func (*ICMPMatch_Type) isICMPMatch_Typematch() {}

func (*ICMPMatch_TypeWildcard) isICMPMatch_Typematch() {}

type isICMPMatch_Codematch interface {
	isICMPMatch_Codematch()
}

type ICMPMatch_Code struct {
	// match any ICMP code
	Code int32 `protobuf:"varint,3,opt,name=code,proto3,oneof"`
}

type ICMPMatch_CodeWildcard struct {
	// match any ICMP code
	CodeWildcard WildcardMatch `protobuf:"varint,4,opt,name=code_wildcard,json=codeWildcard,proto3,enum=opi_api.network.opinetcommon.v1alpha1.WildcardMatch,oneof"`
}

func (*ICMPMatch_Code) isICMPMatch_Codematch() {}

func (*ICMPMatch_CodeWildcard) isICMPMatch_Codematch() {}

// TCP/UDP source and destination port list
type PortListMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// list of source ports or port ranges
	SrcPortRange []*PortRange `protobuf:"bytes,1,rep,name=src_port_range,json=srcPortRange,proto3" json:"src_port_range,omitempty"`
	// list of destination ports or port ranges
	DstPortRange []*PortRange `protobuf:"bytes,2,rep,name=dst_port_range,json=dstPortRange,proto3" json:"dst_port_range,omitempty"`
}

func (x *PortListMatch) Reset() {
	*x = PortListMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PortListMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortListMatch) ProtoMessage() {}

func (x *PortListMatch) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortListMatch.ProtoReflect.Descriptor instead.
func (*PortListMatch) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{14}
}

func (x *PortListMatch) GetSrcPortRange() []*PortRange {
	if x != nil {
		return x.SrcPortRange
	}
	return nil
}

func (x *PortListMatch) GetDstPortRange() []*PortRange {
	if x != nil {
		return x.DstPortRange
	}
	return nil
}

// ICMP type/code match condition list
type ICMPMatchList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ICMP type/code list
	IcmpMatchList []*ICMPMatch `protobuf:"bytes,1,rep,name=icmp_match_list,json=icmpMatchList,proto3" json:"icmp_match_list,omitempty"`
}

func (x *ICMPMatchList) Reset() {
	*x = ICMPMatchList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ICMPMatchList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ICMPMatchList) ProtoMessage() {}

func (x *ICMPMatchList) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ICMPMatchList.ProtoReflect.Descriptor instead.
func (*ICMPMatchList) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{15}
}

func (x *ICMPMatchList) GetIcmpMatchList() []*ICMPMatch {
	if x != nil {
		return x.IcmpMatchList
	}
	return nil
}

// L4 rule match criteria
type RuleL4Match struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to L4Info:
	//	*RuleL4Match_Ports
	//	*RuleL4Match_TypeCode
	//	*RuleL4Match_PortList
	//	*RuleL4Match_IcmpMatchList
	L4Info isRuleL4Match_L4Info `protobuf_oneof:"l4info"`
}

func (x *RuleL4Match) Reset() {
	*x = RuleL4Match{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RuleL4Match) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuleL4Match) ProtoMessage() {}

func (x *RuleL4Match) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuleL4Match.ProtoReflect.Descriptor instead.
func (*RuleL4Match) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{16}
}

func (m *RuleL4Match) GetL4Info() isRuleL4Match_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (x *RuleL4Match) GetPorts() *PortMatch {
	if x, ok := x.GetL4Info().(*RuleL4Match_Ports); ok {
		return x.Ports
	}
	return nil
}

func (x *RuleL4Match) GetTypeCode() *ICMPMatch {
	if x, ok := x.GetL4Info().(*RuleL4Match_TypeCode); ok {
		return x.TypeCode
	}
	return nil
}

func (x *RuleL4Match) GetPortList() *PortListMatch {
	if x, ok := x.GetL4Info().(*RuleL4Match_PortList); ok {
		return x.PortList
	}
	return nil
}

func (x *RuleL4Match) GetIcmpMatchList() *ICMPMatchList {
	if x, ok := x.GetL4Info().(*RuleL4Match_IcmpMatchList); ok {
		return x.IcmpMatchList
	}
	return nil
}

type isRuleL4Match_L4Info interface {
	isRuleL4Match_L4Info()
}

type RuleL4Match_Ports struct {
	// source and/or destination ports/ranges
	Ports *PortMatch `protobuf:"bytes,1,opt,name=ports,proto3,oneof"`
}

type RuleL4Match_TypeCode struct {
	// ICMP type/code match criteria
	TypeCode *ICMPMatch `protobuf:"bytes,2,opt,name=type_code,json=typeCode,proto3,oneof"`
}

type RuleL4Match_PortList struct {
	// list of source and/or destination ports/ranges
	PortList *PortListMatch `protobuf:"bytes,3,opt,name=port_list,json=portList,proto3,oneof"`
}

type RuleL4Match_IcmpMatchList struct {
	// list ICMP type/code match criteria
	IcmpMatchList *ICMPMatchList `protobuf:"bytes,4,opt,name=icmp_match_list,json=icmpMatchList,proto3,oneof"`
}

func (*RuleL4Match_Ports) isRuleL4Match_L4Info() {}

func (*RuleL4Match_TypeCode) isRuleL4Match_L4Info() {}

func (*RuleL4Match_PortList) isRuleL4Match_L4Info() {}

func (*RuleL4Match_IcmpMatchList) isRuleL4Match_L4Info() {}

// rule match criteria
type RuleMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Layer 3 match criteria
	L3Match *RuleL3Match `protobuf:"bytes,1,opt,name=l3_match,json=l3Match,proto3" json:"l3_match,omitempty"`
	// Layer 4 match criteria
	L4Match *RuleL4Match `protobuf:"bytes,2,opt,name=l4_match,json=l4Match,proto3" json:"l4_match,omitempty"`
}

func (x *RuleMatch) Reset() {
	*x = RuleMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RuleMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuleMatch) ProtoMessage() {}

func (x *RuleMatch) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuleMatch.ProtoReflect.Descriptor instead.
func (*RuleMatch) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{17}
}

func (x *RuleMatch) GetL3Match() *RuleL3Match {
	if x != nil {
		return x.L3Match
	}
	return nil
}

func (x *RuleMatch) GetL4Match() *RuleL4Match {
	if x != nil {
		return x.L4Match
	}
	return nil
}

// Opaque handle to identify the index in hardware
type HwHandle struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// hardware handle
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: hw handle must be uint64. --)
	Idx uint64 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
}

func (x *HwHandle) Reset() {
	*x = HwHandle{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networktypes_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HwHandle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HwHandle) ProtoMessage() {}

func (x *HwHandle) ProtoReflect() protoreflect.Message {
	mi := &file_networktypes_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HwHandle.ProtoReflect.Descriptor instead.
func (*HwHandle) Descriptor() ([]byte, []int) {
	return file_networktypes_proto_rawDescGZIP(), []int{18}
}

func (x *HwHandle) GetIdx() uint64 {
	if x != nil {
		return x.Idx
	}
	return 0
}

var File_networktypes_proto protoreflect.FileDescriptor

var file_networktypes_proto_rawDesc = []byte{
	0x0a, 0x12, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x25, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x22, 0x8a, 0x01, 0x0a, 0x09,
	0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3b, 0x0a, 0x02, 0x61, 0x66, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x70,
	0x41, 0x66, 0x52, 0x02, 0x61, 0x66, 0x12, 0x19, 0x0a, 0x07, 0x76, 0x34, 0x5f, 0x61, 0x64, 0x64,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x48, 0x00, 0x52, 0x06, 0x76, 0x34, 0x41, 0x64, 0x64,
	0x72, 0x12, 0x19, 0x0a, 0x07, 0x76, 0x36, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0c, 0x48, 0x00, 0x52, 0x06, 0x76, 0x36, 0x41, 0x64, 0x64, 0x72, 0x42, 0x0a, 0x0a, 0x08,
	0x76, 0x34, 0x5f, 0x6f, 0x72, 0x5f, 0x76, 0x36, 0x22, 0x62, 0x0a, 0x08, 0x49, 0x50, 0x50, 0x72,
	0x65, 0x66, 0x69, 0x78, 0x12, 0x44, 0x0a, 0x04, 0x61, 0x64, 0x64, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x04, 0x61, 0x64, 0x64, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x65,
	0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6c, 0x65, 0x6e, 0x22, 0x32, 0x0a, 0x0a,
	0x49, 0x50, 0x76, 0x34, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x64,
	0x64, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x61, 0x64, 0x64, 0x72, 0x12, 0x10,
	0x0a, 0x03, 0x6c, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x6c, 0x65, 0x6e,
	0x22, 0x32, 0x0a, 0x0a, 0x49, 0x50, 0x76, 0x36, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x12,
	0x0a, 0x04, 0x61, 0x64, 0x64, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x61, 0x64,
	0x64, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x03, 0x6c, 0x65, 0x6e, 0x22, 0x75, 0x0a, 0x08, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x56, 0x61, 0x6c,
	0x12, 0x19, 0x0a, 0x07, 0x76, 0x6c, 0x61, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x48, 0x00, 0x52, 0x06, 0x76, 0x6c, 0x61, 0x6e, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x08, 0x6d,
	0x70, 0x6c, 0x73, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52,
	0x07, 0x6d, 0x70, 0x6c, 0x73, 0x54, 0x61, 0x67, 0x12, 0x14, 0x0a, 0x04, 0x76, 0x6e, 0x69, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x04, 0x76, 0x6e, 0x69, 0x64, 0x12, 0x14,
	0x0a, 0x04, 0x76, 0x73, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x04,
	0x76, 0x73, 0x69, 0x64, 0x42, 0x05, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x94, 0x01, 0x0a, 0x05,
	0x45, 0x6e, 0x63, 0x61, 0x70, 0x12, 0x44, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x45, 0x6e, 0x63, 0x61,
	0x70, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x45, 0x0a, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69,
	0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x22, 0x43, 0x0a, 0x09, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12,
	0x19, 0x0a, 0x08, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x6c, 0x6f, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x4c, 0x6f, 0x77, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x6f,
	0x72, 0x74, 0x5f, 0x68, 0x69, 0x67, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70,
	0x6f, 0x72, 0x74, 0x48, 0x69, 0x67, 0x68, 0x22, 0x93, 0x01, 0x0a, 0x07, 0x49, 0x50, 0x52, 0x61,
	0x6e, 0x67, 0x65, 0x12, 0x42, 0x0a, 0x03, 0x6c, 0x6f, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x03, 0x6c, 0x6f, 0x77, 0x12, 0x44, 0x0a, 0x04, 0x68, 0x69, 0x67, 0x68, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x04, 0x68, 0x69, 0x67, 0x68, 0x22, 0xb9, 0x01,
	0x0a, 0x0c, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x4f,
	0x0a, 0x0a, 0x69, 0x70, 0x76, 0x34, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x52, 0x61, 0x6e,
	0x67, 0x65, 0x48, 0x00, 0x52, 0x09, 0x69, 0x70, 0x76, 0x34, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12,
	0x4f, 0x0a, 0x0a, 0x69, 0x70, 0x76, 0x36, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x52, 0x61,
	0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x09, 0x69, 0x70, 0x76, 0x36, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x42, 0x07, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x22, 0xc1, 0x01, 0x0a, 0x07, 0x49, 0x50,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x49, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50,
	0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x48, 0x00, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78,
	0x12, 0x4b, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x33, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52,
	0x61, 0x6e, 0x67, 0x65, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x12, 0x0a,
	0x03, 0x74, 0x61, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x03, 0x74, 0x61,
	0x67, 0x42, 0x0a, 0x0a, 0x08, 0x69, 0x70, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x22, 0x57, 0x0a,
	0x06, 0x49, 0x50, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x4d, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x65, 0x6e,
	0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70,
	0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09, 0x69, 0x70, 0x45,
	0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0xd6, 0x05, 0x0a, 0x0b, 0x52, 0x75, 0x6c, 0x65, 0x4c,
	0x33, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x1d, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x5f,
	0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x08, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x4e, 0x75, 0x6d, 0x12, 0x5e, 0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x5f, 0x77,
	0x69, 0x6c, 0x64, 0x5f, 0x63, 0x61, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x0d, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x57, 0x69, 0x6c,
	0x64, 0x43, 0x61, 0x72, 0x64, 0x12, 0x50, 0x0a, 0x0a, 0x73, 0x72, 0x63, 0x5f, 0x70, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e,
	0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x49, 0x50, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x48, 0x01, 0x52, 0x09, 0x73, 0x72,
	0x63, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x52, 0x0a, 0x09, 0x73, 0x72, 0x63, 0x5f, 0x72,
	0x61, 0x6e, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69,
	0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x48,
	0x01, 0x52, 0x08, 0x73, 0x72, 0x63, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x19, 0x0a, 0x07, 0x73,
	0x72, 0x63, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x48, 0x01, 0x52, 0x06,
	0x73, 0x72, 0x63, 0x54, 0x61, 0x67, 0x12, 0x4f, 0x0a, 0x0b, 0x73, 0x72, 0x63, 0x5f, 0x69, 0x70,
	0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70,
	0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x01, 0x52, 0x09, 0x73, 0x72,
	0x63, 0x49, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x50, 0x0a, 0x0a, 0x64, 0x73, 0x74, 0x5f, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70,
	0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x48, 0x02, 0x52, 0x09,
	0x64, 0x73, 0x74, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x52, 0x0a, 0x09, 0x64, 0x73, 0x74,
	0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f,
	0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x61, 0x6e, 0x67,
	0x65, 0x48, 0x02, 0x52, 0x08, 0x64, 0x73, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x19, 0x0a,
	0x07, 0x64, 0x73, 0x74, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x48, 0x02,
	0x52, 0x06, 0x64, 0x73, 0x74, 0x54, 0x61, 0x67, 0x12, 0x4f, 0x0a, 0x0b, 0x64, 0x73, 0x74, 0x5f,
	0x69, 0x70, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
	0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x02, 0x52, 0x09,
	0x64, 0x73, 0x74, 0x49, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x0c, 0x0a, 0x0a, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x0a, 0x0a, 0x08, 0x73, 0x72, 0x63, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x42, 0x0a, 0x0a, 0x08, 0x64, 0x73, 0x74, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x22,
	0xbb, 0x01, 0x0a, 0x09, 0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x56, 0x0a,
	0x0e, 0x73, 0x72, 0x63, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0c, 0x73, 0x72, 0x63, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x56, 0x0a, 0x0e, 0x64, 0x73, 0x74, 0x5f, 0x70, 0x6f, 0x72,
	0x74, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
	0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52,
	0x0c, 0x64, 0x73, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x22, 0x8b, 0x02,
	0x0a, 0x09, 0x49, 0x43, 0x4d, 0x50, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x14, 0x0a, 0x04, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x12, 0x5b, 0x0a, 0x0d, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x77, 0x69, 0x6c, 0x64, 0x63, 0x61,
	0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61,
	0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65,
	0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00,
	0x52, 0x0c, 0x74, 0x79, 0x70, 0x65, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x12, 0x14,
	0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x01, 0x52, 0x04,
	0x63, 0x6f, 0x64, 0x65, 0x12, 0x5b, 0x0a, 0x0d, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x77, 0x69, 0x6c,
	0x64, 0x63, 0x61, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70,
	0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x48, 0x01, 0x52, 0x0c, 0x63, 0x6f, 0x64, 0x65, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72,
	0x64, 0x42, 0x0b, 0x0a, 0x09, 0x74, 0x79, 0x70, 0x65, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x0b,
	0x0a, 0x09, 0x63, 0x6f, 0x64, 0x65, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x22, 0xbf, 0x01, 0x0a, 0x0d,
	0x50, 0x6f, 0x72, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x56, 0x0a,
	0x0e, 0x73, 0x72, 0x63, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f,
	0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x0c, 0x73, 0x72, 0x63, 0x50, 0x6f, 0x72, 0x74,
	0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x56, 0x0a, 0x0e, 0x64, 0x73, 0x74, 0x5f, 0x70, 0x6f, 0x72,
	0x74, 0x5f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
	0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52,
	0x0c, 0x64, 0x73, 0x74, 0x50, 0x6f, 0x72, 0x74, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x22, 0x69, 0x0a,
	0x0d, 0x49, 0x43, 0x4d, 0x50, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x58,
	0x0a, 0x0f, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x6c, 0x69, 0x73,
	0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x49, 0x43, 0x4d, 0x50, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x0d, 0x69, 0x63, 0x6d, 0x70, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x22, 0xe7, 0x02, 0x0a, 0x0b, 0x52, 0x75, 0x6c,
	0x65, 0x4c, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x48, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x05, 0x70, 0x6f, 0x72,
	0x74, 0x73, 0x12, 0x4f, 0x0a, 0x09, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x43,
	0x4d, 0x50, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x08, 0x74, 0x79, 0x70, 0x65, 0x43,
	0x6f, 0x64, 0x65, 0x12, 0x53, 0x0a, 0x09, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x6c, 0x69, 0x73, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50,
	0x6f, 0x72, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x08,
	0x70, 0x6f, 0x72, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x5e, 0x0a, 0x0f, 0x69, 0x63, 0x6d, 0x70,
	0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x34, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x43, 0x4d, 0x50, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x69, 0x63, 0x6d, 0x70, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x08, 0x0a, 0x06, 0x6c, 0x34, 0x69, 0x6e,
	0x66, 0x6f, 0x22, 0xa9, 0x01, 0x0a, 0x09, 0x52, 0x75, 0x6c, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x4d, 0x0a, 0x08, 0x6c, 0x33, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x4c,
	0x33, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x07, 0x6c, 0x33, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12,
	0x4d, 0x0a, 0x08, 0x6c, 0x34, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x4c, 0x34,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x07, 0x6c, 0x34, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x22, 0x1c,
	0x0a, 0x08, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x69, 0x64,
	0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x69, 0x64, 0x78, 0x2a, 0x72, 0x0a, 0x12,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x19, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x52,
	0x55, 0x4c, 0x45, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x10,
	0x00, 0x12, 0x1e, 0x0a, 0x1a, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x52, 0x55,
	0x4c, 0x45, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x41, 0x4c, 0x4c, 0x4f, 0x57, 0x10,
	0x01, 0x12, 0x1d, 0x0a, 0x19, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x52, 0x55,
	0x4c, 0x45, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x45, 0x4e, 0x59, 0x10, 0x02,
	0x2a, 0x3e, 0x0a, 0x04, 0x49, 0x70, 0x41, 0x66, 0x12, 0x15, 0x0a, 0x11, 0x49, 0x50, 0x5f, 0x41,
	0x46, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12,
	0x0e, 0x0a, 0x0a, 0x49, 0x50, 0x5f, 0x41, 0x46, 0x5f, 0x49, 0x4e, 0x45, 0x54, 0x10, 0x01, 0x12,
	0x0f, 0x0a, 0x0b, 0x49, 0x50, 0x5f, 0x41, 0x46, 0x5f, 0x49, 0x4e, 0x45, 0x54, 0x36, 0x10, 0x02,
	0x2a, 0x87, 0x01, 0x0a, 0x09, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a,
	0x0a, 0x16, 0x45, 0x4e, 0x43, 0x41, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x45, 0x4e,
	0x43, 0x41, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x44, 0x4f, 0x54, 0x31, 0x51, 0x10, 0x01,
	0x12, 0x1c, 0x0a, 0x18, 0x45, 0x4e, 0x43, 0x41, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d,
	0x50, 0x4c, 0x53, 0x5f, 0x4f, 0x56, 0x45, 0x52, 0x5f, 0x55, 0x44, 0x50, 0x10, 0x02, 0x12, 0x14,
	0x0a, 0x10, 0x45, 0x4e, 0x43, 0x41, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x58, 0x4c,
	0x41, 0x4e, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x45, 0x4e, 0x43, 0x41, 0x50, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x4e, 0x56, 0x47, 0x52, 0x45, 0x10, 0x04, 0x2a, 0x81, 0x01, 0x0a, 0x09, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x4f, 0x55, 0x54,
	0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x4f, 0x54, 0x48, 0x45, 0x52, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x52, 0x4f,
	0x55, 0x54, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x4a, 0x45, 0x43, 0x54, 0x10,
	0x02, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x4c, 0x4f, 0x43, 0x41, 0x4c, 0x10, 0x03, 0x12, 0x15, 0x0a, 0x11, 0x52, 0x4f, 0x55, 0x54, 0x45,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x54, 0x45, 0x10, 0x04, 0x2a, 0x7c,
	0x0a, 0x0d, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12,
	0x1e, 0x0a, 0x1a, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x5f, 0x50, 0x52, 0x4f, 0x54, 0x4f, 0x43, 0x4f,
	0x4c, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12,
	0x18, 0x0a, 0x14, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x5f, 0x50, 0x52, 0x4f, 0x54, 0x4f, 0x43, 0x4f,
	0x4c, 0x5f, 0x4c, 0x4f, 0x43, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x4f, 0x55,
	0x54, 0x45, 0x5f, 0x50, 0x52, 0x4f, 0x54, 0x4f, 0x43, 0x4f, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x54,
	0x49, 0x43, 0x10, 0x02, 0x12, 0x16, 0x0a, 0x12, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x5f, 0x50, 0x52,
	0x4f, 0x54, 0x4f, 0x43, 0x4f, 0x4c, 0x5f, 0x42, 0x47, 0x50, 0x10, 0x03, 0x2a, 0x5a, 0x0a, 0x0a,
	0x41, 0x64, 0x6d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x41, 0x44,
	0x4d, 0x49, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x41, 0x44, 0x4d, 0x49, 0x4e,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x45, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x01, 0x12,
	0x17, 0x0a, 0x13, 0x41, 0x44, 0x4d, 0x49, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x44,
	0x49, 0x53, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x02, 0x2a, 0x56, 0x0a, 0x09, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x44, 0x69, 0x72, 0x12, 0x1a, 0x0a, 0x16, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f,
	0x44, 0x49, 0x52, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10,
	0x00, 0x12, 0x16, 0x0a, 0x12, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x44, 0x49, 0x52, 0x5f,
	0x49, 0x4e, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11, 0x50, 0x4f, 0x4c,
	0x49, 0x43, 0x59, 0x5f, 0x44, 0x49, 0x52, 0x5f, 0x45, 0x47, 0x52, 0x45, 0x53, 0x53, 0x10, 0x02,
	0x2a, 0x2f, 0x0a, 0x0d, 0x57, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x4d, 0x61, 0x74, 0x63,
	0x68, 0x12, 0x0e, 0x0a, 0x0a, 0x4d, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x4e, 0x4f, 0x4e, 0x45, 0x10,
	0x00, 0x12, 0x0e, 0x0a, 0x09, 0x4d, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x41, 0x4e, 0x59, 0x10, 0x80,
	0x02, 0x42, 0x80, 0x01, 0x0a, 0x25, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x42, 0x11, 0x4e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x54, 0x79, 0x70, 0x65, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01,
	0x5a, 0x42, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x70, 0x69,
	0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6f, 0x70, 0x69, 0x2d, 0x61, 0x70, 0x69, 0x2f,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2f, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2f, 0x67, 0x65,
	0x6e, 0x2f, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_networktypes_proto_rawDescOnce sync.Once
	file_networktypes_proto_rawDescData = file_networktypes_proto_rawDesc
)

func file_networktypes_proto_rawDescGZIP() []byte {
	file_networktypes_proto_rawDescOnce.Do(func() {
		file_networktypes_proto_rawDescData = protoimpl.X.CompressGZIP(file_networktypes_proto_rawDescData)
	})
	return file_networktypes_proto_rawDescData
}

var file_networktypes_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_networktypes_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_networktypes_proto_goTypes = []interface{}{
	(SecurityRuleAction)(0), // 0: opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	(IpAf)(0),               // 1: opi_api.network.opinetcommon.v1alpha1.IpAf
	(EncapType)(0),          // 2: opi_api.network.opinetcommon.v1alpha1.EncapType
	(RouteType)(0),          // 3: opi_api.network.opinetcommon.v1alpha1.RouteType
	(RouteProtocol)(0),      // 4: opi_api.network.opinetcommon.v1alpha1.RouteProtocol
	(AdminState)(0),         // 5: opi_api.network.opinetcommon.v1alpha1.AdminState
	(PolicyDir)(0),          // 6: opi_api.network.opinetcommon.v1alpha1.PolicyDir
	(WildcardMatch)(0),      // 7: opi_api.network.opinetcommon.v1alpha1.WildcardMatch
	(*IPAddress)(nil),       // 8: opi_api.network.opinetcommon.v1alpha1.IPAddress
	(*IPPrefix)(nil),        // 9: opi_api.network.opinetcommon.v1alpha1.IPPrefix
	(*IPv4Prefix)(nil),      // 10: opi_api.network.opinetcommon.v1alpha1.IPv4Prefix
	(*IPv6Prefix)(nil),      // 11: opi_api.network.opinetcommon.v1alpha1.IPv6Prefix
	(*EncapVal)(nil),        // 12: opi_api.network.opinetcommon.v1alpha1.EncapVal
	(*Encap)(nil),           // 13: opi_api.network.opinetcommon.v1alpha1.Encap
	(*PortRange)(nil),       // 14: opi_api.network.opinetcommon.v1alpha1.PortRange
	(*IPRange)(nil),         // 15: opi_api.network.opinetcommon.v1alpha1.IPRange
	(*AddressRange)(nil),    // 16: opi_api.network.opinetcommon.v1alpha1.AddressRange
	(*IPEntry)(nil),         // 17: opi_api.network.opinetcommon.v1alpha1.IPEntry
	(*IPList)(nil),          // 18: opi_api.network.opinetcommon.v1alpha1.IPList
	(*RuleL3Match)(nil),     // 19: opi_api.network.opinetcommon.v1alpha1.RuleL3Match
	(*PortMatch)(nil),       // 20: opi_api.network.opinetcommon.v1alpha1.PortMatch
	(*ICMPMatch)(nil),       // 21: opi_api.network.opinetcommon.v1alpha1.ICMPMatch
	(*PortListMatch)(nil),   // 22: opi_api.network.opinetcommon.v1alpha1.PortListMatch
	(*ICMPMatchList)(nil),   // 23: opi_api.network.opinetcommon.v1alpha1.ICMPMatchList
	(*RuleL4Match)(nil),     // 24: opi_api.network.opinetcommon.v1alpha1.RuleL4Match
	(*RuleMatch)(nil),       // 25: opi_api.network.opinetcommon.v1alpha1.RuleMatch
	(*HwHandle)(nil),        // 26: opi_api.network.opinetcommon.v1alpha1.HwHandle
}
var file_networktypes_proto_depIdxs = []int32{
	1,  // 0: opi_api.network.opinetcommon.v1alpha1.IPAddress.af:type_name -> opi_api.network.opinetcommon.v1alpha1.IpAf
	8,  // 1: opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	2,  // 2: opi_api.network.opinetcommon.v1alpha1.Encap.type:type_name -> opi_api.network.opinetcommon.v1alpha1.EncapType
	12, // 3: opi_api.network.opinetcommon.v1alpha1.Encap.value:type_name -> opi_api.network.opinetcommon.v1alpha1.EncapVal
	8,  // 4: opi_api.network.opinetcommon.v1alpha1.IPRange.low:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	8,  // 5: opi_api.network.opinetcommon.v1alpha1.IPRange.high:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	15, // 6: opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range:type_name -> opi_api.network.opinetcommon.v1alpha1.IPRange
	15, // 7: opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range:type_name -> opi_api.network.opinetcommon.v1alpha1.IPRange
	9,  // 8: opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	16, // 9: opi_api.network.opinetcommon.v1alpha1.IPEntry.range:type_name -> opi_api.network.opinetcommon.v1alpha1.AddressRange
	17, // 10: opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries:type_name -> opi_api.network.opinetcommon.v1alpha1.IPEntry
	7,  // 11: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.proto_wild_card:type_name -> opi_api.network.opinetcommon.v1alpha1.WildcardMatch
	9,  // 12: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	16, // 13: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range:type_name -> opi_api.network.opinetcommon.v1alpha1.AddressRange
	18, // 14: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list:type_name -> opi_api.network.opinetcommon.v1alpha1.IPList
	9,  // 15: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	16, // 16: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range:type_name -> opi_api.network.opinetcommon.v1alpha1.AddressRange
	18, // 17: opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list:type_name -> opi_api.network.opinetcommon.v1alpha1.IPList
	14, // 18: opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range:type_name -> opi_api.network.opinetcommon.v1alpha1.PortRange
	14, // 19: opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range:type_name -> opi_api.network.opinetcommon.v1alpha1.PortRange
	7,  // 20: opi_api.network.opinetcommon.v1alpha1.ICMPMatch.type_wildcard:type_name -> opi_api.network.opinetcommon.v1alpha1.WildcardMatch
	7,  // 21: opi_api.network.opinetcommon.v1alpha1.ICMPMatch.code_wildcard:type_name -> opi_api.network.opinetcommon.v1alpha1.WildcardMatch
	14, // 22: opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range:type_name -> opi_api.network.opinetcommon.v1alpha1.PortRange
	14, // 23: opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range:type_name -> opi_api.network.opinetcommon.v1alpha1.PortRange
	21, // 24: opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list:type_name -> opi_api.network.opinetcommon.v1alpha1.ICMPMatch
	20, // 25: opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports:type_name -> opi_api.network.opinetcommon.v1alpha1.PortMatch
	21, // 26: opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code:type_name -> opi_api.network.opinetcommon.v1alpha1.ICMPMatch
	22, // 27: opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list:type_name -> opi_api.network.opinetcommon.v1alpha1.PortListMatch
	23, // 28: opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list:type_name -> opi_api.network.opinetcommon.v1alpha1.ICMPMatchList
	19, // 29: opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match:type_name -> opi_api.network.opinetcommon.v1alpha1.RuleL3Match
	24, // 30: opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match:type_name -> opi_api.network.opinetcommon.v1alpha1.RuleL4Match
	31, // [31:31] is the sub-list for method output_type
	31, // [31:31] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_networktypes_proto_init() }
func file_networktypes_proto_init() {
	if File_networktypes_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_networktypes_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPPrefix); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPv4Prefix); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPv6Prefix); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncapVal); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Encap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PortRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AddressRange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IPList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RuleL3Match); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PortMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ICMPMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PortListMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ICMPMatchList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RuleL4Match); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RuleMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networktypes_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HwHandle); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_networktypes_proto_msgTypes[0].OneofWrappers = []interface{}{
		(*IPAddress_V4Addr)(nil),
		(*IPAddress_V6Addr)(nil),
	}
	file_networktypes_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*EncapVal_VlanId)(nil),
		(*EncapVal_MplsTag)(nil),
		(*EncapVal_Vnid)(nil),
		(*EncapVal_Vsid)(nil),
	}
	file_networktypes_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*AddressRange_Ipv4Range)(nil),
		(*AddressRange_Ipv6Range)(nil),
	}
	file_networktypes_proto_msgTypes[9].OneofWrappers = []interface{}{
		(*IPEntry_Prefix)(nil),
		(*IPEntry_Range)(nil),
		(*IPEntry_Tag)(nil),
	}
	file_networktypes_proto_msgTypes[11].OneofWrappers = []interface{}{
		(*RuleL3Match_ProtoNum)(nil),
		(*RuleL3Match_ProtoWildCard)(nil),
		(*RuleL3Match_SrcPrefix)(nil),
		(*RuleL3Match_SrcRange)(nil),
		(*RuleL3Match_SrcTag)(nil),
		(*RuleL3Match_SrcIpList)(nil),
		(*RuleL3Match_DstPrefix)(nil),
		(*RuleL3Match_DstRange)(nil),
		(*RuleL3Match_DstTag)(nil),
		(*RuleL3Match_DstIpList)(nil),
	}
	file_networktypes_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*ICMPMatch_Type)(nil),
		(*ICMPMatch_TypeWildcard)(nil),
		(*ICMPMatch_Code)(nil),
		(*ICMPMatch_CodeWildcard)(nil),
	}
	file_networktypes_proto_msgTypes[16].OneofWrappers = []interface{}{
		(*RuleL4Match_Ports)(nil),
		(*RuleL4Match_TypeCode)(nil),
		(*RuleL4Match_PortList)(nil),
		(*RuleL4Match_IcmpMatchList)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_networktypes_proto_rawDesc,
			NumEnums:      8,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_networktypes_proto_goTypes,
		DependencyIndexes: file_networktypes_proto_depIdxs,
		EnumInfos:         file_networktypes_proto_enumTypes,
		MessageInfos:      file_networktypes_proto_msgTypes,
	}.Build()
	File_networktypes_proto = out.File
	file_networktypes_proto_rawDesc = nil
	file_networktypes_proto_goTypes = nil
	file_networktypes_proto_depIdxs = nil
}
