// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: networktypes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_networktypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_networktypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_networktypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_networktypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_networktypes_2eproto;
namespace opi_api {
namespace network {
namespace opinetcommon {
namespace v1alpha1 {
class AddressRange;
struct AddressRangeDefaultTypeInternal;
extern AddressRangeDefaultTypeInternal _AddressRange_default_instance_;
class Encap;
struct EncapDefaultTypeInternal;
extern EncapDefaultTypeInternal _Encap_default_instance_;
class EncapVal;
struct EncapValDefaultTypeInternal;
extern EncapValDefaultTypeInternal _EncapVal_default_instance_;
class HwHandle;
struct HwHandleDefaultTypeInternal;
extern HwHandleDefaultTypeInternal _HwHandle_default_instance_;
class ICMPMatch;
struct ICMPMatchDefaultTypeInternal;
extern ICMPMatchDefaultTypeInternal _ICMPMatch_default_instance_;
class ICMPMatchList;
struct ICMPMatchListDefaultTypeInternal;
extern ICMPMatchListDefaultTypeInternal _ICMPMatchList_default_instance_;
class IPAddress;
struct IPAddressDefaultTypeInternal;
extern IPAddressDefaultTypeInternal _IPAddress_default_instance_;
class IPEntry;
struct IPEntryDefaultTypeInternal;
extern IPEntryDefaultTypeInternal _IPEntry_default_instance_;
class IPList;
struct IPListDefaultTypeInternal;
extern IPListDefaultTypeInternal _IPList_default_instance_;
class IPPrefix;
struct IPPrefixDefaultTypeInternal;
extern IPPrefixDefaultTypeInternal _IPPrefix_default_instance_;
class IPRange;
struct IPRangeDefaultTypeInternal;
extern IPRangeDefaultTypeInternal _IPRange_default_instance_;
class IPv4Prefix;
struct IPv4PrefixDefaultTypeInternal;
extern IPv4PrefixDefaultTypeInternal _IPv4Prefix_default_instance_;
class IPv6Prefix;
struct IPv6PrefixDefaultTypeInternal;
extern IPv6PrefixDefaultTypeInternal _IPv6Prefix_default_instance_;
class PortListMatch;
struct PortListMatchDefaultTypeInternal;
extern PortListMatchDefaultTypeInternal _PortListMatch_default_instance_;
class PortMatch;
struct PortMatchDefaultTypeInternal;
extern PortMatchDefaultTypeInternal _PortMatch_default_instance_;
class PortRange;
struct PortRangeDefaultTypeInternal;
extern PortRangeDefaultTypeInternal _PortRange_default_instance_;
class RuleL3Match;
struct RuleL3MatchDefaultTypeInternal;
extern RuleL3MatchDefaultTypeInternal _RuleL3Match_default_instance_;
class RuleL4Match;
struct RuleL4MatchDefaultTypeInternal;
extern RuleL4MatchDefaultTypeInternal _RuleL4Match_default_instance_;
class RuleMatch;
struct RuleMatchDefaultTypeInternal;
extern RuleMatchDefaultTypeInternal _RuleMatch_default_instance_;
}  // namespace v1alpha1
}  // namespace opinetcommon
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::opinetcommon::v1alpha1::AddressRange* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::AddressRange>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::Encap* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::Encap>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::EncapVal* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::EncapVal>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::HwHandle* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::ICMPMatch>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPAddress* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPEntry* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPEntry>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPList* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPList>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPPrefix>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPRange* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPRange>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPv4Prefix* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPv4Prefix>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::IPv6Prefix* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPv6Prefix>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::PortListMatch>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::PortMatch* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::PortMatch>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::PortRange* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::PortRange>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::RuleL3Match>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::RuleL4Match>(Arena*);
template<> ::opi_api::network::opinetcommon::v1alpha1::RuleMatch* Arena::CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::RuleMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace opinetcommon {
namespace v1alpha1 {

enum SecurityRuleAction : int {
  SECURITY_RULE_ACTION_NONE = 0,
  SECURITY_RULE_ACTION_ALLOW = 1,
  SECURITY_RULE_ACTION_DENY = 2,
  SecurityRuleAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecurityRuleAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecurityRuleAction_IsValid(int value);
constexpr SecurityRuleAction SecurityRuleAction_MIN = SECURITY_RULE_ACTION_NONE;
constexpr SecurityRuleAction SecurityRuleAction_MAX = SECURITY_RULE_ACTION_DENY;
constexpr int SecurityRuleAction_ARRAYSIZE = SecurityRuleAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityRuleAction_descriptor();
template<typename T>
inline const std::string& SecurityRuleAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecurityRuleAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecurityRuleAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecurityRuleAction_descriptor(), enum_t_value);
}
inline bool SecurityRuleAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityRuleAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityRuleAction>(
    SecurityRuleAction_descriptor(), name, value);
}
enum IpAf : int {
  IP_AF_UNSPECIFIED = 0,
  IP_AF_INET = 1,
  IP_AF_INET6 = 2,
  IpAf_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IpAf_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IpAf_IsValid(int value);
constexpr IpAf IpAf_MIN = IP_AF_UNSPECIFIED;
constexpr IpAf IpAf_MAX = IP_AF_INET6;
constexpr int IpAf_ARRAYSIZE = IpAf_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IpAf_descriptor();
template<typename T>
inline const std::string& IpAf_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IpAf>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IpAf_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IpAf_descriptor(), enum_t_value);
}
inline bool IpAf_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IpAf* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IpAf>(
    IpAf_descriptor(), name, value);
}
enum EncapType : int {
  ENCAP_TYPE_UNSPECIFIED = 0,
  ENCAP_TYPE_DOT1Q = 1,
  ENCAP_TYPE_MPLS_OVER_UDP = 2,
  ENCAP_TYPE_VXLAN = 3,
  ENCAP_TYPE_NVGRE = 4,
  EncapType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncapType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncapType_IsValid(int value);
constexpr EncapType EncapType_MIN = ENCAP_TYPE_UNSPECIFIED;
constexpr EncapType EncapType_MAX = ENCAP_TYPE_NVGRE;
constexpr int EncapType_ARRAYSIZE = EncapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncapType_descriptor();
template<typename T>
inline const std::string& EncapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncapType_descriptor(), enum_t_value);
}
inline bool EncapType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncapType>(
    EncapType_descriptor(), name, value);
}
enum RouteType : int {
  ROUTE_TYPE_UNSPECIFIED = 0,
  ROUTE_TYPE_OTHER = 1,
  ROUTE_TYPE_REJECT = 2,
  ROUTE_TYPE_LOCAL = 3,
  ROUTE_TYPE_REMOTE = 4,
  RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteType_IsValid(int value);
constexpr RouteType RouteType_MIN = ROUTE_TYPE_UNSPECIFIED;
constexpr RouteType RouteType_MAX = ROUTE_TYPE_REMOTE;
constexpr int RouteType_ARRAYSIZE = RouteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteType_descriptor();
template<typename T>
inline const std::string& RouteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteType_descriptor(), enum_t_value);
}
inline bool RouteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteType>(
    RouteType_descriptor(), name, value);
}
enum RouteProtocol : int {
  ROUTE_PROTOCOL_UNSPECIFIED = 0,
  ROUTE_PROTOCOL_LOCAL = 1,
  ROUTE_PROTOCOL_STATIC = 2,
  ROUTE_PROTOCOL_BGP = 3,
  RouteProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteProtocol_IsValid(int value);
constexpr RouteProtocol RouteProtocol_MIN = ROUTE_PROTOCOL_UNSPECIFIED;
constexpr RouteProtocol RouteProtocol_MAX = ROUTE_PROTOCOL_BGP;
constexpr int RouteProtocol_ARRAYSIZE = RouteProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteProtocol_descriptor();
template<typename T>
inline const std::string& RouteProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteProtocol_descriptor(), enum_t_value);
}
inline bool RouteProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteProtocol>(
    RouteProtocol_descriptor(), name, value);
}
enum AdminState : int {
  ADMIN_STATE_UNSPECIFIED = 0,
  ADMIN_STATE_ENABLE = 1,
  ADMIN_STATE_DISABLE = 2,
  AdminState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AdminState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AdminState_IsValid(int value);
constexpr AdminState AdminState_MIN = ADMIN_STATE_UNSPECIFIED;
constexpr AdminState AdminState_MAX = ADMIN_STATE_DISABLE;
constexpr int AdminState_ARRAYSIZE = AdminState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdminState_descriptor();
template<typename T>
inline const std::string& AdminState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdminState_descriptor(), enum_t_value);
}
inline bool AdminState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdminState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdminState>(
    AdminState_descriptor(), name, value);
}
enum PolicyDir : int {
  POLICY_DIR_UNSPECIFIED = 0,
  POLICY_DIR_INGRESS = 1,
  POLICY_DIR_EGRESS = 2,
  PolicyDir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PolicyDir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PolicyDir_IsValid(int value);
constexpr PolicyDir PolicyDir_MIN = POLICY_DIR_UNSPECIFIED;
constexpr PolicyDir PolicyDir_MAX = POLICY_DIR_EGRESS;
constexpr int PolicyDir_ARRAYSIZE = PolicyDir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PolicyDir_descriptor();
template<typename T>
inline const std::string& PolicyDir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyDir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyDir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PolicyDir_descriptor(), enum_t_value);
}
inline bool PolicyDir_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyDir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PolicyDir>(
    PolicyDir_descriptor(), name, value);
}
enum WildcardMatch : int {
  MATCH_NONE = 0,
  MATCH_ANY = 256,
  WildcardMatch_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WildcardMatch_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WildcardMatch_IsValid(int value);
constexpr WildcardMatch WildcardMatch_MIN = MATCH_NONE;
constexpr WildcardMatch WildcardMatch_MAX = MATCH_ANY;
constexpr int WildcardMatch_ARRAYSIZE = WildcardMatch_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WildcardMatch_descriptor();
template<typename T>
inline const std::string& WildcardMatch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WildcardMatch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WildcardMatch_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WildcardMatch_descriptor(), enum_t_value);
}
inline bool WildcardMatch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WildcardMatch* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WildcardMatch>(
    WildcardMatch_descriptor(), name, value);
}
// ===================================================================

class IPAddress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPAddress) */ {
 public:
  inline IPAddress() : IPAddress(nullptr) {}
  ~IPAddress() override;
  explicit constexpr IPAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPAddress(const IPAddress& from);
  IPAddress(IPAddress&& from) noexcept
    : IPAddress() {
    *this = ::std::move(from);
  }

  inline IPAddress& operator=(const IPAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPAddress& operator=(IPAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPAddress& default_instance() {
    return *internal_default_instance();
  }
  enum V4OrV6Case {
    kV4Addr = 2,
    kV6Addr = 3,
    V4_OR_V6_NOT_SET = 0,
  };

  static inline const IPAddress* internal_default_instance() {
    return reinterpret_cast<const IPAddress*>(
               &_IPAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IPAddress& a, IPAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(IPAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPAddress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPAddress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPAddress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPAddress";
  }
  protected:
  explicit IPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAfFieldNumber = 1,
    kV4AddrFieldNumber = 2,
    kV6AddrFieldNumber = 3,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IpAf af = 1;
  void clear_af();
  ::opi_api::network::opinetcommon::v1alpha1::IpAf af() const;
  void set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::IpAf _internal_af() const;
  void _internal_set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value);
  public:

  // fixed32 v4_addr = 2;
  bool has_v4_addr() const;
  private:
  bool _internal_has_v4_addr() const;
  public:
  void clear_v4_addr();
  uint32_t v4_addr() const;
  void set_v4_addr(uint32_t value);
  private:
  uint32_t _internal_v4_addr() const;
  void _internal_set_v4_addr(uint32_t value);
  public:

  // bytes v6_addr = 3;
  bool has_v6_addr() const;
  private:
  bool _internal_has_v6_addr() const;
  public:
  void clear_v6_addr();
  const std::string& v6_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v6_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v6_addr();
  PROTOBUF_NODISCARD std::string* release_v6_addr();
  void set_allocated_v6_addr(std::string* v6_addr);
  private:
  const std::string& _internal_v6_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v6_addr(const std::string& value);
  std::string* _internal_mutable_v6_addr();
  public:

  void clear_v4_or_v6();
  V4OrV6Case v4_or_v6_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPAddress)
 private:
  class _Internal;
  void set_has_v4_addr();
  void set_has_v6_addr();

  inline bool has_v4_or_v6() const;
  inline void clear_has_v4_or_v6();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int af_;
  union V4OrV6Union {
    constexpr V4OrV6Union() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t v4_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v6_addr_;
  } v4_or_v6_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPPrefix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPPrefix) */ {
 public:
  inline IPPrefix() : IPPrefix(nullptr) {}
  ~IPPrefix() override;
  explicit constexpr IPPrefix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPPrefix(const IPPrefix& from);
  IPPrefix(IPPrefix&& from) noexcept
    : IPPrefix() {
    *this = ::std::move(from);
  }

  inline IPPrefix& operator=(const IPPrefix& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPPrefix& operator=(IPPrefix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPPrefix& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPPrefix* internal_default_instance() {
    return reinterpret_cast<const IPPrefix*>(
               &_IPPrefix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IPPrefix& a, IPPrefix& b) {
    a.Swap(&b);
  }
  inline void Swap(IPPrefix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPPrefix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPPrefix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPPrefix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPPrefix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPPrefix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPPrefix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPPrefix";
  }
  protected:
  explicit IPPrefix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IPAddress addr = 1;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& addr() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_addr();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_addr();
  void set_allocated_addr(::opi_api::network::opinetcommon::v1alpha1::IPAddress* addr);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_addr() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_addr();
  public:
  void unsafe_arena_set_allocated_addr(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* addr);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_addr();

  // int32 len = 2;
  void clear_len();
  int32_t len() const;
  void set_len(int32_t value);
  private:
  int32_t _internal_len() const;
  void _internal_set_len(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPPrefix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* addr_;
  int32_t len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPv4Prefix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix) */ {
 public:
  inline IPv4Prefix() : IPv4Prefix(nullptr) {}
  ~IPv4Prefix() override;
  explicit constexpr IPv4Prefix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPv4Prefix(const IPv4Prefix& from);
  IPv4Prefix(IPv4Prefix&& from) noexcept
    : IPv4Prefix() {
    *this = ::std::move(from);
  }

  inline IPv4Prefix& operator=(const IPv4Prefix& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPv4Prefix& operator=(IPv4Prefix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPv4Prefix& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPv4Prefix* internal_default_instance() {
    return reinterpret_cast<const IPv4Prefix*>(
               &_IPv4Prefix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IPv4Prefix& a, IPv4Prefix& b) {
    a.Swap(&b);
  }
  inline void Swap(IPv4Prefix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPv4Prefix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPv4Prefix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPv4Prefix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPv4Prefix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPv4Prefix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPv4Prefix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPv4Prefix";
  }
  protected:
  explicit IPv4Prefix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // fixed32 addr = 1;
  void clear_addr();
  uint32_t addr() const;
  void set_addr(uint32_t value);
  private:
  uint32_t _internal_addr() const;
  void _internal_set_addr(uint32_t value);
  public:

  // int32 len = 2;
  void clear_len();
  int32_t len() const;
  void set_len(int32_t value);
  private:
  int32_t _internal_len() const;
  void _internal_set_len(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t addr_;
  int32_t len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPv6Prefix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix) */ {
 public:
  inline IPv6Prefix() : IPv6Prefix(nullptr) {}
  ~IPv6Prefix() override;
  explicit constexpr IPv6Prefix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPv6Prefix(const IPv6Prefix& from);
  IPv6Prefix(IPv6Prefix&& from) noexcept
    : IPv6Prefix() {
    *this = ::std::move(from);
  }

  inline IPv6Prefix& operator=(const IPv6Prefix& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPv6Prefix& operator=(IPv6Prefix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPv6Prefix& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPv6Prefix* internal_default_instance() {
    return reinterpret_cast<const IPv6Prefix*>(
               &_IPv6Prefix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IPv6Prefix& a, IPv6Prefix& b) {
    a.Swap(&b);
  }
  inline void Swap(IPv6Prefix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPv6Prefix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPv6Prefix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPv6Prefix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPv6Prefix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPv6Prefix& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPv6Prefix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPv6Prefix";
  }
  protected:
  explicit IPv6Prefix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kLenFieldNumber = 2,
  };
  // bytes addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // int32 len = 2;
  void clear_len();
  int32_t len() const;
  void set_len(int32_t value);
  private:
  int32_t _internal_len() const;
  void _internal_set_len(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  int32_t len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class EncapVal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.EncapVal) */ {
 public:
  inline EncapVal() : EncapVal(nullptr) {}
  ~EncapVal() override;
  explicit constexpr EncapVal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncapVal(const EncapVal& from);
  EncapVal(EncapVal&& from) noexcept
    : EncapVal() {
    *this = ::std::move(from);
  }

  inline EncapVal& operator=(const EncapVal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncapVal& operator=(EncapVal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncapVal& default_instance() {
    return *internal_default_instance();
  }
  enum ValCase {
    kVlanId = 1,
    kMplsTag = 2,
    kVnid = 3,
    kVsid = 5,
    VAL_NOT_SET = 0,
  };

  static inline const EncapVal* internal_default_instance() {
    return reinterpret_cast<const EncapVal*>(
               &_EncapVal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EncapVal& a, EncapVal& b) {
    a.Swap(&b);
  }
  inline void Swap(EncapVal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncapVal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncapVal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncapVal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncapVal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EncapVal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncapVal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.EncapVal";
  }
  protected:
  explicit EncapVal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVlanIdFieldNumber = 1,
    kMplsTagFieldNumber = 2,
    kVnidFieldNumber = 3,
    kVsidFieldNumber = 5,
  };
  // int32 vlan_id = 1;
  bool has_vlan_id() const;
  private:
  bool _internal_has_vlan_id() const;
  public:
  void clear_vlan_id();
  int32_t vlan_id() const;
  void set_vlan_id(int32_t value);
  private:
  int32_t _internal_vlan_id() const;
  void _internal_set_vlan_id(int32_t value);
  public:

  // int32 mpls_tag = 2;
  bool has_mpls_tag() const;
  private:
  bool _internal_has_mpls_tag() const;
  public:
  void clear_mpls_tag();
  int32_t mpls_tag() const;
  void set_mpls_tag(int32_t value);
  private:
  int32_t _internal_mpls_tag() const;
  void _internal_set_mpls_tag(int32_t value);
  public:

  // int32 vnid = 3;
  bool has_vnid() const;
  private:
  bool _internal_has_vnid() const;
  public:
  void clear_vnid();
  int32_t vnid() const;
  void set_vnid(int32_t value);
  private:
  int32_t _internal_vnid() const;
  void _internal_set_vnid(int32_t value);
  public:

  // int32 vsid = 5;
  bool has_vsid() const;
  private:
  bool _internal_has_vsid() const;
  public:
  void clear_vsid();
  int32_t vsid() const;
  void set_vsid(int32_t value);
  private:
  int32_t _internal_vsid() const;
  void _internal_set_vsid(int32_t value);
  public:

  void clear_val();
  ValCase val_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.EncapVal)
 private:
  class _Internal;
  void set_has_vlan_id();
  void set_has_mpls_tag();
  void set_has_vnid();
  void set_has_vsid();

  inline bool has_val() const;
  inline void clear_has_val();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValUnion {
    constexpr ValUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t vlan_id_;
    int32_t mpls_tag_;
    int32_t vnid_;
    int32_t vsid_;
  } val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class Encap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.Encap) */ {
 public:
  inline Encap() : Encap(nullptr) {}
  ~Encap() override;
  explicit constexpr Encap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Encap(const Encap& from);
  Encap(Encap&& from) noexcept
    : Encap() {
    *this = ::std::move(from);
  }

  inline Encap& operator=(const Encap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encap& operator=(Encap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Encap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Encap* internal_default_instance() {
    return reinterpret_cast<const Encap*>(
               &_Encap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Encap& a, Encap& b) {
    a.Swap(&b);
  }
  inline void Swap(Encap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Encap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Encap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Encap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Encap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Encap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Encap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.Encap";
  }
  protected:
  explicit Encap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .opi_api.network.opinetcommon.v1alpha1.EncapVal value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::opi_api::network::opinetcommon::v1alpha1::EncapVal& value() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::EncapVal* release_value();
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* mutable_value();
  void set_allocated_value(::opi_api::network::opinetcommon::v1alpha1::EncapVal* value);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::EncapVal& _internal_value() const;
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::opi_api::network::opinetcommon::v1alpha1::EncapVal* value);
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* unsafe_arena_release_value();

  // .opi_api.network.opinetcommon.v1alpha1.EncapType type = 1;
  void clear_type();
  ::opi_api::network::opinetcommon::v1alpha1::EncapType type() const;
  void set_type(::opi_api::network::opinetcommon::v1alpha1::EncapType value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::EncapType _internal_type() const;
  void _internal_set_type(::opi_api::network::opinetcommon::v1alpha1::EncapType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.Encap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* value_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class PortRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.PortRange) */ {
 public:
  inline PortRange() : PortRange(nullptr) {}
  ~PortRange() override;
  explicit constexpr PortRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortRange(const PortRange& from);
  PortRange(PortRange&& from) noexcept
    : PortRange() {
    *this = ::std::move(from);
  }

  inline PortRange& operator=(const PortRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortRange& operator=(PortRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortRange* internal_default_instance() {
    return reinterpret_cast<const PortRange*>(
               &_PortRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PortRange& a, PortRange& b) {
    a.Swap(&b);
  }
  inline void Swap(PortRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.PortRange";
  }
  protected:
  explicit PortRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortLowFieldNumber = 1,
    kPortHighFieldNumber = 2,
  };
  // int32 port_low = 1;
  void clear_port_low();
  int32_t port_low() const;
  void set_port_low(int32_t value);
  private:
  int32_t _internal_port_low() const;
  void _internal_set_port_low(int32_t value);
  public:

  // int32 port_high = 2;
  void clear_port_high();
  int32_t port_high() const;
  void set_port_high(int32_t value);
  private:
  int32_t _internal_port_high() const;
  void _internal_set_port_high(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.PortRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t port_low_;
  int32_t port_high_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPRange) */ {
 public:
  inline IPRange() : IPRange(nullptr) {}
  ~IPRange() override;
  explicit constexpr IPRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPRange(const IPRange& from);
  IPRange(IPRange&& from) noexcept
    : IPRange() {
    *this = ::std::move(from);
  }

  inline IPRange& operator=(const IPRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPRange& operator=(IPRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPRange* internal_default_instance() {
    return reinterpret_cast<const IPRange*>(
               &_IPRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IPRange& a, IPRange& b) {
    a.Swap(&b);
  }
  inline void Swap(IPRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPRange";
  }
  protected:
  explicit IPRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IPAddress low = 1;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& low() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_low();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_low();
  void set_allocated_low(::opi_api::network::opinetcommon::v1alpha1::IPAddress* low);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_low() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_low();
  public:
  void unsafe_arena_set_allocated_low(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* low);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_low();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress high = 2;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& high() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_high();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_high();
  void set_allocated_high(::opi_api::network::opinetcommon::v1alpha1::IPAddress* high);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_high() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_high();
  public:
  void unsafe_arena_set_allocated_high(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* high);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_high();

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* low_;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* high_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class AddressRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.AddressRange) */ {
 public:
  inline AddressRange() : AddressRange(nullptr) {}
  ~AddressRange() override;
  explicit constexpr AddressRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressRange(const AddressRange& from);
  AddressRange(AddressRange&& from) noexcept
    : AddressRange() {
    *this = ::std::move(from);
  }

  inline AddressRange& operator=(const AddressRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressRange& operator=(AddressRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressRange& default_instance() {
    return *internal_default_instance();
  }
  enum RangeCase {
    kIpv4Range = 1,
    kIpv6Range = 2,
    RANGE_NOT_SET = 0,
  };

  static inline const AddressRange* internal_default_instance() {
    return reinterpret_cast<const AddressRange*>(
               &_AddressRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddressRange& a, AddressRange& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.AddressRange";
  }
  protected:
  explicit AddressRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpv4RangeFieldNumber = 1,
    kIpv6RangeFieldNumber = 2,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IPRange ipv4_range = 1;
  bool has_ipv4_range() const;
  private:
  bool _internal_has_ipv4_range() const;
  public:
  void clear_ipv4_range();
  const ::opi_api::network::opinetcommon::v1alpha1::IPRange& ipv4_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPRange* release_ipv4_range();
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* mutable_ipv4_range();
  void set_allocated_ipv4_range(::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv4_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPRange& _internal_ipv4_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* _internal_mutable_ipv4_range();
  public:
  void unsafe_arena_set_allocated_ipv4_range(
      ::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv4_range);
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* unsafe_arena_release_ipv4_range();

  // .opi_api.network.opinetcommon.v1alpha1.IPRange ipv6_range = 2;
  bool has_ipv6_range() const;
  private:
  bool _internal_has_ipv6_range() const;
  public:
  void clear_ipv6_range();
  const ::opi_api::network::opinetcommon::v1alpha1::IPRange& ipv6_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPRange* release_ipv6_range();
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* mutable_ipv6_range();
  void set_allocated_ipv6_range(::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv6_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPRange& _internal_ipv6_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* _internal_mutable_ipv6_range();
  public:
  void unsafe_arena_set_allocated_ipv6_range(
      ::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv6_range);
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* unsafe_arena_release_ipv6_range();

  void clear_range();
  RangeCase range_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.AddressRange)
 private:
  class _Internal;
  void set_has_ipv4_range();
  void set_has_ipv6_range();

  inline bool has_range() const;
  inline void clear_has_range();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RangeUnion {
    constexpr RangeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv4_range_;
    ::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv6_range_;
  } range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPEntry) */ {
 public:
  inline IPEntry() : IPEntry(nullptr) {}
  ~IPEntry() override;
  explicit constexpr IPEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPEntry(const IPEntry& from);
  IPEntry(IPEntry&& from) noexcept
    : IPEntry() {
    *this = ::std::move(from);
  }

  inline IPEntry& operator=(const IPEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPEntry& operator=(IPEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPEntry& default_instance() {
    return *internal_default_instance();
  }
  enum IpEntryCase {
    kPrefix = 1,
    kRange = 2,
    kTag = 3,
    IP_ENTRY_NOT_SET = 0,
  };

  static inline const IPEntry* internal_default_instance() {
    return reinterpret_cast<const IPEntry*>(
               &_IPEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IPEntry& a, IPEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(IPEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPEntry";
  }
  protected:
  explicit IPEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
    kRangeFieldNumber = 2,
    kTagFieldNumber = 3,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_prefix();
  void set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_prefix();
  public:
  void unsafe_arena_set_allocated_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_prefix();

  // .opi_api.network.opinetcommon.v1alpha1.AddressRange range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::AddressRange* release_range();
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* mutable_range();
  void set_allocated_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& _internal_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* range);
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* unsafe_arena_release_range();

  // int32 tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  int32_t tag() const;
  void set_tag(int32_t value);
  private:
  int32_t _internal_tag() const;
  void _internal_set_tag(int32_t value);
  public:

  void clear_ip_entry();
  IpEntryCase ip_entry_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPEntry)
 private:
  class _Internal;
  void set_has_prefix();
  void set_has_range();
  void set_has_tag();

  inline bool has_ip_entry() const;
  inline void clear_has_ip_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IpEntryUnion {
    constexpr IpEntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix_;
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* range_;
    int32_t tag_;
  } ip_entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class IPList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.IPList) */ {
 public:
  inline IPList() : IPList(nullptr) {}
  ~IPList() override;
  explicit constexpr IPList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPList(const IPList& from);
  IPList(IPList&& from) noexcept
    : IPList() {
    *this = ::std::move(from);
  }

  inline IPList& operator=(const IPList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPList& operator=(IPList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPList* internal_default_instance() {
    return reinterpret_cast<const IPList*>(
               &_IPList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IPList& a, IPList& b) {
    a.Swap(&b);
  }
  inline void Swap(IPList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IPList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.IPList";
  }
  protected:
  explicit IPList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpEntriesFieldNumber = 1,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.IPEntry ip_entries = 1;
  int ip_entries_size() const;
  private:
  int _internal_ip_entries_size() const;
  public:
  void clear_ip_entries();
  ::opi_api::network::opinetcommon::v1alpha1::IPEntry* mutable_ip_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPEntry >*
      mutable_ip_entries();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPEntry& _internal_ip_entries(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPEntry* _internal_add_ip_entries();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::IPEntry& ip_entries(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPEntry* add_ip_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPEntry >&
      ip_entries() const;

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.IPList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPEntry > ip_entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class RuleL3Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.RuleL3Match) */ {
 public:
  inline RuleL3Match() : RuleL3Match(nullptr) {}
  ~RuleL3Match() override;
  explicit constexpr RuleL3Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleL3Match(const RuleL3Match& from);
  RuleL3Match(RuleL3Match&& from) noexcept
    : RuleL3Match() {
    *this = ::std::move(from);
  }

  inline RuleL3Match& operator=(const RuleL3Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleL3Match& operator=(RuleL3Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleL3Match& default_instance() {
    return *internal_default_instance();
  }
  enum ProtomatchCase {
    kProtoNum = 1,
    kProtoWildCard = 2,
    PROTOMATCH_NOT_SET = 0,
  };

  enum SrcmatchCase {
    kSrcPrefix = 3,
    kSrcRange = 4,
    kSrcTag = 5,
    kSrcIpList = 6,
    SRCMATCH_NOT_SET = 0,
  };

  enum DstmatchCase {
    kDstPrefix = 7,
    kDstRange = 8,
    kDstTag = 9,
    kDstIpList = 10,
    DSTMATCH_NOT_SET = 0,
  };

  static inline const RuleL3Match* internal_default_instance() {
    return reinterpret_cast<const RuleL3Match*>(
               &_RuleL3Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RuleL3Match& a, RuleL3Match& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleL3Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleL3Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleL3Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleL3Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleL3Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuleL3Match& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleL3Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.RuleL3Match";
  }
  protected:
  explicit RuleL3Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtoNumFieldNumber = 1,
    kProtoWildCardFieldNumber = 2,
    kSrcPrefixFieldNumber = 3,
    kSrcRangeFieldNumber = 4,
    kSrcTagFieldNumber = 5,
    kSrcIpListFieldNumber = 6,
    kDstPrefixFieldNumber = 7,
    kDstRangeFieldNumber = 8,
    kDstTagFieldNumber = 9,
    kDstIpListFieldNumber = 10,
  };
  // int32 proto_num = 1;
  bool has_proto_num() const;
  private:
  bool _internal_has_proto_num() const;
  public:
  void clear_proto_num();
  int32_t proto_num() const;
  void set_proto_num(int32_t value);
  private:
  int32_t _internal_proto_num() const;
  void _internal_set_proto_num(int32_t value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.WildcardMatch proto_wild_card = 2;
  bool has_proto_wild_card() const;
  private:
  bool _internal_has_proto_wild_card() const;
  public:
  void clear_proto_wild_card();
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch proto_wild_card() const;
  void set_proto_wild_card(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch _internal_proto_wild_card() const;
  void _internal_set_proto_wild_card(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix src_prefix = 3;
  bool has_src_prefix() const;
  private:
  bool _internal_has_src_prefix() const;
  public:
  void clear_src_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& src_prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_src_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_src_prefix();
  void set_allocated_src_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* src_prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_src_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_src_prefix();
  public:
  void unsafe_arena_set_allocated_src_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* src_prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_src_prefix();

  // .opi_api.network.opinetcommon.v1alpha1.AddressRange src_range = 4;
  bool has_src_range() const;
  private:
  bool _internal_has_src_range() const;
  public:
  void clear_src_range();
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& src_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::AddressRange* release_src_range();
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* mutable_src_range();
  void set_allocated_src_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* src_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& _internal_src_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _internal_mutable_src_range();
  public:
  void unsafe_arena_set_allocated_src_range(
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* src_range);
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* unsafe_arena_release_src_range();

  // int32 src_tag = 5;
  bool has_src_tag() const;
  private:
  bool _internal_has_src_tag() const;
  public:
  void clear_src_tag();
  int32_t src_tag() const;
  void set_src_tag(int32_t value);
  private:
  int32_t _internal_src_tag() const;
  void _internal_set_src_tag(int32_t value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPList src_ip_list = 6;
  bool has_src_ip_list() const;
  private:
  bool _internal_has_src_ip_list() const;
  public:
  void clear_src_ip_list();
  const ::opi_api::network::opinetcommon::v1alpha1::IPList& src_ip_list() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPList* release_src_ip_list();
  ::opi_api::network::opinetcommon::v1alpha1::IPList* mutable_src_ip_list();
  void set_allocated_src_ip_list(::opi_api::network::opinetcommon::v1alpha1::IPList* src_ip_list);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPList& _internal_src_ip_list() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPList* _internal_mutable_src_ip_list();
  public:
  void unsafe_arena_set_allocated_src_ip_list(
      ::opi_api::network::opinetcommon::v1alpha1::IPList* src_ip_list);
  ::opi_api::network::opinetcommon::v1alpha1::IPList* unsafe_arena_release_src_ip_list();

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix dst_prefix = 7;
  bool has_dst_prefix() const;
  private:
  bool _internal_has_dst_prefix() const;
  public:
  void clear_dst_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& dst_prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_dst_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_dst_prefix();
  void set_allocated_dst_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* dst_prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_dst_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_dst_prefix();
  public:
  void unsafe_arena_set_allocated_dst_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* dst_prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_dst_prefix();

  // .opi_api.network.opinetcommon.v1alpha1.AddressRange dst_range = 8;
  bool has_dst_range() const;
  private:
  bool _internal_has_dst_range() const;
  public:
  void clear_dst_range();
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& dst_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::AddressRange* release_dst_range();
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* mutable_dst_range();
  void set_allocated_dst_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* dst_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& _internal_dst_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _internal_mutable_dst_range();
  public:
  void unsafe_arena_set_allocated_dst_range(
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* dst_range);
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* unsafe_arena_release_dst_range();

  // int32 dst_tag = 9;
  bool has_dst_tag() const;
  private:
  bool _internal_has_dst_tag() const;
  public:
  void clear_dst_tag();
  int32_t dst_tag() const;
  void set_dst_tag(int32_t value);
  private:
  int32_t _internal_dst_tag() const;
  void _internal_set_dst_tag(int32_t value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPList dst_ip_list = 10;
  bool has_dst_ip_list() const;
  private:
  bool _internal_has_dst_ip_list() const;
  public:
  void clear_dst_ip_list();
  const ::opi_api::network::opinetcommon::v1alpha1::IPList& dst_ip_list() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPList* release_dst_ip_list();
  ::opi_api::network::opinetcommon::v1alpha1::IPList* mutable_dst_ip_list();
  void set_allocated_dst_ip_list(::opi_api::network::opinetcommon::v1alpha1::IPList* dst_ip_list);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPList& _internal_dst_ip_list() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPList* _internal_mutable_dst_ip_list();
  public:
  void unsafe_arena_set_allocated_dst_ip_list(
      ::opi_api::network::opinetcommon::v1alpha1::IPList* dst_ip_list);
  ::opi_api::network::opinetcommon::v1alpha1::IPList* unsafe_arena_release_dst_ip_list();

  void clear_protomatch();
  ProtomatchCase protomatch_case() const;
  void clear_srcmatch();
  SrcmatchCase srcmatch_case() const;
  void clear_dstmatch();
  DstmatchCase dstmatch_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.RuleL3Match)
 private:
  class _Internal;
  void set_has_proto_num();
  void set_has_proto_wild_card();
  void set_has_src_prefix();
  void set_has_src_range();
  void set_has_src_tag();
  void set_has_src_ip_list();
  void set_has_dst_prefix();
  void set_has_dst_range();
  void set_has_dst_tag();
  void set_has_dst_ip_list();

  inline bool has_protomatch() const;
  inline void clear_has_protomatch();

  inline bool has_srcmatch() const;
  inline void clear_has_srcmatch();

  inline bool has_dstmatch() const;
  inline void clear_has_dstmatch();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ProtomatchUnion {
    constexpr ProtomatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t proto_num_;
    int proto_wild_card_;
  } protomatch_;
  union SrcmatchUnion {
    constexpr SrcmatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* src_prefix_;
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* src_range_;
    int32_t src_tag_;
    ::opi_api::network::opinetcommon::v1alpha1::IPList* src_ip_list_;
  } srcmatch_;
  union DstmatchUnion {
    constexpr DstmatchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* dst_prefix_;
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* dst_range_;
    int32_t dst_tag_;
    ::opi_api::network::opinetcommon::v1alpha1::IPList* dst_ip_list_;
  } dstmatch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[3];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class PortMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.PortMatch) */ {
 public:
  inline PortMatch() : PortMatch(nullptr) {}
  ~PortMatch() override;
  explicit constexpr PortMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortMatch(const PortMatch& from);
  PortMatch(PortMatch&& from) noexcept
    : PortMatch() {
    *this = ::std::move(from);
  }

  inline PortMatch& operator=(const PortMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortMatch& operator=(PortMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortMatch* internal_default_instance() {
    return reinterpret_cast<const PortMatch*>(
               &_PortMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PortMatch& a, PortMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(PortMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.PortMatch";
  }
  protected:
  explicit PortMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPortRangeFieldNumber = 1,
    kDstPortRangeFieldNumber = 2,
  };
  // .opi_api.network.opinetcommon.v1alpha1.PortRange src_port_range = 1;
  bool has_src_port_range() const;
  private:
  bool _internal_has_src_port_range() const;
  public:
  void clear_src_port_range();
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& src_port_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::PortRange* release_src_port_range();
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* mutable_src_port_range();
  void set_allocated_src_port_range(::opi_api::network::opinetcommon::v1alpha1::PortRange* src_port_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& _internal_src_port_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _internal_mutable_src_port_range();
  public:
  void unsafe_arena_set_allocated_src_port_range(
      ::opi_api::network::opinetcommon::v1alpha1::PortRange* src_port_range);
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* unsafe_arena_release_src_port_range();

  // .opi_api.network.opinetcommon.v1alpha1.PortRange dst_port_range = 2;
  bool has_dst_port_range() const;
  private:
  bool _internal_has_dst_port_range() const;
  public:
  void clear_dst_port_range();
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& dst_port_range() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::PortRange* release_dst_port_range();
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* mutable_dst_port_range();
  void set_allocated_dst_port_range(::opi_api::network::opinetcommon::v1alpha1::PortRange* dst_port_range);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& _internal_dst_port_range() const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _internal_mutable_dst_port_range();
  public:
  void unsafe_arena_set_allocated_dst_port_range(
      ::opi_api::network::opinetcommon::v1alpha1::PortRange* dst_port_range);
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* unsafe_arena_release_dst_port_range();

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.PortMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* src_port_range_;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* dst_port_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class ICMPMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.ICMPMatch) */ {
 public:
  inline ICMPMatch() : ICMPMatch(nullptr) {}
  ~ICMPMatch() override;
  explicit constexpr ICMPMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICMPMatch(const ICMPMatch& from);
  ICMPMatch(ICMPMatch&& from) noexcept
    : ICMPMatch() {
    *this = ::std::move(from);
  }

  inline ICMPMatch& operator=(const ICMPMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICMPMatch& operator=(ICMPMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICMPMatch& default_instance() {
    return *internal_default_instance();
  }
  enum TypematchCase {
    kType = 1,
    kTypeWildcard = 2,
    TYPEMATCH_NOT_SET = 0,
  };

  enum CodematchCase {
    kCode = 3,
    kCodeWildcard = 4,
    CODEMATCH_NOT_SET = 0,
  };

  static inline const ICMPMatch* internal_default_instance() {
    return reinterpret_cast<const ICMPMatch*>(
               &_ICMPMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ICMPMatch& a, ICMPMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ICMPMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICMPMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICMPMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICMPMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICMPMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ICMPMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICMPMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.ICMPMatch";
  }
  protected:
  explicit ICMPMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTypeWildcardFieldNumber = 2,
    kCodeFieldNumber = 3,
    kCodeWildcardFieldNumber = 4,
  };
  // int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.WildcardMatch type_wildcard = 2;
  bool has_type_wildcard() const;
  private:
  bool _internal_has_type_wildcard() const;
  public:
  void clear_type_wildcard();
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch type_wildcard() const;
  void set_type_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch _internal_type_wildcard() const;
  void _internal_set_type_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  public:

  // int32 code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // .opi_api.network.opinetcommon.v1alpha1.WildcardMatch code_wildcard = 4;
  bool has_code_wildcard() const;
  private:
  bool _internal_has_code_wildcard() const;
  public:
  void clear_code_wildcard();
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch code_wildcard() const;
  void set_code_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch _internal_code_wildcard() const;
  void _internal_set_code_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value);
  public:

  void clear_typematch();
  TypematchCase typematch_case() const;
  void clear_codematch();
  CodematchCase codematch_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.ICMPMatch)
 private:
  class _Internal;
  void set_has_type();
  void set_has_type_wildcard();
  void set_has_code();
  void set_has_code_wildcard();

  inline bool has_typematch() const;
  inline void clear_has_typematch();

  inline bool has_codematch() const;
  inline void clear_has_codematch();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypematchUnion {
    constexpr TypematchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t type_;
    int type_wildcard_;
  } typematch_;
  union CodematchUnion {
    constexpr CodematchUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t code_;
    int code_wildcard_;
  } codematch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class PortListMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.PortListMatch) */ {
 public:
  inline PortListMatch() : PortListMatch(nullptr) {}
  ~PortListMatch() override;
  explicit constexpr PortListMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortListMatch(const PortListMatch& from);
  PortListMatch(PortListMatch&& from) noexcept
    : PortListMatch() {
    *this = ::std::move(from);
  }

  inline PortListMatch& operator=(const PortListMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortListMatch& operator=(PortListMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortListMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortListMatch* internal_default_instance() {
    return reinterpret_cast<const PortListMatch*>(
               &_PortListMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PortListMatch& a, PortListMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(PortListMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortListMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortListMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortListMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortListMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortListMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortListMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.PortListMatch";
  }
  protected:
  explicit PortListMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPortRangeFieldNumber = 1,
    kDstPortRangeFieldNumber = 2,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.PortRange src_port_range = 1;
  int src_port_range_size() const;
  private:
  int _internal_src_port_range_size() const;
  public:
  void clear_src_port_range();
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* mutable_src_port_range(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >*
      mutable_src_port_range();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& _internal_src_port_range(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _internal_add_src_port_range();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& src_port_range(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* add_src_port_range();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >&
      src_port_range() const;

  // repeated .opi_api.network.opinetcommon.v1alpha1.PortRange dst_port_range = 2;
  int dst_port_range_size() const;
  private:
  int _internal_dst_port_range_size() const;
  public:
  void clear_dst_port_range();
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* mutable_dst_port_range(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >*
      mutable_dst_port_range();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& _internal_dst_port_range(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _internal_add_dst_port_range();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange& dst_port_range(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* add_dst_port_range();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >&
      dst_port_range() const;

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.PortListMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange > src_port_range_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange > dst_port_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class ICMPMatchList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList) */ {
 public:
  inline ICMPMatchList() : ICMPMatchList(nullptr) {}
  ~ICMPMatchList() override;
  explicit constexpr ICMPMatchList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICMPMatchList(const ICMPMatchList& from);
  ICMPMatchList(ICMPMatchList&& from) noexcept
    : ICMPMatchList() {
    *this = ::std::move(from);
  }

  inline ICMPMatchList& operator=(const ICMPMatchList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICMPMatchList& operator=(ICMPMatchList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICMPMatchList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICMPMatchList* internal_default_instance() {
    return reinterpret_cast<const ICMPMatchList*>(
               &_ICMPMatchList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ICMPMatchList& a, ICMPMatchList& b) {
    a.Swap(&b);
  }
  inline void Swap(ICMPMatchList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICMPMatchList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICMPMatchList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICMPMatchList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICMPMatchList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ICMPMatchList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICMPMatchList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.ICMPMatchList";
  }
  protected:
  explicit ICMPMatchList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIcmpMatchListFieldNumber = 1,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.ICMPMatch icmp_match_list = 1;
  int icmp_match_list_size() const;
  private:
  int _internal_icmp_match_list_size() const;
  public:
  void clear_icmp_match_list();
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* mutable_icmp_match_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch >*
      mutable_icmp_match_list();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& _internal_icmp_match_list(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* _internal_add_icmp_match_list();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& icmp_match_list(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* add_icmp_match_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch >&
      icmp_match_list() const;

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch > icmp_match_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class RuleL4Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.RuleL4Match) */ {
 public:
  inline RuleL4Match() : RuleL4Match(nullptr) {}
  ~RuleL4Match() override;
  explicit constexpr RuleL4Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleL4Match(const RuleL4Match& from);
  RuleL4Match(RuleL4Match&& from) noexcept
    : RuleL4Match() {
    *this = ::std::move(from);
  }

  inline RuleL4Match& operator=(const RuleL4Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleL4Match& operator=(RuleL4Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleL4Match& default_instance() {
    return *internal_default_instance();
  }
  enum L4InfoCase {
    kPorts = 1,
    kTypeCode = 2,
    kPortList = 3,
    kIcmpMatchList = 4,
    L4INFO_NOT_SET = 0,
  };

  static inline const RuleL4Match* internal_default_instance() {
    return reinterpret_cast<const RuleL4Match*>(
               &_RuleL4Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RuleL4Match& a, RuleL4Match& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleL4Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleL4Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleL4Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleL4Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleL4Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuleL4Match& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleL4Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.RuleL4Match";
  }
  protected:
  explicit RuleL4Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 1,
    kTypeCodeFieldNumber = 2,
    kPortListFieldNumber = 3,
    kIcmpMatchListFieldNumber = 4,
  };
  // .opi_api.network.opinetcommon.v1alpha1.PortMatch ports = 1;
  bool has_ports() const;
  private:
  bool _internal_has_ports() const;
  public:
  void clear_ports();
  const ::opi_api::network::opinetcommon::v1alpha1::PortMatch& ports() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::PortMatch* release_ports();
  ::opi_api::network::opinetcommon::v1alpha1::PortMatch* mutable_ports();
  void set_allocated_ports(::opi_api::network::opinetcommon::v1alpha1::PortMatch* ports);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortMatch& _internal_ports() const;
  ::opi_api::network::opinetcommon::v1alpha1::PortMatch* _internal_mutable_ports();
  public:
  void unsafe_arena_set_allocated_ports(
      ::opi_api::network::opinetcommon::v1alpha1::PortMatch* ports);
  ::opi_api::network::opinetcommon::v1alpha1::PortMatch* unsafe_arena_release_ports();

  // .opi_api.network.opinetcommon.v1alpha1.ICMPMatch type_code = 2;
  bool has_type_code() const;
  private:
  bool _internal_has_type_code() const;
  public:
  void clear_type_code();
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& type_code() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* release_type_code();
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* mutable_type_code();
  void set_allocated_type_code(::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* type_code);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& _internal_type_code() const;
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* _internal_mutable_type_code();
  public:
  void unsafe_arena_set_allocated_type_code(
      ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* type_code);
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* unsafe_arena_release_type_code();

  // .opi_api.network.opinetcommon.v1alpha1.PortListMatch port_list = 3;
  bool has_port_list() const;
  private:
  bool _internal_has_port_list() const;
  public:
  void clear_port_list();
  const ::opi_api::network::opinetcommon::v1alpha1::PortListMatch& port_list() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* release_port_list();
  ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* mutable_port_list();
  void set_allocated_port_list(::opi_api::network::opinetcommon::v1alpha1::PortListMatch* port_list);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::PortListMatch& _internal_port_list() const;
  ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* _internal_mutable_port_list();
  public:
  void unsafe_arena_set_allocated_port_list(
      ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* port_list);
  ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* unsafe_arena_release_port_list();

  // .opi_api.network.opinetcommon.v1alpha1.ICMPMatchList icmp_match_list = 4;
  bool has_icmp_match_list() const;
  private:
  bool _internal_has_icmp_match_list() const;
  public:
  void clear_icmp_match_list();
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList& icmp_match_list() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* release_icmp_match_list();
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* mutable_icmp_match_list();
  void set_allocated_icmp_match_list(::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* icmp_match_list);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList& _internal_icmp_match_list() const;
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* _internal_mutable_icmp_match_list();
  public:
  void unsafe_arena_set_allocated_icmp_match_list(
      ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* icmp_match_list);
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* unsafe_arena_release_icmp_match_list();

  void clear_l4info();
  L4InfoCase l4info_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.RuleL4Match)
 private:
  class _Internal;
  void set_has_ports();
  void set_has_type_code();
  void set_has_port_list();
  void set_has_icmp_match_list();

  inline bool has_l4info() const;
  inline void clear_has_l4info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union L4InfoUnion {
    constexpr L4InfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::opinetcommon::v1alpha1::PortMatch* ports_;
    ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* type_code_;
    ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* port_list_;
    ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* icmp_match_list_;
  } l4info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class RuleMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.RuleMatch) */ {
 public:
  inline RuleMatch() : RuleMatch(nullptr) {}
  ~RuleMatch() override;
  explicit constexpr RuleMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleMatch(const RuleMatch& from);
  RuleMatch(RuleMatch&& from) noexcept
    : RuleMatch() {
    *this = ::std::move(from);
  }

  inline RuleMatch& operator=(const RuleMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleMatch& operator=(RuleMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuleMatch* internal_default_instance() {
    return reinterpret_cast<const RuleMatch*>(
               &_RuleMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RuleMatch& a, RuleMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuleMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.RuleMatch";
  }
  protected:
  explicit RuleMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kL3MatchFieldNumber = 1,
    kL4MatchFieldNumber = 2,
  };
  // .opi_api.network.opinetcommon.v1alpha1.RuleL3Match l3_match = 1;
  bool has_l3_match() const;
  private:
  bool _internal_has_l3_match() const;
  public:
  void clear_l3_match();
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match& l3_match() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* release_l3_match();
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* mutable_l3_match();
  void set_allocated_l3_match(::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* l3_match);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match& _internal_l3_match() const;
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* _internal_mutable_l3_match();
  public:
  void unsafe_arena_set_allocated_l3_match(
      ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* l3_match);
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* unsafe_arena_release_l3_match();

  // .opi_api.network.opinetcommon.v1alpha1.RuleL4Match l4_match = 2;
  bool has_l4_match() const;
  private:
  bool _internal_has_l4_match() const;
  public:
  void clear_l4_match();
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match& l4_match() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* release_l4_match();
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* mutable_l4_match();
  void set_allocated_l4_match(::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* l4_match);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match& _internal_l4_match() const;
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* _internal_mutable_l4_match();
  public:
  void unsafe_arena_set_allocated_l4_match(
      ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* l4_match);
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* unsafe_arena_release_l4_match();

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.RuleMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* l3_match_;
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* l4_match_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// -------------------------------------------------------------------

class HwHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.opinetcommon.v1alpha1.HwHandle) */ {
 public:
  inline HwHandle() : HwHandle(nullptr) {}
  ~HwHandle() override;
  explicit constexpr HwHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HwHandle(const HwHandle& from);
  HwHandle(HwHandle&& from) noexcept
    : HwHandle() {
    *this = ::std::move(from);
  }

  inline HwHandle& operator=(const HwHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline HwHandle& operator=(HwHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HwHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const HwHandle* internal_default_instance() {
    return reinterpret_cast<const HwHandle*>(
               &_HwHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HwHandle& a, HwHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(HwHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HwHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HwHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HwHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HwHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HwHandle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HwHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.opinetcommon.v1alpha1.HwHandle";
  }
  protected:
  explicit HwHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // uint64 idx = 1;
  void clear_idx();
  uint64_t idx() const;
  void set_idx(uint64_t value);
  private:
  uint64_t _internal_idx() const;
  void _internal_set_idx(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.opinetcommon.v1alpha1.HwHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_networktypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IPAddress

// .opi_api.network.opinetcommon.v1alpha1.IpAf af = 1;
inline void IPAddress::clear_af() {
  af_ = 0;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IpAf IPAddress::_internal_af() const {
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::IpAf >(af_);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IpAf IPAddress::af() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPAddress.af)
  return _internal_af();
}
inline void IPAddress::_internal_set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value) {
  
  af_ = value;
}
inline void IPAddress::set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value) {
  _internal_set_af(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPAddress.af)
}

// fixed32 v4_addr = 2;
inline bool IPAddress::_internal_has_v4_addr() const {
  return v4_or_v6_case() == kV4Addr;
}
inline bool IPAddress::has_v4_addr() const {
  return _internal_has_v4_addr();
}
inline void IPAddress::set_has_v4_addr() {
  _oneof_case_[0] = kV4Addr;
}
inline void IPAddress::clear_v4_addr() {
  if (_internal_has_v4_addr()) {
    v4_or_v6_.v4_addr_ = 0u;
    clear_has_v4_or_v6();
  }
}
inline uint32_t IPAddress::_internal_v4_addr() const {
  if (_internal_has_v4_addr()) {
    return v4_or_v6_.v4_addr_;
  }
  return 0u;
}
inline void IPAddress::_internal_set_v4_addr(uint32_t value) {
  if (!_internal_has_v4_addr()) {
    clear_v4_or_v6();
    set_has_v4_addr();
  }
  v4_or_v6_.v4_addr_ = value;
}
inline uint32_t IPAddress::v4_addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPAddress.v4_addr)
  return _internal_v4_addr();
}
inline void IPAddress::set_v4_addr(uint32_t value) {
  _internal_set_v4_addr(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPAddress.v4_addr)
}

// bytes v6_addr = 3;
inline bool IPAddress::_internal_has_v6_addr() const {
  return v4_or_v6_case() == kV6Addr;
}
inline bool IPAddress::has_v6_addr() const {
  return _internal_has_v6_addr();
}
inline void IPAddress::set_has_v6_addr() {
  _oneof_case_[0] = kV6Addr;
}
inline void IPAddress::clear_v6_addr() {
  if (_internal_has_v6_addr()) {
    v4_or_v6_.v6_addr_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_v4_or_v6();
  }
}
inline const std::string& IPAddress::v6_addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPAddress.v6_addr)
  return _internal_v6_addr();
}
template <typename ArgT0, typename... ArgT>
inline void IPAddress::set_v6_addr(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_v6_addr()) {
    clear_v4_or_v6();
    set_has_v6_addr();
    v4_or_v6_.v6_addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v4_or_v6_.v6_addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPAddress.v6_addr)
}
inline std::string* IPAddress::mutable_v6_addr() {
  std::string* _s = _internal_mutable_v6_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPAddress.v6_addr)
  return _s;
}
inline const std::string& IPAddress::_internal_v6_addr() const {
  if (_internal_has_v6_addr()) {
    return v4_or_v6_.v6_addr_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void IPAddress::_internal_set_v6_addr(const std::string& value) {
  if (!_internal_has_v6_addr()) {
    clear_v4_or_v6();
    set_has_v6_addr();
    v4_or_v6_.v6_addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  v4_or_v6_.v6_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPAddress::_internal_mutable_v6_addr() {
  if (!_internal_has_v6_addr()) {
    clear_v4_or_v6();
    set_has_v6_addr();
    v4_or_v6_.v6_addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return v4_or_v6_.v6_addr_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPAddress::release_v6_addr() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPAddress.v6_addr)
  if (_internal_has_v6_addr()) {
    clear_has_v4_or_v6();
    return v4_or_v6_.v6_addr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void IPAddress::set_allocated_v6_addr(std::string* v6_addr) {
  if (has_v4_or_v6()) {
    clear_v4_or_v6();
  }
  if (v6_addr != nullptr) {
    set_has_v6_addr();
    v4_or_v6_.v6_addr_.UnsafeSetDefault(v6_addr);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(v6_addr);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPAddress.v6_addr)
}

inline bool IPAddress::has_v4_or_v6() const {
  return v4_or_v6_case() != V4_OR_V6_NOT_SET;
}
inline void IPAddress::clear_has_v4_or_v6() {
  _oneof_case_[0] = V4_OR_V6_NOT_SET;
}
inline IPAddress::V4OrV6Case IPAddress::v4_or_v6_case() const {
  return IPAddress::V4OrV6Case(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IPPrefix

// .opi_api.network.opinetcommon.v1alpha1.IPAddress addr = 1;
inline bool IPPrefix::_internal_has_addr() const {
  return this != internal_default_instance() && addr_ != nullptr;
}
inline bool IPPrefix::has_addr() const {
  return _internal_has_addr();
}
inline void IPPrefix::clear_addr() {
  if (GetArenaForAllocation() == nullptr && addr_ != nullptr) {
    delete addr_;
  }
  addr_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPPrefix::_internal_addr() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = addr_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPPrefix::addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr)
  return _internal_addr();
}
inline void IPPrefix::unsafe_arena_set_allocated_addr(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* addr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(addr_);
  }
  addr_ = addr;
  if (addr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPPrefix::release_addr() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = addr_;
  addr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPPrefix::unsafe_arena_release_addr() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = addr_;
  addr_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPPrefix::_internal_mutable_addr() {
  
  if (addr_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    addr_ = p;
  }
  return addr_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPPrefix::mutable_addr() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr)
  return _msg;
}
inline void IPPrefix::set_allocated_addr(::opi_api::network::opinetcommon::v1alpha1::IPAddress* addr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete addr_;
  }
  if (addr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::IPAddress>::GetOwningArena(addr);
    if (message_arena != submessage_arena) {
      addr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, addr, submessage_arena);
    }
    
  } else {
    
  }
  addr_ = addr;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPPrefix.addr)
}

// int32 len = 2;
inline void IPPrefix::clear_len() {
  len_ = 0;
}
inline int32_t IPPrefix::_internal_len() const {
  return len_;
}
inline int32_t IPPrefix::len() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPPrefix.len)
  return _internal_len();
}
inline void IPPrefix::_internal_set_len(int32_t value) {
  
  len_ = value;
}
inline void IPPrefix::set_len(int32_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPPrefix.len)
}

// -------------------------------------------------------------------

// IPv4Prefix

// fixed32 addr = 1;
inline void IPv4Prefix::clear_addr() {
  addr_ = 0u;
}
inline uint32_t IPv4Prefix::_internal_addr() const {
  return addr_;
}
inline uint32_t IPv4Prefix::addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix.addr)
  return _internal_addr();
}
inline void IPv4Prefix::_internal_set_addr(uint32_t value) {
  
  addr_ = value;
}
inline void IPv4Prefix::set_addr(uint32_t value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix.addr)
}

// int32 len = 2;
inline void IPv4Prefix::clear_len() {
  len_ = 0;
}
inline int32_t IPv4Prefix::_internal_len() const {
  return len_;
}
inline int32_t IPv4Prefix::len() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix.len)
  return _internal_len();
}
inline void IPv4Prefix::_internal_set_len(int32_t value) {
  
  len_ = value;
}
inline void IPv4Prefix::set_len(int32_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPv4Prefix.len)
}

// -------------------------------------------------------------------

// IPv6Prefix

// bytes addr = 1;
inline void IPv6Prefix::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& IPv6Prefix::addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPv6Prefix::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.addr)
}
inline std::string* IPv6Prefix::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.addr)
  return _s;
}
inline const std::string& IPv6Prefix::_internal_addr() const {
  return addr_.Get();
}
inline void IPv6Prefix::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IPv6Prefix::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IPv6Prefix::release_addr() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IPv6Prefix::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.addr)
}

// int32 len = 2;
inline void IPv6Prefix::clear_len() {
  len_ = 0;
}
inline int32_t IPv6Prefix::_internal_len() const {
  return len_;
}
inline int32_t IPv6Prefix::len() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.len)
  return _internal_len();
}
inline void IPv6Prefix::_internal_set_len(int32_t value) {
  
  len_ = value;
}
inline void IPv6Prefix::set_len(int32_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPv6Prefix.len)
}

// -------------------------------------------------------------------

// EncapVal

// int32 vlan_id = 1;
inline bool EncapVal::_internal_has_vlan_id() const {
  return val_case() == kVlanId;
}
inline bool EncapVal::has_vlan_id() const {
  return _internal_has_vlan_id();
}
inline void EncapVal::set_has_vlan_id() {
  _oneof_case_[0] = kVlanId;
}
inline void EncapVal::clear_vlan_id() {
  if (_internal_has_vlan_id()) {
    val_.vlan_id_ = 0;
    clear_has_val();
  }
}
inline int32_t EncapVal::_internal_vlan_id() const {
  if (_internal_has_vlan_id()) {
    return val_.vlan_id_;
  }
  return 0;
}
inline void EncapVal::_internal_set_vlan_id(int32_t value) {
  if (!_internal_has_vlan_id()) {
    clear_val();
    set_has_vlan_id();
  }
  val_.vlan_id_ = value;
}
inline int32_t EncapVal::vlan_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.EncapVal.vlan_id)
  return _internal_vlan_id();
}
inline void EncapVal::set_vlan_id(int32_t value) {
  _internal_set_vlan_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.EncapVal.vlan_id)
}

// int32 mpls_tag = 2;
inline bool EncapVal::_internal_has_mpls_tag() const {
  return val_case() == kMplsTag;
}
inline bool EncapVal::has_mpls_tag() const {
  return _internal_has_mpls_tag();
}
inline void EncapVal::set_has_mpls_tag() {
  _oneof_case_[0] = kMplsTag;
}
inline void EncapVal::clear_mpls_tag() {
  if (_internal_has_mpls_tag()) {
    val_.mpls_tag_ = 0;
    clear_has_val();
  }
}
inline int32_t EncapVal::_internal_mpls_tag() const {
  if (_internal_has_mpls_tag()) {
    return val_.mpls_tag_;
  }
  return 0;
}
inline void EncapVal::_internal_set_mpls_tag(int32_t value) {
  if (!_internal_has_mpls_tag()) {
    clear_val();
    set_has_mpls_tag();
  }
  val_.mpls_tag_ = value;
}
inline int32_t EncapVal::mpls_tag() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.EncapVal.mpls_tag)
  return _internal_mpls_tag();
}
inline void EncapVal::set_mpls_tag(int32_t value) {
  _internal_set_mpls_tag(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.EncapVal.mpls_tag)
}

// int32 vnid = 3;
inline bool EncapVal::_internal_has_vnid() const {
  return val_case() == kVnid;
}
inline bool EncapVal::has_vnid() const {
  return _internal_has_vnid();
}
inline void EncapVal::set_has_vnid() {
  _oneof_case_[0] = kVnid;
}
inline void EncapVal::clear_vnid() {
  if (_internal_has_vnid()) {
    val_.vnid_ = 0;
    clear_has_val();
  }
}
inline int32_t EncapVal::_internal_vnid() const {
  if (_internal_has_vnid()) {
    return val_.vnid_;
  }
  return 0;
}
inline void EncapVal::_internal_set_vnid(int32_t value) {
  if (!_internal_has_vnid()) {
    clear_val();
    set_has_vnid();
  }
  val_.vnid_ = value;
}
inline int32_t EncapVal::vnid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.EncapVal.vnid)
  return _internal_vnid();
}
inline void EncapVal::set_vnid(int32_t value) {
  _internal_set_vnid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.EncapVal.vnid)
}

// int32 vsid = 5;
inline bool EncapVal::_internal_has_vsid() const {
  return val_case() == kVsid;
}
inline bool EncapVal::has_vsid() const {
  return _internal_has_vsid();
}
inline void EncapVal::set_has_vsid() {
  _oneof_case_[0] = kVsid;
}
inline void EncapVal::clear_vsid() {
  if (_internal_has_vsid()) {
    val_.vsid_ = 0;
    clear_has_val();
  }
}
inline int32_t EncapVal::_internal_vsid() const {
  if (_internal_has_vsid()) {
    return val_.vsid_;
  }
  return 0;
}
inline void EncapVal::_internal_set_vsid(int32_t value) {
  if (!_internal_has_vsid()) {
    clear_val();
    set_has_vsid();
  }
  val_.vsid_ = value;
}
inline int32_t EncapVal::vsid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.EncapVal.vsid)
  return _internal_vsid();
}
inline void EncapVal::set_vsid(int32_t value) {
  _internal_set_vsid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.EncapVal.vsid)
}

inline bool EncapVal::has_val() const {
  return val_case() != VAL_NOT_SET;
}
inline void EncapVal::clear_has_val() {
  _oneof_case_[0] = VAL_NOT_SET;
}
inline EncapVal::ValCase EncapVal::val_case() const {
  return EncapVal::ValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Encap

// .opi_api.network.opinetcommon.v1alpha1.EncapType type = 1;
inline void Encap::clear_type() {
  type_ = 0;
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapType Encap::_internal_type() const {
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::EncapType >(type_);
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapType Encap::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.Encap.type)
  return _internal_type();
}
inline void Encap::_internal_set_type(::opi_api::network::opinetcommon::v1alpha1::EncapType value) {
  
  type_ = value;
}
inline void Encap::set_type(::opi_api::network::opinetcommon::v1alpha1::EncapType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.Encap.type)
}

// .opi_api.network.opinetcommon.v1alpha1.EncapVal value = 2;
inline bool Encap::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Encap::has_value() const {
  return _internal_has_value();
}
inline void Encap::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::EncapVal& Encap::_internal_value() const {
  const ::opi_api::network::opinetcommon::v1alpha1::EncapVal* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::EncapVal&>(
      ::opi_api::network::opinetcommon::v1alpha1::_EncapVal_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::EncapVal& Encap::value() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.Encap.value)
  return _internal_value();
}
inline void Encap::unsafe_arena_set_allocated_value(
    ::opi_api::network::opinetcommon::v1alpha1::EncapVal* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.Encap.value)
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapVal* Encap::release_value() {
  
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapVal* Encap::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.Encap.value)
  
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapVal* Encap::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::EncapVal>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::EncapVal* Encap::mutable_value() {
  ::opi_api::network::opinetcommon::v1alpha1::EncapVal* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.Encap.value)
  return _msg;
}
inline void Encap::set_allocated_value(::opi_api::network::opinetcommon::v1alpha1::EncapVal* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::EncapVal>::GetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.Encap.value)
}

// -------------------------------------------------------------------

// PortRange

// int32 port_low = 1;
inline void PortRange::clear_port_low() {
  port_low_ = 0;
}
inline int32_t PortRange::_internal_port_low() const {
  return port_low_;
}
inline int32_t PortRange::port_low() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortRange.port_low)
  return _internal_port_low();
}
inline void PortRange::_internal_set_port_low(int32_t value) {
  
  port_low_ = value;
}
inline void PortRange::set_port_low(int32_t value) {
  _internal_set_port_low(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.PortRange.port_low)
}

// int32 port_high = 2;
inline void PortRange::clear_port_high() {
  port_high_ = 0;
}
inline int32_t PortRange::_internal_port_high() const {
  return port_high_;
}
inline int32_t PortRange::port_high() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortRange.port_high)
  return _internal_port_high();
}
inline void PortRange::_internal_set_port_high(int32_t value) {
  
  port_high_ = value;
}
inline void PortRange::set_port_high(int32_t value) {
  _internal_set_port_high(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.PortRange.port_high)
}

// -------------------------------------------------------------------

// IPRange

// .opi_api.network.opinetcommon.v1alpha1.IPAddress low = 1;
inline bool IPRange::_internal_has_low() const {
  return this != internal_default_instance() && low_ != nullptr;
}
inline bool IPRange::has_low() const {
  return _internal_has_low();
}
inline void IPRange::clear_low() {
  if (GetArenaForAllocation() == nullptr && low_ != nullptr) {
    delete low_;
  }
  low_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPRange::_internal_low() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = low_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPRange::low() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPRange.low)
  return _internal_low();
}
inline void IPRange::unsafe_arena_set_allocated_low(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* low) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(low_);
  }
  low_ = low;
  if (low) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPRange.low)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::release_low() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = low_;
  low_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::unsafe_arena_release_low() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPRange.low)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = low_;
  low_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::_internal_mutable_low() {
  
  if (low_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    low_ = p;
  }
  return low_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::mutable_low() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_low();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPRange.low)
  return _msg;
}
inline void IPRange::set_allocated_low(::opi_api::network::opinetcommon::v1alpha1::IPAddress* low) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete low_;
  }
  if (low) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::IPAddress>::GetOwningArena(low);
    if (message_arena != submessage_arena) {
      low = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, low, submessage_arena);
    }
    
  } else {
    
  }
  low_ = low;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPRange.low)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress high = 2;
inline bool IPRange::_internal_has_high() const {
  return this != internal_default_instance() && high_ != nullptr;
}
inline bool IPRange::has_high() const {
  return _internal_has_high();
}
inline void IPRange::clear_high() {
  if (GetArenaForAllocation() == nullptr && high_ != nullptr) {
    delete high_;
  }
  high_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPRange::_internal_high() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = high_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPRange::high() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPRange.high)
  return _internal_high();
}
inline void IPRange::unsafe_arena_set_allocated_high(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* high) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(high_);
  }
  high_ = high;
  if (high) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPRange.high)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::release_high() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = high_;
  high_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::unsafe_arena_release_high() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPRange.high)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = high_;
  high_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::_internal_mutable_high() {
  
  if (high_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    high_ = p;
  }
  return high_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPRange::mutable_high() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_high();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPRange.high)
  return _msg;
}
inline void IPRange::set_allocated_high(::opi_api::network::opinetcommon::v1alpha1::IPAddress* high) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete high_;
  }
  if (high) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::IPAddress>::GetOwningArena(high);
    if (message_arena != submessage_arena) {
      high = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, high, submessage_arena);
    }
    
  } else {
    
  }
  high_ = high;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPRange.high)
}

// -------------------------------------------------------------------

// AddressRange

// .opi_api.network.opinetcommon.v1alpha1.IPRange ipv4_range = 1;
inline bool AddressRange::_internal_has_ipv4_range() const {
  return range_case() == kIpv4Range;
}
inline bool AddressRange::has_ipv4_range() const {
  return _internal_has_ipv4_range();
}
inline void AddressRange::set_has_ipv4_range() {
  _oneof_case_[0] = kIpv4Range;
}
inline void AddressRange::clear_ipv4_range() {
  if (_internal_has_ipv4_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete range_.ipv4_range_;
    }
    clear_has_range();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::release_ipv4_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range)
  if (_internal_has_ipv4_range()) {
    clear_has_range();
      ::opi_api::network::opinetcommon::v1alpha1::IPRange* temp = range_.ipv4_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    range_.ipv4_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPRange& AddressRange::_internal_ipv4_range() const {
  return _internal_has_ipv4_range()
      ? *range_.ipv4_range_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPRange&>(::opi_api::network::opinetcommon::v1alpha1::_IPRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPRange& AddressRange::ipv4_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range)
  return _internal_ipv4_range();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::unsafe_arena_release_ipv4_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range)
  if (_internal_has_ipv4_range()) {
    clear_has_range();
    ::opi_api::network::opinetcommon::v1alpha1::IPRange* temp = range_.ipv4_range_;
    range_.ipv4_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AddressRange::unsafe_arena_set_allocated_ipv4_range(::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv4_range) {
  clear_range();
  if (ipv4_range) {
    set_has_ipv4_range();
    range_.ipv4_range_ = ipv4_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::_internal_mutable_ipv4_range() {
  if (!_internal_has_ipv4_range()) {
    clear_range();
    set_has_ipv4_range();
    range_.ipv4_range_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPRange >(GetArenaForAllocation());
  }
  return range_.ipv4_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::mutable_ipv4_range() {
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* _msg = _internal_mutable_ipv4_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv4_range)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.IPRange ipv6_range = 2;
inline bool AddressRange::_internal_has_ipv6_range() const {
  return range_case() == kIpv6Range;
}
inline bool AddressRange::has_ipv6_range() const {
  return _internal_has_ipv6_range();
}
inline void AddressRange::set_has_ipv6_range() {
  _oneof_case_[0] = kIpv6Range;
}
inline void AddressRange::clear_ipv6_range() {
  if (_internal_has_ipv6_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete range_.ipv6_range_;
    }
    clear_has_range();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::release_ipv6_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range)
  if (_internal_has_ipv6_range()) {
    clear_has_range();
      ::opi_api::network::opinetcommon::v1alpha1::IPRange* temp = range_.ipv6_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    range_.ipv6_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPRange& AddressRange::_internal_ipv6_range() const {
  return _internal_has_ipv6_range()
      ? *range_.ipv6_range_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPRange&>(::opi_api::network::opinetcommon::v1alpha1::_IPRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPRange& AddressRange::ipv6_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range)
  return _internal_ipv6_range();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::unsafe_arena_release_ipv6_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range)
  if (_internal_has_ipv6_range()) {
    clear_has_range();
    ::opi_api::network::opinetcommon::v1alpha1::IPRange* temp = range_.ipv6_range_;
    range_.ipv6_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AddressRange::unsafe_arena_set_allocated_ipv6_range(::opi_api::network::opinetcommon::v1alpha1::IPRange* ipv6_range) {
  clear_range();
  if (ipv6_range) {
    set_has_ipv6_range();
    range_.ipv6_range_ = ipv6_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::_internal_mutable_ipv6_range() {
  if (!_internal_has_ipv6_range()) {
    clear_range();
    set_has_ipv6_range();
    range_.ipv6_range_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPRange >(GetArenaForAllocation());
  }
  return range_.ipv6_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPRange* AddressRange::mutable_ipv6_range() {
  ::opi_api::network::opinetcommon::v1alpha1::IPRange* _msg = _internal_mutable_ipv6_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.AddressRange.ipv6_range)
  return _msg;
}

inline bool AddressRange::has_range() const {
  return range_case() != RANGE_NOT_SET;
}
inline void AddressRange::clear_has_range() {
  _oneof_case_[0] = RANGE_NOT_SET;
}
inline AddressRange::RangeCase AddressRange::range_case() const {
  return AddressRange::RangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IPEntry

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
inline bool IPEntry::_internal_has_prefix() const {
  return ip_entry_case() == kPrefix;
}
inline bool IPEntry::has_prefix() const {
  return _internal_has_prefix();
}
inline void IPEntry::set_has_prefix() {
  _oneof_case_[0] = kPrefix;
}
inline void IPEntry::clear_prefix() {
  if (_internal_has_prefix()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_entry_.prefix_;
    }
    clear_has_ip_entry();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* IPEntry::release_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix)
  if (_internal_has_prefix()) {
    clear_has_ip_entry();
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = ip_entry_.prefix_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_entry_.prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& IPEntry::_internal_prefix() const {
  return _internal_has_prefix()
      ? *ip_entry_.prefix_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& IPEntry::prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix)
  return _internal_prefix();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* IPEntry::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix)
  if (_internal_has_prefix()) {
    clear_has_ip_entry();
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = ip_entry_.prefix_;
    ip_entry_.prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPEntry::unsafe_arena_set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  clear_ip_entry();
  if (prefix) {
    set_has_prefix();
    ip_entry_.prefix_ = prefix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* IPEntry::_internal_mutable_prefix() {
  if (!_internal_has_prefix()) {
    clear_ip_entry();
    set_has_prefix();
    ip_entry_.prefix_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >(GetArenaForAllocation());
  }
  return ip_entry_.prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* IPEntry::mutable_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPEntry.prefix)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.AddressRange range = 2;
inline bool IPEntry::_internal_has_range() const {
  return ip_entry_case() == kRange;
}
inline bool IPEntry::has_range() const {
  return _internal_has_range();
}
inline void IPEntry::set_has_range() {
  _oneof_case_[0] = kRange;
}
inline void IPEntry::clear_range() {
  if (_internal_has_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_entry_.range_;
    }
    clear_has_ip_entry();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* IPEntry::release_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.IPEntry.range)
  if (_internal_has_range()) {
    clear_has_ip_entry();
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = ip_entry_.range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_entry_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& IPEntry::_internal_range() const {
  return _internal_has_range()
      ? *ip_entry_.range_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::AddressRange&>(::opi_api::network::opinetcommon::v1alpha1::_AddressRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& IPEntry::range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPEntry.range)
  return _internal_range();
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* IPEntry::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.IPEntry.range)
  if (_internal_has_range()) {
    clear_has_ip_entry();
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = ip_entry_.range_;
    ip_entry_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IPEntry::unsafe_arena_set_allocated_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* range) {
  clear_ip_entry();
  if (range) {
    set_has_range();
    ip_entry_.range_ = range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.IPEntry.range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* IPEntry::_internal_mutable_range() {
  if (!_internal_has_range()) {
    clear_ip_entry();
    set_has_range();
    ip_entry_.range_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::AddressRange >(GetArenaForAllocation());
  }
  return ip_entry_.range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* IPEntry::mutable_range() {
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPEntry.range)
  return _msg;
}

// int32 tag = 3;
inline bool IPEntry::_internal_has_tag() const {
  return ip_entry_case() == kTag;
}
inline bool IPEntry::has_tag() const {
  return _internal_has_tag();
}
inline void IPEntry::set_has_tag() {
  _oneof_case_[0] = kTag;
}
inline void IPEntry::clear_tag() {
  if (_internal_has_tag()) {
    ip_entry_.tag_ = 0;
    clear_has_ip_entry();
  }
}
inline int32_t IPEntry::_internal_tag() const {
  if (_internal_has_tag()) {
    return ip_entry_.tag_;
  }
  return 0;
}
inline void IPEntry::_internal_set_tag(int32_t value) {
  if (!_internal_has_tag()) {
    clear_ip_entry();
    set_has_tag();
  }
  ip_entry_.tag_ = value;
}
inline int32_t IPEntry::tag() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPEntry.tag)
  return _internal_tag();
}
inline void IPEntry::set_tag(int32_t value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.IPEntry.tag)
}

inline bool IPEntry::has_ip_entry() const {
  return ip_entry_case() != IP_ENTRY_NOT_SET;
}
inline void IPEntry::clear_has_ip_entry() {
  _oneof_case_[0] = IP_ENTRY_NOT_SET;
}
inline IPEntry::IpEntryCase IPEntry::ip_entry_case() const {
  return IPEntry::IpEntryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// IPList

// repeated .opi_api.network.opinetcommon.v1alpha1.IPEntry ip_entries = 1;
inline int IPList::_internal_ip_entries_size() const {
  return ip_entries_.size();
}
inline int IPList::ip_entries_size() const {
  return _internal_ip_entries_size();
}
inline void IPList::clear_ip_entries() {
  ip_entries_.Clear();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPEntry* IPList::mutable_ip_entries(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries)
  return ip_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPEntry >*
IPList::mutable_ip_entries() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries)
  return &ip_entries_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPEntry& IPList::_internal_ip_entries(int index) const {
  return ip_entries_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPEntry& IPList::ip_entries(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries)
  return _internal_ip_entries(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPEntry* IPList::_internal_add_ip_entries() {
  return ip_entries_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPEntry* IPList::add_ip_entries() {
  ::opi_api::network::opinetcommon::v1alpha1::IPEntry* _add = _internal_add_ip_entries();
  // @@protoc_insertion_point(field_add:opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPEntry >&
IPList::ip_entries() const {
  // @@protoc_insertion_point(field_list:opi_api.network.opinetcommon.v1alpha1.IPList.ip_entries)
  return ip_entries_;
}

// -------------------------------------------------------------------

// RuleL3Match

// int32 proto_num = 1;
inline bool RuleL3Match::_internal_has_proto_num() const {
  return protomatch_case() == kProtoNum;
}
inline bool RuleL3Match::has_proto_num() const {
  return _internal_has_proto_num();
}
inline void RuleL3Match::set_has_proto_num() {
  _oneof_case_[0] = kProtoNum;
}
inline void RuleL3Match::clear_proto_num() {
  if (_internal_has_proto_num()) {
    protomatch_.proto_num_ = 0;
    clear_has_protomatch();
  }
}
inline int32_t RuleL3Match::_internal_proto_num() const {
  if (_internal_has_proto_num()) {
    return protomatch_.proto_num_;
  }
  return 0;
}
inline void RuleL3Match::_internal_set_proto_num(int32_t value) {
  if (!_internal_has_proto_num()) {
    clear_protomatch();
    set_has_proto_num();
  }
  protomatch_.proto_num_ = value;
}
inline int32_t RuleL3Match::proto_num() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.proto_num)
  return _internal_proto_num();
}
inline void RuleL3Match::set_proto_num(int32_t value) {
  _internal_set_proto_num(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.proto_num)
}

// .opi_api.network.opinetcommon.v1alpha1.WildcardMatch proto_wild_card = 2;
inline bool RuleL3Match::_internal_has_proto_wild_card() const {
  return protomatch_case() == kProtoWildCard;
}
inline bool RuleL3Match::has_proto_wild_card() const {
  return _internal_has_proto_wild_card();
}
inline void RuleL3Match::set_has_proto_wild_card() {
  _oneof_case_[0] = kProtoWildCard;
}
inline void RuleL3Match::clear_proto_wild_card() {
  if (_internal_has_proto_wild_card()) {
    protomatch_.proto_wild_card_ = 0;
    clear_has_protomatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch RuleL3Match::_internal_proto_wild_card() const {
  if (_internal_has_proto_wild_card()) {
    return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(protomatch_.proto_wild_card_);
  }
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(0);
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch RuleL3Match::proto_wild_card() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.proto_wild_card)
  return _internal_proto_wild_card();
}
inline void RuleL3Match::_internal_set_proto_wild_card(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  if (!_internal_has_proto_wild_card()) {
    clear_protomatch();
    set_has_proto_wild_card();
  }
  protomatch_.proto_wild_card_ = value;
}
inline void RuleL3Match::set_proto_wild_card(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  _internal_set_proto_wild_card(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.proto_wild_card)
}

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix src_prefix = 3;
inline bool RuleL3Match::_internal_has_src_prefix() const {
  return srcmatch_case() == kSrcPrefix;
}
inline bool RuleL3Match::has_src_prefix() const {
  return _internal_has_src_prefix();
}
inline void RuleL3Match::set_has_src_prefix() {
  _oneof_case_[1] = kSrcPrefix;
}
inline void RuleL3Match::clear_src_prefix() {
  if (_internal_has_src_prefix()) {
    if (GetArenaForAllocation() == nullptr) {
      delete srcmatch_.src_prefix_;
    }
    clear_has_srcmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::release_src_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix)
  if (_internal_has_src_prefix()) {
    clear_has_srcmatch();
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = srcmatch_.src_prefix_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    srcmatch_.src_prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RuleL3Match::_internal_src_prefix() const {
  return _internal_has_src_prefix()
      ? *srcmatch_.src_prefix_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RuleL3Match::src_prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix)
  return _internal_src_prefix();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::unsafe_arena_release_src_prefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix)
  if (_internal_has_src_prefix()) {
    clear_has_srcmatch();
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = srcmatch_.src_prefix_;
    srcmatch_.src_prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_src_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* src_prefix) {
  clear_srcmatch();
  if (src_prefix) {
    set_has_src_prefix();
    srcmatch_.src_prefix_ = src_prefix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::_internal_mutable_src_prefix() {
  if (!_internal_has_src_prefix()) {
    clear_srcmatch();
    set_has_src_prefix();
    srcmatch_.src_prefix_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >(GetArenaForAllocation());
  }
  return srcmatch_.src_prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::mutable_src_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_src_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_prefix)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.AddressRange src_range = 4;
inline bool RuleL3Match::_internal_has_src_range() const {
  return srcmatch_case() == kSrcRange;
}
inline bool RuleL3Match::has_src_range() const {
  return _internal_has_src_range();
}
inline void RuleL3Match::set_has_src_range() {
  _oneof_case_[1] = kSrcRange;
}
inline void RuleL3Match::clear_src_range() {
  if (_internal_has_src_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete srcmatch_.src_range_;
    }
    clear_has_srcmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::release_src_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range)
  if (_internal_has_src_range()) {
    clear_has_srcmatch();
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = srcmatch_.src_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    srcmatch_.src_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& RuleL3Match::_internal_src_range() const {
  return _internal_has_src_range()
      ? *srcmatch_.src_range_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::AddressRange&>(::opi_api::network::opinetcommon::v1alpha1::_AddressRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& RuleL3Match::src_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range)
  return _internal_src_range();
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::unsafe_arena_release_src_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range)
  if (_internal_has_src_range()) {
    clear_has_srcmatch();
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = srcmatch_.src_range_;
    srcmatch_.src_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_src_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* src_range) {
  clear_srcmatch();
  if (src_range) {
    set_has_src_range();
    srcmatch_.src_range_ = src_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::_internal_mutable_src_range() {
  if (!_internal_has_src_range()) {
    clear_srcmatch();
    set_has_src_range();
    srcmatch_.src_range_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::AddressRange >(GetArenaForAllocation());
  }
  return srcmatch_.src_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::mutable_src_range() {
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _msg = _internal_mutable_src_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_range)
  return _msg;
}

// int32 src_tag = 5;
inline bool RuleL3Match::_internal_has_src_tag() const {
  return srcmatch_case() == kSrcTag;
}
inline bool RuleL3Match::has_src_tag() const {
  return _internal_has_src_tag();
}
inline void RuleL3Match::set_has_src_tag() {
  _oneof_case_[1] = kSrcTag;
}
inline void RuleL3Match::clear_src_tag() {
  if (_internal_has_src_tag()) {
    srcmatch_.src_tag_ = 0;
    clear_has_srcmatch();
  }
}
inline int32_t RuleL3Match::_internal_src_tag() const {
  if (_internal_has_src_tag()) {
    return srcmatch_.src_tag_;
  }
  return 0;
}
inline void RuleL3Match::_internal_set_src_tag(int32_t value) {
  if (!_internal_has_src_tag()) {
    clear_srcmatch();
    set_has_src_tag();
  }
  srcmatch_.src_tag_ = value;
}
inline int32_t RuleL3Match::src_tag() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_tag)
  return _internal_src_tag();
}
inline void RuleL3Match::set_src_tag(int32_t value) {
  _internal_set_src_tag(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_tag)
}

// .opi_api.network.opinetcommon.v1alpha1.IPList src_ip_list = 6;
inline bool RuleL3Match::_internal_has_src_ip_list() const {
  return srcmatch_case() == kSrcIpList;
}
inline bool RuleL3Match::has_src_ip_list() const {
  return _internal_has_src_ip_list();
}
inline void RuleL3Match::set_has_src_ip_list() {
  _oneof_case_[1] = kSrcIpList;
}
inline void RuleL3Match::clear_src_ip_list() {
  if (_internal_has_src_ip_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete srcmatch_.src_ip_list_;
    }
    clear_has_srcmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::release_src_ip_list() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list)
  if (_internal_has_src_ip_list()) {
    clear_has_srcmatch();
      ::opi_api::network::opinetcommon::v1alpha1::IPList* temp = srcmatch_.src_ip_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    srcmatch_.src_ip_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPList& RuleL3Match::_internal_src_ip_list() const {
  return _internal_has_src_ip_list()
      ? *srcmatch_.src_ip_list_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPList&>(::opi_api::network::opinetcommon::v1alpha1::_IPList_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPList& RuleL3Match::src_ip_list() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list)
  return _internal_src_ip_list();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::unsafe_arena_release_src_ip_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list)
  if (_internal_has_src_ip_list()) {
    clear_has_srcmatch();
    ::opi_api::network::opinetcommon::v1alpha1::IPList* temp = srcmatch_.src_ip_list_;
    srcmatch_.src_ip_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_src_ip_list(::opi_api::network::opinetcommon::v1alpha1::IPList* src_ip_list) {
  clear_srcmatch();
  if (src_ip_list) {
    set_has_src_ip_list();
    srcmatch_.src_ip_list_ = src_ip_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::_internal_mutable_src_ip_list() {
  if (!_internal_has_src_ip_list()) {
    clear_srcmatch();
    set_has_src_ip_list();
    srcmatch_.src_ip_list_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPList >(GetArenaForAllocation());
  }
  return srcmatch_.src_ip_list_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::mutable_src_ip_list() {
  ::opi_api::network::opinetcommon::v1alpha1::IPList* _msg = _internal_mutable_src_ip_list();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.src_ip_list)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix dst_prefix = 7;
inline bool RuleL3Match::_internal_has_dst_prefix() const {
  return dstmatch_case() == kDstPrefix;
}
inline bool RuleL3Match::has_dst_prefix() const {
  return _internal_has_dst_prefix();
}
inline void RuleL3Match::set_has_dst_prefix() {
  _oneof_case_[2] = kDstPrefix;
}
inline void RuleL3Match::clear_dst_prefix() {
  if (_internal_has_dst_prefix()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dstmatch_.dst_prefix_;
    }
    clear_has_dstmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::release_dst_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix)
  if (_internal_has_dst_prefix()) {
    clear_has_dstmatch();
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = dstmatch_.dst_prefix_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstmatch_.dst_prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RuleL3Match::_internal_dst_prefix() const {
  return _internal_has_dst_prefix()
      ? *dstmatch_.dst_prefix_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RuleL3Match::dst_prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix)
  return _internal_dst_prefix();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::unsafe_arena_release_dst_prefix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix)
  if (_internal_has_dst_prefix()) {
    clear_has_dstmatch();
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = dstmatch_.dst_prefix_;
    dstmatch_.dst_prefix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_dst_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* dst_prefix) {
  clear_dstmatch();
  if (dst_prefix) {
    set_has_dst_prefix();
    dstmatch_.dst_prefix_ = dst_prefix;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::_internal_mutable_dst_prefix() {
  if (!_internal_has_dst_prefix()) {
    clear_dstmatch();
    set_has_dst_prefix();
    dstmatch_.dst_prefix_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >(GetArenaForAllocation());
  }
  return dstmatch_.dst_prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RuleL3Match::mutable_dst_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_dst_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_prefix)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.AddressRange dst_range = 8;
inline bool RuleL3Match::_internal_has_dst_range() const {
  return dstmatch_case() == kDstRange;
}
inline bool RuleL3Match::has_dst_range() const {
  return _internal_has_dst_range();
}
inline void RuleL3Match::set_has_dst_range() {
  _oneof_case_[2] = kDstRange;
}
inline void RuleL3Match::clear_dst_range() {
  if (_internal_has_dst_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dstmatch_.dst_range_;
    }
    clear_has_dstmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::release_dst_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range)
  if (_internal_has_dst_range()) {
    clear_has_dstmatch();
      ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = dstmatch_.dst_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstmatch_.dst_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& RuleL3Match::_internal_dst_range() const {
  return _internal_has_dst_range()
      ? *dstmatch_.dst_range_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::AddressRange&>(::opi_api::network::opinetcommon::v1alpha1::_AddressRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::AddressRange& RuleL3Match::dst_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range)
  return _internal_dst_range();
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::unsafe_arena_release_dst_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range)
  if (_internal_has_dst_range()) {
    clear_has_dstmatch();
    ::opi_api::network::opinetcommon::v1alpha1::AddressRange* temp = dstmatch_.dst_range_;
    dstmatch_.dst_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_dst_range(::opi_api::network::opinetcommon::v1alpha1::AddressRange* dst_range) {
  clear_dstmatch();
  if (dst_range) {
    set_has_dst_range();
    dstmatch_.dst_range_ = dst_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::_internal_mutable_dst_range() {
  if (!_internal_has_dst_range()) {
    clear_dstmatch();
    set_has_dst_range();
    dstmatch_.dst_range_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::AddressRange >(GetArenaForAllocation());
  }
  return dstmatch_.dst_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::AddressRange* RuleL3Match::mutable_dst_range() {
  ::opi_api::network::opinetcommon::v1alpha1::AddressRange* _msg = _internal_mutable_dst_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_range)
  return _msg;
}

// int32 dst_tag = 9;
inline bool RuleL3Match::_internal_has_dst_tag() const {
  return dstmatch_case() == kDstTag;
}
inline bool RuleL3Match::has_dst_tag() const {
  return _internal_has_dst_tag();
}
inline void RuleL3Match::set_has_dst_tag() {
  _oneof_case_[2] = kDstTag;
}
inline void RuleL3Match::clear_dst_tag() {
  if (_internal_has_dst_tag()) {
    dstmatch_.dst_tag_ = 0;
    clear_has_dstmatch();
  }
}
inline int32_t RuleL3Match::_internal_dst_tag() const {
  if (_internal_has_dst_tag()) {
    return dstmatch_.dst_tag_;
  }
  return 0;
}
inline void RuleL3Match::_internal_set_dst_tag(int32_t value) {
  if (!_internal_has_dst_tag()) {
    clear_dstmatch();
    set_has_dst_tag();
  }
  dstmatch_.dst_tag_ = value;
}
inline int32_t RuleL3Match::dst_tag() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_tag)
  return _internal_dst_tag();
}
inline void RuleL3Match::set_dst_tag(int32_t value) {
  _internal_set_dst_tag(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_tag)
}

// .opi_api.network.opinetcommon.v1alpha1.IPList dst_ip_list = 10;
inline bool RuleL3Match::_internal_has_dst_ip_list() const {
  return dstmatch_case() == kDstIpList;
}
inline bool RuleL3Match::has_dst_ip_list() const {
  return _internal_has_dst_ip_list();
}
inline void RuleL3Match::set_has_dst_ip_list() {
  _oneof_case_[2] = kDstIpList;
}
inline void RuleL3Match::clear_dst_ip_list() {
  if (_internal_has_dst_ip_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete dstmatch_.dst_ip_list_;
    }
    clear_has_dstmatch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::release_dst_ip_list() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list)
  if (_internal_has_dst_ip_list()) {
    clear_has_dstmatch();
      ::opi_api::network::opinetcommon::v1alpha1::IPList* temp = dstmatch_.dst_ip_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstmatch_.dst_ip_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPList& RuleL3Match::_internal_dst_ip_list() const {
  return _internal_has_dst_ip_list()
      ? *dstmatch_.dst_ip_list_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPList&>(::opi_api::network::opinetcommon::v1alpha1::_IPList_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPList& RuleL3Match::dst_ip_list() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list)
  return _internal_dst_ip_list();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::unsafe_arena_release_dst_ip_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list)
  if (_internal_has_dst_ip_list()) {
    clear_has_dstmatch();
    ::opi_api::network::opinetcommon::v1alpha1::IPList* temp = dstmatch_.dst_ip_list_;
    dstmatch_.dst_ip_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL3Match::unsafe_arena_set_allocated_dst_ip_list(::opi_api::network::opinetcommon::v1alpha1::IPList* dst_ip_list) {
  clear_dstmatch();
  if (dst_ip_list) {
    set_has_dst_ip_list();
    dstmatch_.dst_ip_list_ = dst_ip_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::_internal_mutable_dst_ip_list() {
  if (!_internal_has_dst_ip_list()) {
    clear_dstmatch();
    set_has_dst_ip_list();
    dstmatch_.dst_ip_list_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPList >(GetArenaForAllocation());
  }
  return dstmatch_.dst_ip_list_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPList* RuleL3Match::mutable_dst_ip_list() {
  ::opi_api::network::opinetcommon::v1alpha1::IPList* _msg = _internal_mutable_dst_ip_list();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL3Match.dst_ip_list)
  return _msg;
}

inline bool RuleL3Match::has_protomatch() const {
  return protomatch_case() != PROTOMATCH_NOT_SET;
}
inline void RuleL3Match::clear_has_protomatch() {
  _oneof_case_[0] = PROTOMATCH_NOT_SET;
}
inline bool RuleL3Match::has_srcmatch() const {
  return srcmatch_case() != SRCMATCH_NOT_SET;
}
inline void RuleL3Match::clear_has_srcmatch() {
  _oneof_case_[1] = SRCMATCH_NOT_SET;
}
inline bool RuleL3Match::has_dstmatch() const {
  return dstmatch_case() != DSTMATCH_NOT_SET;
}
inline void RuleL3Match::clear_has_dstmatch() {
  _oneof_case_[2] = DSTMATCH_NOT_SET;
}
inline RuleL3Match::ProtomatchCase RuleL3Match::protomatch_case() const {
  return RuleL3Match::ProtomatchCase(_oneof_case_[0]);
}
inline RuleL3Match::SrcmatchCase RuleL3Match::srcmatch_case() const {
  return RuleL3Match::SrcmatchCase(_oneof_case_[1]);
}
inline RuleL3Match::DstmatchCase RuleL3Match::dstmatch_case() const {
  return RuleL3Match::DstmatchCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// PortMatch

// .opi_api.network.opinetcommon.v1alpha1.PortRange src_port_range = 1;
inline bool PortMatch::_internal_has_src_port_range() const {
  return this != internal_default_instance() && src_port_range_ != nullptr;
}
inline bool PortMatch::has_src_port_range() const {
  return _internal_has_src_port_range();
}
inline void PortMatch::clear_src_port_range() {
  if (GetArenaForAllocation() == nullptr && src_port_range_ != nullptr) {
    delete src_port_range_;
  }
  src_port_range_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortMatch::_internal_src_port_range() const {
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange* p = src_port_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::PortRange&>(
      ::opi_api::network::opinetcommon::v1alpha1::_PortRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortMatch::src_port_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range)
  return _internal_src_port_range();
}
inline void PortMatch::unsafe_arena_set_allocated_src_port_range(
    ::opi_api::network::opinetcommon::v1alpha1::PortRange* src_port_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_port_range_);
  }
  src_port_range_ = src_port_range;
  if (src_port_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::release_src_port_range() {
  
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* temp = src_port_range_;
  src_port_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::unsafe_arena_release_src_port_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range)
  
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* temp = src_port_range_;
  src_port_range_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::_internal_mutable_src_port_range() {
  
  if (src_port_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::PortRange>(GetArenaForAllocation());
    src_port_range_ = p;
  }
  return src_port_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::mutable_src_port_range() {
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _msg = _internal_mutable_src_port_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range)
  return _msg;
}
inline void PortMatch::set_allocated_src_port_range(::opi_api::network::opinetcommon::v1alpha1::PortRange* src_port_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete src_port_range_;
  }
  if (src_port_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::PortRange>::GetOwningArena(src_port_range);
    if (message_arena != submessage_arena) {
      src_port_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_port_range, submessage_arena);
    }
    
  } else {
    
  }
  src_port_range_ = src_port_range;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.PortMatch.src_port_range)
}

// .opi_api.network.opinetcommon.v1alpha1.PortRange dst_port_range = 2;
inline bool PortMatch::_internal_has_dst_port_range() const {
  return this != internal_default_instance() && dst_port_range_ != nullptr;
}
inline bool PortMatch::has_dst_port_range() const {
  return _internal_has_dst_port_range();
}
inline void PortMatch::clear_dst_port_range() {
  if (GetArenaForAllocation() == nullptr && dst_port_range_ != nullptr) {
    delete dst_port_range_;
  }
  dst_port_range_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortMatch::_internal_dst_port_range() const {
  const ::opi_api::network::opinetcommon::v1alpha1::PortRange* p = dst_port_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::PortRange&>(
      ::opi_api::network::opinetcommon::v1alpha1::_PortRange_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortMatch::dst_port_range() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range)
  return _internal_dst_port_range();
}
inline void PortMatch::unsafe_arena_set_allocated_dst_port_range(
    ::opi_api::network::opinetcommon::v1alpha1::PortRange* dst_port_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_port_range_);
  }
  dst_port_range_ = dst_port_range;
  if (dst_port_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range)
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::release_dst_port_range() {
  
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* temp = dst_port_range_;
  dst_port_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::unsafe_arena_release_dst_port_range() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range)
  
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* temp = dst_port_range_;
  dst_port_range_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::_internal_mutable_dst_port_range() {
  
  if (dst_port_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::PortRange>(GetArenaForAllocation());
    dst_port_range_ = p;
  }
  return dst_port_range_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortMatch::mutable_dst_port_range() {
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _msg = _internal_mutable_dst_port_range();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range)
  return _msg;
}
inline void PortMatch::set_allocated_dst_port_range(::opi_api::network::opinetcommon::v1alpha1::PortRange* dst_port_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dst_port_range_;
  }
  if (dst_port_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::PortRange>::GetOwningArena(dst_port_range);
    if (message_arena != submessage_arena) {
      dst_port_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_port_range, submessage_arena);
    }
    
  } else {
    
  }
  dst_port_range_ = dst_port_range;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.PortMatch.dst_port_range)
}

// -------------------------------------------------------------------

// ICMPMatch

// int32 type = 1;
inline bool ICMPMatch::_internal_has_type() const {
  return typematch_case() == kType;
}
inline bool ICMPMatch::has_type() const {
  return _internal_has_type();
}
inline void ICMPMatch::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void ICMPMatch::clear_type() {
  if (_internal_has_type()) {
    typematch_.type_ = 0;
    clear_has_typematch();
  }
}
inline int32_t ICMPMatch::_internal_type() const {
  if (_internal_has_type()) {
    return typematch_.type_;
  }
  return 0;
}
inline void ICMPMatch::_internal_set_type(int32_t value) {
  if (!_internal_has_type()) {
    clear_typematch();
    set_has_type();
  }
  typematch_.type_ = value;
}
inline int32_t ICMPMatch::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.type)
  return _internal_type();
}
inline void ICMPMatch::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.type)
}

// .opi_api.network.opinetcommon.v1alpha1.WildcardMatch type_wildcard = 2;
inline bool ICMPMatch::_internal_has_type_wildcard() const {
  return typematch_case() == kTypeWildcard;
}
inline bool ICMPMatch::has_type_wildcard() const {
  return _internal_has_type_wildcard();
}
inline void ICMPMatch::set_has_type_wildcard() {
  _oneof_case_[0] = kTypeWildcard;
}
inline void ICMPMatch::clear_type_wildcard() {
  if (_internal_has_type_wildcard()) {
    typematch_.type_wildcard_ = 0;
    clear_has_typematch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch ICMPMatch::_internal_type_wildcard() const {
  if (_internal_has_type_wildcard()) {
    return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(typematch_.type_wildcard_);
  }
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(0);
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch ICMPMatch::type_wildcard() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.type_wildcard)
  return _internal_type_wildcard();
}
inline void ICMPMatch::_internal_set_type_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  if (!_internal_has_type_wildcard()) {
    clear_typematch();
    set_has_type_wildcard();
  }
  typematch_.type_wildcard_ = value;
}
inline void ICMPMatch::set_type_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  _internal_set_type_wildcard(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.type_wildcard)
}

// int32 code = 3;
inline bool ICMPMatch::_internal_has_code() const {
  return codematch_case() == kCode;
}
inline bool ICMPMatch::has_code() const {
  return _internal_has_code();
}
inline void ICMPMatch::set_has_code() {
  _oneof_case_[1] = kCode;
}
inline void ICMPMatch::clear_code() {
  if (_internal_has_code()) {
    codematch_.code_ = 0;
    clear_has_codematch();
  }
}
inline int32_t ICMPMatch::_internal_code() const {
  if (_internal_has_code()) {
    return codematch_.code_;
  }
  return 0;
}
inline void ICMPMatch::_internal_set_code(int32_t value) {
  if (!_internal_has_code()) {
    clear_codematch();
    set_has_code();
  }
  codematch_.code_ = value;
}
inline int32_t ICMPMatch::code() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.code)
  return _internal_code();
}
inline void ICMPMatch::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.code)
}

// .opi_api.network.opinetcommon.v1alpha1.WildcardMatch code_wildcard = 4;
inline bool ICMPMatch::_internal_has_code_wildcard() const {
  return codematch_case() == kCodeWildcard;
}
inline bool ICMPMatch::has_code_wildcard() const {
  return _internal_has_code_wildcard();
}
inline void ICMPMatch::set_has_code_wildcard() {
  _oneof_case_[1] = kCodeWildcard;
}
inline void ICMPMatch::clear_code_wildcard() {
  if (_internal_has_code_wildcard()) {
    codematch_.code_wildcard_ = 0;
    clear_has_codematch();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch ICMPMatch::_internal_code_wildcard() const {
  if (_internal_has_code_wildcard()) {
    return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(codematch_.code_wildcard_);
  }
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch >(0);
}
inline ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch ICMPMatch::code_wildcard() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.code_wildcard)
  return _internal_code_wildcard();
}
inline void ICMPMatch::_internal_set_code_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  if (!_internal_has_code_wildcard()) {
    clear_codematch();
    set_has_code_wildcard();
  }
  codematch_.code_wildcard_ = value;
}
inline void ICMPMatch::set_code_wildcard(::opi_api::network::opinetcommon::v1alpha1::WildcardMatch value) {
  _internal_set_code_wildcard(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.ICMPMatch.code_wildcard)
}

inline bool ICMPMatch::has_typematch() const {
  return typematch_case() != TYPEMATCH_NOT_SET;
}
inline void ICMPMatch::clear_has_typematch() {
  _oneof_case_[0] = TYPEMATCH_NOT_SET;
}
inline bool ICMPMatch::has_codematch() const {
  return codematch_case() != CODEMATCH_NOT_SET;
}
inline void ICMPMatch::clear_has_codematch() {
  _oneof_case_[1] = CODEMATCH_NOT_SET;
}
inline ICMPMatch::TypematchCase ICMPMatch::typematch_case() const {
  return ICMPMatch::TypematchCase(_oneof_case_[0]);
}
inline ICMPMatch::CodematchCase ICMPMatch::codematch_case() const {
  return ICMPMatch::CodematchCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// PortListMatch

// repeated .opi_api.network.opinetcommon.v1alpha1.PortRange src_port_range = 1;
inline int PortListMatch::_internal_src_port_range_size() const {
  return src_port_range_.size();
}
inline int PortListMatch::src_port_range_size() const {
  return _internal_src_port_range_size();
}
inline void PortListMatch::clear_src_port_range() {
  src_port_range_.Clear();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::mutable_src_port_range(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range)
  return src_port_range_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >*
PortListMatch::mutable_src_port_range() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range)
  return &src_port_range_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortListMatch::_internal_src_port_range(int index) const {
  return src_port_range_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortListMatch::src_port_range(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range)
  return _internal_src_port_range(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::_internal_add_src_port_range() {
  return src_port_range_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::add_src_port_range() {
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _add = _internal_add_src_port_range();
  // @@protoc_insertion_point(field_add:opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >&
PortListMatch::src_port_range() const {
  // @@protoc_insertion_point(field_list:opi_api.network.opinetcommon.v1alpha1.PortListMatch.src_port_range)
  return src_port_range_;
}

// repeated .opi_api.network.opinetcommon.v1alpha1.PortRange dst_port_range = 2;
inline int PortListMatch::_internal_dst_port_range_size() const {
  return dst_port_range_.size();
}
inline int PortListMatch::dst_port_range_size() const {
  return _internal_dst_port_range_size();
}
inline void PortListMatch::clear_dst_port_range() {
  dst_port_range_.Clear();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::mutable_dst_port_range(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range)
  return dst_port_range_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >*
PortListMatch::mutable_dst_port_range() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range)
  return &dst_port_range_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortListMatch::_internal_dst_port_range(int index) const {
  return dst_port_range_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortRange& PortListMatch::dst_port_range(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range)
  return _internal_dst_port_range(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::_internal_add_dst_port_range() {
  return dst_port_range_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortRange* PortListMatch::add_dst_port_range() {
  ::opi_api::network::opinetcommon::v1alpha1::PortRange* _add = _internal_add_dst_port_range();
  // @@protoc_insertion_point(field_add:opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::PortRange >&
PortListMatch::dst_port_range() const {
  // @@protoc_insertion_point(field_list:opi_api.network.opinetcommon.v1alpha1.PortListMatch.dst_port_range)
  return dst_port_range_;
}

// -------------------------------------------------------------------

// ICMPMatchList

// repeated .opi_api.network.opinetcommon.v1alpha1.ICMPMatch icmp_match_list = 1;
inline int ICMPMatchList::_internal_icmp_match_list_size() const {
  return icmp_match_list_.size();
}
inline int ICMPMatchList::icmp_match_list_size() const {
  return _internal_icmp_match_list_size();
}
inline void ICMPMatchList::clear_icmp_match_list() {
  icmp_match_list_.Clear();
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* ICMPMatchList::mutable_icmp_match_list(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list)
  return icmp_match_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch >*
ICMPMatchList::mutable_icmp_match_list() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list)
  return &icmp_match_list_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& ICMPMatchList::_internal_icmp_match_list(int index) const {
  return icmp_match_list_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& ICMPMatchList::icmp_match_list(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list)
  return _internal_icmp_match_list(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* ICMPMatchList::_internal_add_icmp_match_list() {
  return icmp_match_list_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* ICMPMatchList::add_icmp_match_list() {
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* _add = _internal_add_icmp_match_list();
  // @@protoc_insertion_point(field_add:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch >&
ICMPMatchList::icmp_match_list() const {
  // @@protoc_insertion_point(field_list:opi_api.network.opinetcommon.v1alpha1.ICMPMatchList.icmp_match_list)
  return icmp_match_list_;
}

// -------------------------------------------------------------------

// RuleL4Match

// .opi_api.network.opinetcommon.v1alpha1.PortMatch ports = 1;
inline bool RuleL4Match::_internal_has_ports() const {
  return l4info_case() == kPorts;
}
inline bool RuleL4Match::has_ports() const {
  return _internal_has_ports();
}
inline void RuleL4Match::set_has_ports() {
  _oneof_case_[0] = kPorts;
}
inline void RuleL4Match::clear_ports() {
  if (_internal_has_ports()) {
    if (GetArenaForAllocation() == nullptr) {
      delete l4info_.ports_;
    }
    clear_has_l4info();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortMatch* RuleL4Match::release_ports() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports)
  if (_internal_has_ports()) {
    clear_has_l4info();
      ::opi_api::network::opinetcommon::v1alpha1::PortMatch* temp = l4info_.ports_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    l4info_.ports_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortMatch& RuleL4Match::_internal_ports() const {
  return _internal_has_ports()
      ? *l4info_.ports_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::PortMatch&>(::opi_api::network::opinetcommon::v1alpha1::_PortMatch_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortMatch& RuleL4Match::ports() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports)
  return _internal_ports();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortMatch* RuleL4Match::unsafe_arena_release_ports() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports)
  if (_internal_has_ports()) {
    clear_has_l4info();
    ::opi_api::network::opinetcommon::v1alpha1::PortMatch* temp = l4info_.ports_;
    l4info_.ports_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL4Match::unsafe_arena_set_allocated_ports(::opi_api::network::opinetcommon::v1alpha1::PortMatch* ports) {
  clear_l4info();
  if (ports) {
    set_has_ports();
    l4info_.ports_ = ports;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports)
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortMatch* RuleL4Match::_internal_mutable_ports() {
  if (!_internal_has_ports()) {
    clear_l4info();
    set_has_ports();
    l4info_.ports_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::PortMatch >(GetArenaForAllocation());
  }
  return l4info_.ports_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortMatch* RuleL4Match::mutable_ports() {
  ::opi_api::network::opinetcommon::v1alpha1::PortMatch* _msg = _internal_mutable_ports();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.ports)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.ICMPMatch type_code = 2;
inline bool RuleL4Match::_internal_has_type_code() const {
  return l4info_case() == kTypeCode;
}
inline bool RuleL4Match::has_type_code() const {
  return _internal_has_type_code();
}
inline void RuleL4Match::set_has_type_code() {
  _oneof_case_[0] = kTypeCode;
}
inline void RuleL4Match::clear_type_code() {
  if (_internal_has_type_code()) {
    if (GetArenaForAllocation() == nullptr) {
      delete l4info_.type_code_;
    }
    clear_has_l4info();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* RuleL4Match::release_type_code() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code)
  if (_internal_has_type_code()) {
    clear_has_l4info();
      ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* temp = l4info_.type_code_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    l4info_.type_code_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& RuleL4Match::_internal_type_code() const {
  return _internal_has_type_code()
      ? *l4info_.type_code_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch&>(::opi_api::network::opinetcommon::v1alpha1::_ICMPMatch_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch& RuleL4Match::type_code() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code)
  return _internal_type_code();
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* RuleL4Match::unsafe_arena_release_type_code() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code)
  if (_internal_has_type_code()) {
    clear_has_l4info();
    ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* temp = l4info_.type_code_;
    l4info_.type_code_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL4Match::unsafe_arena_set_allocated_type_code(::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* type_code) {
  clear_l4info();
  if (type_code) {
    set_has_type_code();
    l4info_.type_code_ = type_code;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code)
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* RuleL4Match::_internal_mutable_type_code() {
  if (!_internal_has_type_code()) {
    clear_l4info();
    set_has_type_code();
    l4info_.type_code_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch >(GetArenaForAllocation());
  }
  return l4info_.type_code_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* RuleL4Match::mutable_type_code() {
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatch* _msg = _internal_mutable_type_code();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.type_code)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.PortListMatch port_list = 3;
inline bool RuleL4Match::_internal_has_port_list() const {
  return l4info_case() == kPortList;
}
inline bool RuleL4Match::has_port_list() const {
  return _internal_has_port_list();
}
inline void RuleL4Match::set_has_port_list() {
  _oneof_case_[0] = kPortList;
}
inline void RuleL4Match::clear_port_list() {
  if (_internal_has_port_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete l4info_.port_list_;
    }
    clear_has_l4info();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* RuleL4Match::release_port_list() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list)
  if (_internal_has_port_list()) {
    clear_has_l4info();
      ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* temp = l4info_.port_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    l4info_.port_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortListMatch& RuleL4Match::_internal_port_list() const {
  return _internal_has_port_list()
      ? *l4info_.port_list_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::PortListMatch&>(::opi_api::network::opinetcommon::v1alpha1::_PortListMatch_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::PortListMatch& RuleL4Match::port_list() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list)
  return _internal_port_list();
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* RuleL4Match::unsafe_arena_release_port_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list)
  if (_internal_has_port_list()) {
    clear_has_l4info();
    ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* temp = l4info_.port_list_;
    l4info_.port_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL4Match::unsafe_arena_set_allocated_port_list(::opi_api::network::opinetcommon::v1alpha1::PortListMatch* port_list) {
  clear_l4info();
  if (port_list) {
    set_has_port_list();
    l4info_.port_list_ = port_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list)
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* RuleL4Match::_internal_mutable_port_list() {
  if (!_internal_has_port_list()) {
    clear_l4info();
    set_has_port_list();
    l4info_.port_list_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::PortListMatch >(GetArenaForAllocation());
  }
  return l4info_.port_list_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* RuleL4Match::mutable_port_list() {
  ::opi_api::network::opinetcommon::v1alpha1::PortListMatch* _msg = _internal_mutable_port_list();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.port_list)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.ICMPMatchList icmp_match_list = 4;
inline bool RuleL4Match::_internal_has_icmp_match_list() const {
  return l4info_case() == kIcmpMatchList;
}
inline bool RuleL4Match::has_icmp_match_list() const {
  return _internal_has_icmp_match_list();
}
inline void RuleL4Match::set_has_icmp_match_list() {
  _oneof_case_[0] = kIcmpMatchList;
}
inline void RuleL4Match::clear_icmp_match_list() {
  if (_internal_has_icmp_match_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete l4info_.icmp_match_list_;
    }
    clear_has_l4info();
  }
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* RuleL4Match::release_icmp_match_list() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list)
  if (_internal_has_icmp_match_list()) {
    clear_has_l4info();
      ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* temp = l4info_.icmp_match_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    l4info_.icmp_match_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList& RuleL4Match::_internal_icmp_match_list() const {
  return _internal_has_icmp_match_list()
      ? *l4info_.icmp_match_list_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList&>(::opi_api::network::opinetcommon::v1alpha1::_ICMPMatchList_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList& RuleL4Match::icmp_match_list() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list)
  return _internal_icmp_match_list();
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* RuleL4Match::unsafe_arena_release_icmp_match_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list)
  if (_internal_has_icmp_match_list()) {
    clear_has_l4info();
    ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* temp = l4info_.icmp_match_list_;
    l4info_.icmp_match_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RuleL4Match::unsafe_arena_set_allocated_icmp_match_list(::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* icmp_match_list) {
  clear_l4info();
  if (icmp_match_list) {
    set_has_icmp_match_list();
    l4info_.icmp_match_list_ = icmp_match_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list)
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* RuleL4Match::_internal_mutable_icmp_match_list() {
  if (!_internal_has_icmp_match_list()) {
    clear_l4info();
    set_has_icmp_match_list();
    l4info_.icmp_match_list_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList >(GetArenaForAllocation());
  }
  return l4info_.icmp_match_list_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* RuleL4Match::mutable_icmp_match_list() {
  ::opi_api::network::opinetcommon::v1alpha1::ICMPMatchList* _msg = _internal_mutable_icmp_match_list();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleL4Match.icmp_match_list)
  return _msg;
}

inline bool RuleL4Match::has_l4info() const {
  return l4info_case() != L4INFO_NOT_SET;
}
inline void RuleL4Match::clear_has_l4info() {
  _oneof_case_[0] = L4INFO_NOT_SET;
}
inline RuleL4Match::L4InfoCase RuleL4Match::l4info_case() const {
  return RuleL4Match::L4InfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RuleMatch

// .opi_api.network.opinetcommon.v1alpha1.RuleL3Match l3_match = 1;
inline bool RuleMatch::_internal_has_l3_match() const {
  return this != internal_default_instance() && l3_match_ != nullptr;
}
inline bool RuleMatch::has_l3_match() const {
  return _internal_has_l3_match();
}
inline void RuleMatch::clear_l3_match() {
  if (GetArenaForAllocation() == nullptr && l3_match_ != nullptr) {
    delete l3_match_;
  }
  l3_match_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match& RuleMatch::_internal_l3_match() const {
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* p = l3_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match&>(
      ::opi_api::network::opinetcommon::v1alpha1::_RuleL3Match_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match& RuleMatch::l3_match() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match)
  return _internal_l3_match();
}
inline void RuleMatch::unsafe_arena_set_allocated_l3_match(
    ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* l3_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(l3_match_);
  }
  l3_match_ = l3_match;
  if (l3_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match)
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* RuleMatch::release_l3_match() {
  
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* temp = l3_match_;
  l3_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* RuleMatch::unsafe_arena_release_l3_match() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match)
  
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* temp = l3_match_;
  l3_match_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* RuleMatch::_internal_mutable_l3_match() {
  
  if (l3_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::RuleL3Match>(GetArenaForAllocation());
    l3_match_ = p;
  }
  return l3_match_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* RuleMatch::mutable_l3_match() {
  ::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* _msg = _internal_mutable_l3_match();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match)
  return _msg;
}
inline void RuleMatch::set_allocated_l3_match(::opi_api::network::opinetcommon::v1alpha1::RuleL3Match* l3_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete l3_match_;
  }
  if (l3_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::RuleL3Match>::GetOwningArena(l3_match);
    if (message_arena != submessage_arena) {
      l3_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l3_match, submessage_arena);
    }
    
  } else {
    
  }
  l3_match_ = l3_match;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l3_match)
}

// .opi_api.network.opinetcommon.v1alpha1.RuleL4Match l4_match = 2;
inline bool RuleMatch::_internal_has_l4_match() const {
  return this != internal_default_instance() && l4_match_ != nullptr;
}
inline bool RuleMatch::has_l4_match() const {
  return _internal_has_l4_match();
}
inline void RuleMatch::clear_l4_match() {
  if (GetArenaForAllocation() == nullptr && l4_match_ != nullptr) {
    delete l4_match_;
  }
  l4_match_ = nullptr;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match& RuleMatch::_internal_l4_match() const {
  const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* p = l4_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match&>(
      ::opi_api::network::opinetcommon::v1alpha1::_RuleL4Match_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match& RuleMatch::l4_match() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match)
  return _internal_l4_match();
}
inline void RuleMatch::unsafe_arena_set_allocated_l4_match(
    ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* l4_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(l4_match_);
  }
  l4_match_ = l4_match;
  if (l4_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match)
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* RuleMatch::release_l4_match() {
  
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* temp = l4_match_;
  l4_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* RuleMatch::unsafe_arena_release_l4_match() {
  // @@protoc_insertion_point(field_release:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match)
  
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* temp = l4_match_;
  l4_match_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* RuleMatch::_internal_mutable_l4_match() {
  
  if (l4_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::RuleL4Match>(GetArenaForAllocation());
    l4_match_ = p;
  }
  return l4_match_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* RuleMatch::mutable_l4_match() {
  ::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* _msg = _internal_mutable_l4_match();
  // @@protoc_insertion_point(field_mutable:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match)
  return _msg;
}
inline void RuleMatch::set_allocated_l4_match(::opi_api::network::opinetcommon::v1alpha1::RuleL4Match* l4_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete l4_match_;
  }
  if (l4_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::opinetcommon::v1alpha1::RuleL4Match>::GetOwningArena(l4_match);
    if (message_arena != submessage_arena) {
      l4_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l4_match, submessage_arena);
    }
    
  } else {
    
  }
  l4_match_ = l4_match;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.opinetcommon.v1alpha1.RuleMatch.l4_match)
}

// -------------------------------------------------------------------

// HwHandle

// uint64 idx = 1;
inline void HwHandle::clear_idx() {
  idx_ = uint64_t{0u};
}
inline uint64_t HwHandle::_internal_idx() const {
  return idx_;
}
inline uint64_t HwHandle::idx() const {
  // @@protoc_insertion_point(field_get:opi_api.network.opinetcommon.v1alpha1.HwHandle.idx)
  return _internal_idx();
}
inline void HwHandle::_internal_set_idx(uint64_t value) {
  
  idx_ = value;
}
inline void HwHandle::set_idx(uint64_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:opi_api.network.opinetcommon.v1alpha1.HwHandle.idx)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace opinetcommon
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::SecurityRuleAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::SecurityRuleAction>() {
  return ::opi_api::network::opinetcommon::v1alpha1::SecurityRuleAction_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::IpAf> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::IpAf>() {
  return ::opi_api::network::opinetcommon::v1alpha1::IpAf_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::EncapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::EncapType>() {
  return ::opi_api::network::opinetcommon::v1alpha1::EncapType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::RouteType>() {
  return ::opi_api::network::opinetcommon::v1alpha1::RouteType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::RouteProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::RouteProtocol>() {
  return ::opi_api::network::opinetcommon::v1alpha1::RouteProtocol_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::AdminState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::AdminState>() {
  return ::opi_api::network::opinetcommon::v1alpha1::AdminState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::PolicyDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::PolicyDir>() {
  return ::opi_api::network::opinetcommon::v1alpha1::PolicyDir_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch>() {
  return ::opi_api::network::opinetcommon::v1alpha1::WildcardMatch_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_networktypes_2eproto
