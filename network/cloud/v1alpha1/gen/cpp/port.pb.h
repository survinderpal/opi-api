// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: port.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_port_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_port_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "object_key.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_port_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_port_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_port_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class Port;
struct PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class PortLinkFSMRecord;
struct PortLinkFSMRecordDefaultTypeInternal;
extern PortLinkFSMRecordDefaultTypeInternal _PortLinkFSMRecord_default_instance_;
class PortLinkStatus;
struct PortLinkStatusDefaultTypeInternal;
extern PortLinkStatusDefaultTypeInternal _PortLinkStatus_default_instance_;
class PortSpec;
struct PortSpecDefaultTypeInternal;
extern PortSpecDefaultTypeInternal _PortSpec_default_instance_;
class PortStatus;
struct PortStatusDefaultTypeInternal;
extern PortStatusDefaultTypeInternal _PortStatus_default_instance_;
class PortXcvrStatus;
struct PortXcvrStatusDefaultTypeInternal;
extern PortXcvrStatusDefaultTypeInternal _PortXcvrStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::Port* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::Port>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::PortLinkStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortLinkStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::PortSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::PortStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortXcvrStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum PortAdminState : int {
  PORT_ADMIN_STATE_UNSPECIFIED = 0,
  PORT_ADMIN_STATE_DOWN = 1,
  PORT_ADMIN_STATE_UP = 2,
  PortAdminState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortAdminState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortAdminState_IsValid(int value);
constexpr PortAdminState PortAdminState_MIN = PORT_ADMIN_STATE_UNSPECIFIED;
constexpr PortAdminState PortAdminState_MAX = PORT_ADMIN_STATE_UP;
constexpr int PortAdminState_ARRAYSIZE = PortAdminState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortAdminState_descriptor();
template<typename T>
inline const std::string& PortAdminState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortAdminState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortAdminState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortAdminState_descriptor(), enum_t_value);
}
inline bool PortAdminState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortAdminState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortAdminState>(
    PortAdminState_descriptor(), name, value);
}
enum PortXcvrState : int {
  PORT_XCVR_STATE_UNSPECIFIED = 0,
  PORT_XCVR_STATE_INSERTED = 1,
  PORT_XCVR_STATE_PENDING = 2,
  PORT_XCVR_STATE_SPROM_READ = 3,
  PORT_XCVR_STATE_SPROM_READ_ERR = 4,
  PortXcvrState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortXcvrState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortXcvrState_IsValid(int value);
constexpr PortXcvrState PortXcvrState_MIN = PORT_XCVR_STATE_UNSPECIFIED;
constexpr PortXcvrState PortXcvrState_MAX = PORT_XCVR_STATE_SPROM_READ_ERR;
constexpr int PortXcvrState_ARRAYSIZE = PortXcvrState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortXcvrState_descriptor();
template<typename T>
inline const std::string& PortXcvrState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortXcvrState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortXcvrState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortXcvrState_descriptor(), enum_t_value);
}
inline bool PortXcvrState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortXcvrState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortXcvrState>(
    PortXcvrState_descriptor(), name, value);
}
enum PortXcvrPid : int {
  PORT_XCVR_PID_UNSPECIFIED = 0,
  PORT_XCVR_PID_QSFP_100G_CR4 = 1,
  PORT_XCVR_PID_QSFP_40GBASE_CR4 = 2,
  PORT_XCVR_PID_SFP_25GBASE_CR_S = 3,
  PORT_XCVR_PID_SFP_25GBASE_CR_L = 4,
  PORT_XCVR_PID_SFP_25GBASE_CR_N = 5,
  PORT_XCVR_PID_QSFP_50G_CR2_FC = 6,
  PORT_XCVR_PID_QSFP_50G_CR2 = 7,
  PORT_XCVR_PID_QSFP_200G_CR4 = 8,
  PORT_XCVR_PID_QSFP_100G_AOC = 50,
  PORT_XCVR_PID_QSFP_100G_ACC = 51,
  PORT_XCVR_PID_QSFP_100G_SR4 = 52,
  PORT_XCVR_PID_QSFP_100G_LR4 = 53,
  PORT_XCVR_PID_QSFP_100G_ER4 = 54,
  PORT_XCVR_PID_QSFP_40GBASE_ER4 = 55,
  PORT_XCVR_PID_QSFP_40GBASE_SR4 = 56,
  PORT_XCVR_PID_QSFP_40GBASE_LR4 = 57,
  PORT_XCVR_PID_QSFP_40GBASE_AOC = 58,
  PORT_XCVR_PID_SFP_25GBASE_SR = 59,
  PORT_XCVR_PID_SFP_25GBASE_LR = 60,
  PORT_XCVR_PID_SFP_25GBASE_ER = 61,
  PORT_XCVR_PID_SFP_25GBASE_AOC = 62,
  PORT_XCVR_PID_SFP_10GBASE_SR = 63,
  PORT_XCVR_PID_SFP_10GBASE_LR = 64,
  PORT_XCVR_PID_SFP_10GBASE_LRM = 65,
  PORT_XCVR_PID_SFP_10GBASE_ER = 66,
  PORT_XCVR_PID_SFP_10GBASE_AOC = 67,
  PORT_XCVR_PID_SFP_10GBASE_CU = 68,
  PORT_XCVR_PID_QSFP_100G_CWDM4 = 69,
  PORT_XCVR_PID_QSFP_100G_PSM4 = 70,
  PORT_XCVR_PID_SFP_25GBASE_ACC = 71,
  PORT_XCVR_PID_SFP_10GBASE_T = 72,
  PORT_XCVR_PID_SFP_1000BASE_T = 73,
  PortXcvrPid_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortXcvrPid_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortXcvrPid_IsValid(int value);
constexpr PortXcvrPid PortXcvrPid_MIN = PORT_XCVR_PID_UNSPECIFIED;
constexpr PortXcvrPid PortXcvrPid_MAX = PORT_XCVR_PID_SFP_1000BASE_T;
constexpr int PortXcvrPid_ARRAYSIZE = PortXcvrPid_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortXcvrPid_descriptor();
template<typename T>
inline const std::string& PortXcvrPid_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortXcvrPid>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortXcvrPid_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortXcvrPid_descriptor(), enum_t_value);
}
inline bool PortXcvrPid_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortXcvrPid* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortXcvrPid>(
    PortXcvrPid_descriptor(), name, value);
}
enum MediaType : int {
  MEDIA_TYPE_UNSPECIFIED = 0,
  MEDIA_TYPE_COPPER = 1,
  MEDIA_TYPE_FIBER = 2,
  MediaType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MediaType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MediaType_IsValid(int value);
constexpr MediaType MediaType_MIN = MEDIA_TYPE_UNSPECIFIED;
constexpr MediaType MediaType_MAX = MEDIA_TYPE_FIBER;
constexpr int MediaType_ARRAYSIZE = MediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaType_descriptor();
template<typename T>
inline const std::string& MediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaType_descriptor(), enum_t_value);
}
inline bool MediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaType>(
    MediaType_descriptor(), name, value);
}
enum PortOperState : int {
  PORT_OPER_STATE_UNSPECIFIED = 0,
  PORT_OPER_STATE_UP = 1,
  PORT_OPER_STATE_DOWN = 2,
  PortOperState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortOperState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortOperState_IsValid(int value);
constexpr PortOperState PortOperState_MIN = PORT_OPER_STATE_UNSPECIFIED;
constexpr PortOperState PortOperState_MAX = PORT_OPER_STATE_DOWN;
constexpr int PortOperState_ARRAYSIZE = PortOperState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortOperState_descriptor();
template<typename T>
inline const std::string& PortOperState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortOperState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortOperState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortOperState_descriptor(), enum_t_value);
}
inline bool PortOperState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortOperState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortOperState>(
    PortOperState_descriptor(), name, value);
}
enum PortPauseType : int {
  PORT_PAUSE_TYPE_UNSPECIFIED = 0,
  PORT_PAUSE_TYPE_LINK = 1,
  PORT_PAUSE_TYPE_PFC = 2,
  PortPauseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortPauseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortPauseType_IsValid(int value);
constexpr PortPauseType PortPauseType_MIN = PORT_PAUSE_TYPE_UNSPECIFIED;
constexpr PortPauseType PortPauseType_MAX = PORT_PAUSE_TYPE_PFC;
constexpr int PortPauseType_ARRAYSIZE = PortPauseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortPauseType_descriptor();
template<typename T>
inline const std::string& PortPauseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortPauseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortPauseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortPauseType_descriptor(), enum_t_value);
}
inline bool PortPauseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortPauseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortPauseType>(
    PortPauseType_descriptor(), name, value);
}
enum PortLinkFSM : int {
  PORT_LINK_FSM_UNSPECIFIED = 0,
  PORT_LINK_FSM_ENABLED = 1,
  PORT_LINK_FSM_AN_CFG = 2,
  PORT_LINK_FSM_AN_DISABLED = 3,
  PORT_LINK_FSM_AN_START = 4,
  PORT_LINK_FSM_AN_SIGNAL_DETECT = 5,
  PORT_LINK_FSM_AN_WAIT_HCD = 6,
  PORT_LINK_FSM_AN_COMPLETE = 7,
  PORT_LINK_FSM_SERDES_CFG = 8,
  PORT_LINK_FSM_WAIT_SERDES_RDY = 9,
  PORT_LINK_FSM_MAC_CFG = 10,
  PORT_LINK_FSM_SIGNAL_DETECT = 11,
  PORT_LINK_FSM_AN_DFE_TUNING = 12,
  PORT_LINK_FSM_DFE_TUNING = 13,
  PORT_LINK_FSM_DFE_DISABLED = 14,
  PORT_LINK_FSM_DFE_START_ICAL = 15,
  PORT_LINK_FSM_DFE_WAIT_ICAL = 16,
  PORT_LINK_FSM_DFE_START_PCAL = 17,
  PORT_LINK_FSM_DFE_WAIT_PCAL = 18,
  PORT_LINK_FSM_DFE_PCAL_CONTINUOUS = 19,
  PORT_LINK_FSM_CLEAR_MAC_REMOTE_FAULTS = 20,
  PORT_LINK_FSM_WAIT_MAC_SYNC = 21,
  PORT_LINK_FSM_WAIT_MAC_FAULTS_CLEAR = 22,
  PORT_LINK_FSM_WAIT_PHY_LINK_UP = 23,
  PORT_LINK_FSM_UP = 24,
  PortLinkFSM_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortLinkFSM_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortLinkFSM_IsValid(int value);
constexpr PortLinkFSM PortLinkFSM_MIN = PORT_LINK_FSM_UNSPECIFIED;
constexpr PortLinkFSM PortLinkFSM_MAX = PORT_LINK_FSM_UP;
constexpr int PortLinkFSM_ARRAYSIZE = PortLinkFSM_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortLinkFSM_descriptor();
template<typename T>
inline const std::string& PortLinkFSM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortLinkFSM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortLinkFSM_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortLinkFSM_descriptor(), enum_t_value);
}
inline bool PortLinkFSM_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortLinkFSM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortLinkFSM>(
    PortLinkFSM_descriptor(), name, value);
}
enum PortLoopBackMode : int {
  PORT_LOOP_BACK_MODE_UNSPECIFIED = 0,
  PORT_LOOP_BACK_MODE_MAC = 1,
  PORT_LOOP_BACK_MODE_PHY = 2,
  PortLoopBackMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortLoopBackMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortLoopBackMode_IsValid(int value);
constexpr PortLoopBackMode PortLoopBackMode_MIN = PORT_LOOP_BACK_MODE_UNSPECIFIED;
constexpr PortLoopBackMode PortLoopBackMode_MAX = PORT_LOOP_BACK_MODE_PHY;
constexpr int PortLoopBackMode_ARRAYSIZE = PortLoopBackMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortLoopBackMode_descriptor();
template<typename T>
inline const std::string& PortLoopBackMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortLoopBackMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortLoopBackMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortLoopBackMode_descriptor(), enum_t_value);
}
inline bool PortLoopBackMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortLoopBackMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortLoopBackMode>(
    PortLoopBackMode_descriptor(), name, value);
}
enum PortFecType : int {
  PORT_FEC_TYPE_UNSPECIFIED = 0,
  PORT_FEC_TYPE_FC = 1,
  PORT_FEC_TYPE_RS = 2,
  PortFecType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortFecType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortFecType_IsValid(int value);
constexpr PortFecType PortFecType_MIN = PORT_FEC_TYPE_UNSPECIFIED;
constexpr PortFecType PortFecType_MAX = PORT_FEC_TYPE_RS;
constexpr int PortFecType_ARRAYSIZE = PortFecType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortFecType_descriptor();
template<typename T>
inline const std::string& PortFecType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortFecType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortFecType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortFecType_descriptor(), enum_t_value);
}
inline bool PortFecType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortFecType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortFecType>(
    PortFecType_descriptor(), name, value);
}
enum PortType : int {
  PORT_TYPE_UNSPECIFIED = 0,
  PORT_TYPE_ETH = 1,
  PORT_TYPE_ETH_MGMT = 2,
  PortType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortType_IsValid(int value);
constexpr PortType PortType_MIN = PORT_TYPE_UNSPECIFIED;
constexpr PortType PortType_MAX = PORT_TYPE_ETH_MGMT;
constexpr int PortType_ARRAYSIZE = PortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortType_descriptor();
template<typename T>
inline const std::string& PortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortType_descriptor(), enum_t_value);
}
inline bool PortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortType>(
    PortType_descriptor(), name, value);
}
enum PortSpeed : int {
  PORT_SPEED_UNSPECIFIED = 0,
  PORT_SPEED_10M = 1,
  PORT_SPEED_100M = 2,
  PORT_SPEED_1G = 3,
  PORT_SPEED_10G = 4,
  PORT_SPEED_25G = 5,
  PORT_SPEED_40G = 6,
  PORT_SPEED_50G = 7,
  PORT_SPEED_100G = 8,
  PORT_SPEED_200G = 9,
  PORT_SPEED_400G = 10,
  PortSpeed_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PortSpeed_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PortSpeed_IsValid(int value);
constexpr PortSpeed PortSpeed_MIN = PORT_SPEED_UNSPECIFIED;
constexpr PortSpeed PortSpeed_MAX = PORT_SPEED_400G;
constexpr int PortSpeed_ARRAYSIZE = PortSpeed_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PortSpeed_descriptor();
template<typename T>
inline const std::string& PortSpeed_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PortSpeed>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PortSpeed_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PortSpeed_descriptor(), enum_t_value);
}
inline bool PortSpeed_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PortSpeed* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PortSpeed>(
    PortSpeed_descriptor(), name, value);
}
// ===================================================================

class Port final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.Port) */ {
 public:
  inline Port() : Port(nullptr) {}
  ~Port() override;
  explicit constexpr Port(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Port& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Port& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.network.cloud.v1alpha1.PortSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::PortSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::PortSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::PortSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::PortSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::PortSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::PortSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::PortSpec* spec);
  ::opi_api::network::cloud::v1alpha1::PortSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.PortStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::PortStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::PortStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::PortStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::PortStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::PortStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::PortStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::PortStatus* status);
  ::opi_api::network::cloud::v1alpha1::PortStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::cloud::v1alpha1::PortSpec* spec_;
  ::opi_api::network::cloud::v1alpha1::PortStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// -------------------------------------------------------------------

class PortSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.PortSpec) */ {
 public:
  inline PortSpec() : PortSpec(nullptr) {}
  ~PortSpec() override;
  explicit constexpr PortSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortSpec(const PortSpec& from);
  PortSpec(PortSpec&& from) noexcept
    : PortSpec() {
    *this = ::std::move(from);
  }

  inline PortSpec& operator=(const PortSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortSpec& operator=(PortSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortSpec* internal_default_instance() {
    return reinterpret_cast<const PortSpec*>(
               &_PortSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PortSpec& a, PortSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(PortSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.PortSpec";
  }
  protected:
  explicit PortSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPortNumberFieldNumber = 2,
    kAdminStateFieldNumber = 3,
    kTypeFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kFecTypeFieldNumber = 6,
    kDebounceTimeoutFieldNumber = 8,
    kMtuFieldNumber = 9,
    kPauseTypeFieldNumber = 10,
    kAutonegEnableFieldNumber = 7,
    kTxPauseEnFieldNumber = 11,
    kRxPauseEnFieldNumber = 12,
    kLoopbackModeFieldNumber = 13,
    kLanesCountFieldNumber = 14,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // int32 port_number = 2;
  void clear_port_number();
  int32_t port_number() const;
  void set_port_number(int32_t value);
  private:
  int32_t _internal_port_number() const;
  void _internal_set_port_number(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortAdminState admin_state = 3;
  void clear_admin_state();
  ::opi_api::network::cloud::v1alpha1::PortAdminState admin_state() const;
  void set_admin_state(::opi_api::network::cloud::v1alpha1::PortAdminState value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortAdminState _internal_admin_state() const;
  void _internal_set_admin_state(::opi_api::network::cloud::v1alpha1::PortAdminState value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortType type = 4;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::PortType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::PortType value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::PortType value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortSpeed speed = 5;
  void clear_speed();
  ::opi_api::network::cloud::v1alpha1::PortSpeed speed() const;
  void set_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortSpeed _internal_speed() const;
  void _internal_set_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortFecType fec_type = 6;
  void clear_fec_type();
  ::opi_api::network::cloud::v1alpha1::PortFecType fec_type() const;
  void set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortFecType _internal_fec_type() const;
  void _internal_set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value);
  public:

  // int32 debounce_timeout = 8;
  void clear_debounce_timeout();
  int32_t debounce_timeout() const;
  void set_debounce_timeout(int32_t value);
  private:
  int32_t _internal_debounce_timeout() const;
  void _internal_set_debounce_timeout(int32_t value);
  public:

  // int32 mtu = 9;
  void clear_mtu();
  int32_t mtu() const;
  void set_mtu(int32_t value);
  private:
  int32_t _internal_mtu() const;
  void _internal_set_mtu(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortPauseType pause_type = 10;
  void clear_pause_type();
  ::opi_api::network::cloud::v1alpha1::PortPauseType pause_type() const;
  void set_pause_type(::opi_api::network::cloud::v1alpha1::PortPauseType value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortPauseType _internal_pause_type() const;
  void _internal_set_pause_type(::opi_api::network::cloud::v1alpha1::PortPauseType value);
  public:

  // bool autoneg_enable = 7;
  void clear_autoneg_enable();
  bool autoneg_enable() const;
  void set_autoneg_enable(bool value);
  private:
  bool _internal_autoneg_enable() const;
  void _internal_set_autoneg_enable(bool value);
  public:

  // bool tx_pause_en = 11;
  void clear_tx_pause_en();
  bool tx_pause_en() const;
  void set_tx_pause_en(bool value);
  private:
  bool _internal_tx_pause_en() const;
  void _internal_set_tx_pause_en(bool value);
  public:

  // bool rx_pause_en = 12;
  void clear_rx_pause_en();
  bool rx_pause_en() const;
  void set_rx_pause_en(bool value);
  private:
  bool _internal_rx_pause_en() const;
  void _internal_set_rx_pause_en(bool value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortLoopBackMode loopback_mode = 13;
  void clear_loopback_mode();
  ::opi_api::network::cloud::v1alpha1::PortLoopBackMode loopback_mode() const;
  void set_loopback_mode(::opi_api::network::cloud::v1alpha1::PortLoopBackMode value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortLoopBackMode _internal_loopback_mode() const;
  void _internal_set_loopback_mode(::opi_api::network::cloud::v1alpha1::PortLoopBackMode value);
  public:

  // int32 lanes_count = 14;
  void clear_lanes_count();
  int32_t lanes_count() const;
  void set_lanes_count(int32_t value);
  private:
  int32_t _internal_lanes_count() const;
  void _internal_set_lanes_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.PortSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  int32_t port_number_;
  int admin_state_;
  int type_;
  int speed_;
  int fec_type_;
  int32_t debounce_timeout_;
  int32_t mtu_;
  int pause_type_;
  bool autoneg_enable_;
  bool tx_pause_en_;
  bool rx_pause_en_;
  int loopback_mode_;
  int32_t lanes_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// -------------------------------------------------------------------

class PortStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.PortStatus) */ {
 public:
  inline PortStatus() : PortStatus(nullptr) {}
  ~PortStatus() override;
  explicit constexpr PortStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortStatus(const PortStatus& from);
  PortStatus(PortStatus&& from) noexcept
    : PortStatus() {
    *this = ::std::move(from);
  }

  inline PortStatus& operator=(const PortStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortStatus& operator=(PortStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortStatus* internal_default_instance() {
    return reinterpret_cast<const PortStatus*>(
               &_PortStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PortStatus& a, PortStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PortStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.PortStatus";
  }
  protected:
  explicit PortStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFsmRecordFieldNumber = 7,
    kLinkStatusFieldNumber = 2,
    kXcvrStatusFieldNumber = 3,
    kIfIndexFieldNumber = 1,
    kFsmStateFieldNumber = 4,
    kMacIdFieldNumber = 5,
    kMacChFieldNumber = 6,
  };
  // repeated .opi_api.network.cloud.v1alpha1.PortLinkFSMRecord fsm_record = 7;
  int fsm_record_size() const;
  private:
  int _internal_fsm_record_size() const;
  public:
  void clear_fsm_record();
  ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* mutable_fsm_record(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord >*
      mutable_fsm_record();
  private:
  const ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord& _internal_fsm_record(int index) const;
  ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* _internal_add_fsm_record();
  public:
  const ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord& fsm_record(int index) const;
  ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* add_fsm_record();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord >&
      fsm_record() const;

  // .opi_api.network.cloud.v1alpha1.PortLinkStatus link_status = 2;
  bool has_link_status() const;
  private:
  bool _internal_has_link_status() const;
  public:
  void clear_link_status();
  const ::opi_api::network::cloud::v1alpha1::PortLinkStatus& link_status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::PortLinkStatus* release_link_status();
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* mutable_link_status();
  void set_allocated_link_status(::opi_api::network::cloud::v1alpha1::PortLinkStatus* link_status);
  private:
  const ::opi_api::network::cloud::v1alpha1::PortLinkStatus& _internal_link_status() const;
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* _internal_mutable_link_status();
  public:
  void unsafe_arena_set_allocated_link_status(
      ::opi_api::network::cloud::v1alpha1::PortLinkStatus* link_status);
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* unsafe_arena_release_link_status();

  // .opi_api.network.cloud.v1alpha1.PortXcvrStatus xcvr_status = 3;
  bool has_xcvr_status() const;
  private:
  bool _internal_has_xcvr_status() const;
  public:
  void clear_xcvr_status();
  const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus& xcvr_status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* release_xcvr_status();
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* mutable_xcvr_status();
  void set_allocated_xcvr_status(::opi_api::network::cloud::v1alpha1::PortXcvrStatus* xcvr_status);
  private:
  const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus& _internal_xcvr_status() const;
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* _internal_mutable_xcvr_status();
  public:
  void unsafe_arena_set_allocated_xcvr_status(
      ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* xcvr_status);
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* unsafe_arena_release_xcvr_status();

  // uint32 if_index = 1;
  void clear_if_index();
  uint32_t if_index() const;
  void set_if_index(uint32_t value);
  private:
  uint32_t _internal_if_index() const;
  void _internal_set_if_index(uint32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortLinkFSM fsm_state = 4;
  void clear_fsm_state();
  ::opi_api::network::cloud::v1alpha1::PortLinkFSM fsm_state() const;
  void set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortLinkFSM _internal_fsm_state() const;
  void _internal_set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value);
  public:

  // int32 mac_id = 5;
  void clear_mac_id();
  int32_t mac_id() const;
  void set_mac_id(int32_t value);
  private:
  int32_t _internal_mac_id() const;
  void _internal_set_mac_id(int32_t value);
  public:

  // int32 mac_ch = 6;
  void clear_mac_ch();
  int32_t mac_ch() const;
  void set_mac_ch(int32_t value);
  private:
  int32_t _internal_mac_ch() const;
  void _internal_set_mac_ch(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.PortStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord > fsm_record_;
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* link_status_;
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* xcvr_status_;
  uint32_t if_index_;
  int fsm_state_;
  int32_t mac_id_;
  int32_t mac_ch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// -------------------------------------------------------------------

class PortLinkStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.PortLinkStatus) */ {
 public:
  inline PortLinkStatus() : PortLinkStatus(nullptr) {}
  ~PortLinkStatus() override;
  explicit constexpr PortLinkStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortLinkStatus(const PortLinkStatus& from);
  PortLinkStatus(PortLinkStatus&& from) noexcept
    : PortLinkStatus() {
    *this = ::std::move(from);
  }

  inline PortLinkStatus& operator=(const PortLinkStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortLinkStatus& operator=(PortLinkStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortLinkStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortLinkStatus* internal_default_instance() {
    return reinterpret_cast<const PortLinkStatus*>(
               &_PortLinkStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PortLinkStatus& a, PortLinkStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PortLinkStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortLinkStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortLinkStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortLinkStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortLinkStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortLinkStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortLinkStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.PortLinkStatus";
  }
  protected:
  explicit PortLinkStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperStateFieldNumber = 1,
    kPortSpeedFieldNumber = 2,
    kAutonegEnFieldNumber = 3,
    kLanesCountFieldNumber = 4,
    kFecTypeFieldNumber = 5,
  };
  // .opi_api.network.cloud.v1alpha1.PortOperState oper_state = 1;
  void clear_oper_state();
  ::opi_api::network::cloud::v1alpha1::PortOperState oper_state() const;
  void set_oper_state(::opi_api::network::cloud::v1alpha1::PortOperState value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortOperState _internal_oper_state() const;
  void _internal_set_oper_state(::opi_api::network::cloud::v1alpha1::PortOperState value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortSpeed port_speed = 2;
  void clear_port_speed();
  ::opi_api::network::cloud::v1alpha1::PortSpeed port_speed() const;
  void set_port_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortSpeed _internal_port_speed() const;
  void _internal_set_port_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value);
  public:

  // bool autoneg_en = 3;
  void clear_autoneg_en();
  bool autoneg_en() const;
  void set_autoneg_en(bool value);
  private:
  bool _internal_autoneg_en() const;
  void _internal_set_autoneg_en(bool value);
  public:

  // int32 lanes_count = 4;
  void clear_lanes_count();
  int32_t lanes_count() const;
  void set_lanes_count(int32_t value);
  private:
  int32_t _internal_lanes_count() const;
  void _internal_set_lanes_count(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortFecType fec_type = 5;
  void clear_fec_type();
  ::opi_api::network::cloud::v1alpha1::PortFecType fec_type() const;
  void set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortFecType _internal_fec_type() const;
  void _internal_set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.PortLinkStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int oper_state_;
  int port_speed_;
  bool autoneg_en_;
  int32_t lanes_count_;
  int fec_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// -------------------------------------------------------------------

class PortXcvrStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.PortXcvrStatus) */ {
 public:
  inline PortXcvrStatus() : PortXcvrStatus(nullptr) {}
  ~PortXcvrStatus() override;
  explicit constexpr PortXcvrStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortXcvrStatus(const PortXcvrStatus& from);
  PortXcvrStatus(PortXcvrStatus&& from) noexcept
    : PortXcvrStatus() {
    *this = ::std::move(from);
  }

  inline PortXcvrStatus& operator=(const PortXcvrStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortXcvrStatus& operator=(PortXcvrStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortXcvrStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortXcvrStatus* internal_default_instance() {
    return reinterpret_cast<const PortXcvrStatus*>(
               &_PortXcvrStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PortXcvrStatus& a, PortXcvrStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PortXcvrStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortXcvrStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortXcvrStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortXcvrStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortXcvrStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortXcvrStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortXcvrStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.PortXcvrStatus";
  }
  protected:
  explicit PortXcvrStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXcvrSpromFieldNumber = 5,
    kVendornameFieldNumber = 6,
    kVendorOuiFieldNumber = 7,
    kSerialNumberFieldNumber = 9,
    kPartNumberFieldNumber = 10,
    kRevisionFieldNumber = 11,
    kPortFieldNumber = 1,
    kStateFieldNumber = 2,
    kPidFieldNumber = 3,
    kMediaTypeFieldNumber = 4,
    kEncodingTypeFieldNumber = 8,
    kTemperatureFieldNumber = 12,
    kWarnTemperatureFieldNumber = 13,
    kAlarmTemperatureFieldNumber = 14,
  };
  // bytes xcvr_sprom = 5;
  void clear_xcvr_sprom();
  const std::string& xcvr_sprom() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xcvr_sprom(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xcvr_sprom();
  PROTOBUF_NODISCARD std::string* release_xcvr_sprom();
  void set_allocated_xcvr_sprom(std::string* xcvr_sprom);
  private:
  const std::string& _internal_xcvr_sprom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xcvr_sprom(const std::string& value);
  std::string* _internal_mutable_xcvr_sprom();
  public:

  // string vendorname = 6;
  void clear_vendorname();
  const std::string& vendorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendorname();
  PROTOBUF_NODISCARD std::string* release_vendorname();
  void set_allocated_vendorname(std::string* vendorname);
  private:
  const std::string& _internal_vendorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendorname(const std::string& value);
  std::string* _internal_mutable_vendorname();
  public:

  // string vendor_oui = 7;
  void clear_vendor_oui();
  const std::string& vendor_oui() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_oui(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_oui();
  PROTOBUF_NODISCARD std::string* release_vendor_oui();
  void set_allocated_vendor_oui(std::string* vendor_oui);
  private:
  const std::string& _internal_vendor_oui() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_oui(const std::string& value);
  std::string* _internal_mutable_vendor_oui();
  public:

  // string serial_number = 9;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string part_number = 10;
  void clear_part_number();
  const std::string& part_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_part_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_part_number();
  PROTOBUF_NODISCARD std::string* release_part_number();
  void set_allocated_part_number(std::string* part_number);
  private:
  const std::string& _internal_part_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_part_number(const std::string& value);
  std::string* _internal_mutable_part_number();
  public:

  // string revision = 11;
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  PROTOBUF_NODISCARD std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // int32 port = 1;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortXcvrState state = 2;
  void clear_state();
  ::opi_api::network::cloud::v1alpha1::PortXcvrState state() const;
  void set_state(::opi_api::network::cloud::v1alpha1::PortXcvrState value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortXcvrState _internal_state() const;
  void _internal_set_state(::opi_api::network::cloud::v1alpha1::PortXcvrState value);
  public:

  // .opi_api.network.cloud.v1alpha1.PortXcvrPid pid = 3;
  void clear_pid();
  ::opi_api::network::cloud::v1alpha1::PortXcvrPid pid() const;
  void set_pid(::opi_api::network::cloud::v1alpha1::PortXcvrPid value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortXcvrPid _internal_pid() const;
  void _internal_set_pid(::opi_api::network::cloud::v1alpha1::PortXcvrPid value);
  public:

  // .opi_api.network.cloud.v1alpha1.MediaType media_type = 4;
  void clear_media_type();
  ::opi_api::network::cloud::v1alpha1::MediaType media_type() const;
  void set_media_type(::opi_api::network::cloud::v1alpha1::MediaType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MediaType _internal_media_type() const;
  void _internal_set_media_type(::opi_api::network::cloud::v1alpha1::MediaType value);
  public:

  // int32 encoding_type = 8;
  void clear_encoding_type();
  int32_t encoding_type() const;
  void set_encoding_type(int32_t value);
  private:
  int32_t _internal_encoding_type() const;
  void _internal_set_encoding_type(int32_t value);
  public:

  // int32 temperature = 12;
  void clear_temperature();
  int32_t temperature() const;
  void set_temperature(int32_t value);
  private:
  int32_t _internal_temperature() const;
  void _internal_set_temperature(int32_t value);
  public:

  // int32 warn_temperature = 13;
  void clear_warn_temperature();
  int32_t warn_temperature() const;
  void set_warn_temperature(int32_t value);
  private:
  int32_t _internal_warn_temperature() const;
  void _internal_set_warn_temperature(int32_t value);
  public:

  // int32 alarm_temperature = 14;
  void clear_alarm_temperature();
  int32_t alarm_temperature() const;
  void set_alarm_temperature(int32_t value);
  private:
  int32_t _internal_alarm_temperature() const;
  void _internal_set_alarm_temperature(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.PortXcvrStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xcvr_sprom_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendorname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_oui_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr part_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  int32_t port_;
  int state_;
  int pid_;
  int media_type_;
  int32_t encoding_type_;
  int32_t temperature_;
  int32_t warn_temperature_;
  int32_t alarm_temperature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// -------------------------------------------------------------------

class PortLinkFSMRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord) */ {
 public:
  inline PortLinkFSMRecord() : PortLinkFSMRecord(nullptr) {}
  ~PortLinkFSMRecord() override;
  explicit constexpr PortLinkFSMRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortLinkFSMRecord(const PortLinkFSMRecord& from);
  PortLinkFSMRecord(PortLinkFSMRecord&& from) noexcept
    : PortLinkFSMRecord() {
    *this = ::std::move(from);
  }

  inline PortLinkFSMRecord& operator=(const PortLinkFSMRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortLinkFSMRecord& operator=(PortLinkFSMRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortLinkFSMRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortLinkFSMRecord* internal_default_instance() {
    return reinterpret_cast<const PortLinkFSMRecord*>(
               &_PortLinkFSMRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PortLinkFSMRecord& a, PortLinkFSMRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(PortLinkFSMRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortLinkFSMRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortLinkFSMRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortLinkFSMRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortLinkFSMRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortLinkFSMRecord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortLinkFSMRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.PortLinkFSMRecord";
  }
  protected:
  explicit PortLinkFSMRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 3,
    kStateTimeFieldNumber = 2,
    kFsmStateFieldNumber = 1,
  };
  // string duration = 3;
  void clear_duration();
  const std::string& duration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_duration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_duration();
  PROTOBUF_NODISCARD std::string* release_duration();
  void set_allocated_duration(std::string* duration);
  private:
  const std::string& _internal_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_duration(const std::string& value);
  std::string* _internal_mutable_duration();
  public:

  // .google.protobuf.Timestamp state_time = 2;
  bool has_state_time() const;
  private:
  bool _internal_has_state_time() const;
  public:
  void clear_state_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& state_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_state_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_state_time();
  void set_allocated_state_time(::PROTOBUF_NAMESPACE_ID::Timestamp* state_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_state_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_state_time();
  public:
  void unsafe_arena_set_allocated_state_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* state_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_state_time();

  // .opi_api.network.cloud.v1alpha1.PortLinkFSM fsm_state = 1;
  void clear_fsm_state();
  ::opi_api::network::cloud::v1alpha1::PortLinkFSM fsm_state() const;
  void set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value);
  private:
  ::opi_api::network::cloud::v1alpha1::PortLinkFSM _internal_fsm_state() const;
  void _internal_set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr duration_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* state_time_;
  int fsm_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_port_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Port

// .opi_api.network.cloud.v1alpha1.PortSpec spec = 1;
inline bool Port::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Port::has_spec() const {
  return _internal_has_spec();
}
inline void Port::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::PortSpec& Port::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::PortSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::PortSpec&>(
      ::opi_api::network::cloud::v1alpha1::_PortSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::PortSpec& Port::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Port.spec)
  return _internal_spec();
}
inline void Port::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::PortSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Port.spec)
}
inline ::opi_api::network::cloud::v1alpha1::PortSpec* Port::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::PortSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortSpec* Port::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Port.spec)
  
  ::opi_api::network::cloud::v1alpha1::PortSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortSpec* Port::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::network::cloud::v1alpha1::PortSpec* Port::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::PortSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Port.spec)
  return _msg;
}
inline void Port::set_allocated_spec(::opi_api::network::cloud::v1alpha1::PortSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::PortSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Port.spec)
}

// .opi_api.network.cloud.v1alpha1.PortStatus status = 2;
inline bool Port::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Port::has_status() const {
  return _internal_has_status();
}
inline void Port::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::PortStatus& Port::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::PortStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::PortStatus&>(
      ::opi_api::network::cloud::v1alpha1::_PortStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::PortStatus& Port::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Port.status)
  return _internal_status();
}
inline void Port::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::PortStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Port.status)
}
inline ::opi_api::network::cloud::v1alpha1::PortStatus* Port::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::PortStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortStatus* Port::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Port.status)
  
  ::opi_api::network::cloud::v1alpha1::PortStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortStatus* Port::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::cloud::v1alpha1::PortStatus* Port::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::PortStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Port.status)
  return _msg;
}
inline void Port::set_allocated_status(::opi_api::network::cloud::v1alpha1::PortStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::PortStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Port.status)
}

// -------------------------------------------------------------------

// PortSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool PortSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool PortSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& PortSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& PortSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.id)
  return _internal_id();
}
inline void PortSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.PortSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* PortSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* PortSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* PortSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* PortSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortSpec.id)
  return _msg;
}
inline void PortSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortSpec.id)
}

// int32 port_number = 2;
inline void PortSpec::clear_port_number() {
  port_number_ = 0;
}
inline int32_t PortSpec::_internal_port_number() const {
  return port_number_;
}
inline int32_t PortSpec::port_number() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.port_number)
  return _internal_port_number();
}
inline void PortSpec::_internal_set_port_number(int32_t value) {
  
  port_number_ = value;
}
inline void PortSpec::set_port_number(int32_t value) {
  _internal_set_port_number(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.port_number)
}

// .opi_api.network.cloud.v1alpha1.PortAdminState admin_state = 3;
inline void PortSpec::clear_admin_state() {
  admin_state_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortAdminState PortSpec::_internal_admin_state() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortAdminState >(admin_state_);
}
inline ::opi_api::network::cloud::v1alpha1::PortAdminState PortSpec::admin_state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.admin_state)
  return _internal_admin_state();
}
inline void PortSpec::_internal_set_admin_state(::opi_api::network::cloud::v1alpha1::PortAdminState value) {
  
  admin_state_ = value;
}
inline void PortSpec::set_admin_state(::opi_api::network::cloud::v1alpha1::PortAdminState value) {
  _internal_set_admin_state(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.admin_state)
}

// .opi_api.network.cloud.v1alpha1.PortType type = 4;
inline void PortSpec::clear_type() {
  type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortType PortSpec::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortType >(type_);
}
inline ::opi_api::network::cloud::v1alpha1::PortType PortSpec::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.type)
  return _internal_type();
}
inline void PortSpec::_internal_set_type(::opi_api::network::cloud::v1alpha1::PortType value) {
  
  type_ = value;
}
inline void PortSpec::set_type(::opi_api::network::cloud::v1alpha1::PortType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.type)
}

// .opi_api.network.cloud.v1alpha1.PortSpeed speed = 5;
inline void PortSpec::clear_speed() {
  speed_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortSpeed PortSpec::_internal_speed() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortSpeed >(speed_);
}
inline ::opi_api::network::cloud::v1alpha1::PortSpeed PortSpec::speed() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.speed)
  return _internal_speed();
}
inline void PortSpec::_internal_set_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value) {
  
  speed_ = value;
}
inline void PortSpec::set_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.speed)
}

// .opi_api.network.cloud.v1alpha1.PortFecType fec_type = 6;
inline void PortSpec::clear_fec_type() {
  fec_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortFecType PortSpec::_internal_fec_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortFecType >(fec_type_);
}
inline ::opi_api::network::cloud::v1alpha1::PortFecType PortSpec::fec_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.fec_type)
  return _internal_fec_type();
}
inline void PortSpec::_internal_set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value) {
  
  fec_type_ = value;
}
inline void PortSpec::set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value) {
  _internal_set_fec_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.fec_type)
}

// bool autoneg_enable = 7;
inline void PortSpec::clear_autoneg_enable() {
  autoneg_enable_ = false;
}
inline bool PortSpec::_internal_autoneg_enable() const {
  return autoneg_enable_;
}
inline bool PortSpec::autoneg_enable() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.autoneg_enable)
  return _internal_autoneg_enable();
}
inline void PortSpec::_internal_set_autoneg_enable(bool value) {
  
  autoneg_enable_ = value;
}
inline void PortSpec::set_autoneg_enable(bool value) {
  _internal_set_autoneg_enable(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.autoneg_enable)
}

// int32 debounce_timeout = 8;
inline void PortSpec::clear_debounce_timeout() {
  debounce_timeout_ = 0;
}
inline int32_t PortSpec::_internal_debounce_timeout() const {
  return debounce_timeout_;
}
inline int32_t PortSpec::debounce_timeout() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.debounce_timeout)
  return _internal_debounce_timeout();
}
inline void PortSpec::_internal_set_debounce_timeout(int32_t value) {
  
  debounce_timeout_ = value;
}
inline void PortSpec::set_debounce_timeout(int32_t value) {
  _internal_set_debounce_timeout(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.debounce_timeout)
}

// int32 mtu = 9;
inline void PortSpec::clear_mtu() {
  mtu_ = 0;
}
inline int32_t PortSpec::_internal_mtu() const {
  return mtu_;
}
inline int32_t PortSpec::mtu() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.mtu)
  return _internal_mtu();
}
inline void PortSpec::_internal_set_mtu(int32_t value) {
  
  mtu_ = value;
}
inline void PortSpec::set_mtu(int32_t value) {
  _internal_set_mtu(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.mtu)
}

// .opi_api.network.cloud.v1alpha1.PortPauseType pause_type = 10;
inline void PortSpec::clear_pause_type() {
  pause_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortPauseType PortSpec::_internal_pause_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortPauseType >(pause_type_);
}
inline ::opi_api::network::cloud::v1alpha1::PortPauseType PortSpec::pause_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.pause_type)
  return _internal_pause_type();
}
inline void PortSpec::_internal_set_pause_type(::opi_api::network::cloud::v1alpha1::PortPauseType value) {
  
  pause_type_ = value;
}
inline void PortSpec::set_pause_type(::opi_api::network::cloud::v1alpha1::PortPauseType value) {
  _internal_set_pause_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.pause_type)
}

// bool tx_pause_en = 11;
inline void PortSpec::clear_tx_pause_en() {
  tx_pause_en_ = false;
}
inline bool PortSpec::_internal_tx_pause_en() const {
  return tx_pause_en_;
}
inline bool PortSpec::tx_pause_en() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.tx_pause_en)
  return _internal_tx_pause_en();
}
inline void PortSpec::_internal_set_tx_pause_en(bool value) {
  
  tx_pause_en_ = value;
}
inline void PortSpec::set_tx_pause_en(bool value) {
  _internal_set_tx_pause_en(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.tx_pause_en)
}

// bool rx_pause_en = 12;
inline void PortSpec::clear_rx_pause_en() {
  rx_pause_en_ = false;
}
inline bool PortSpec::_internal_rx_pause_en() const {
  return rx_pause_en_;
}
inline bool PortSpec::rx_pause_en() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.rx_pause_en)
  return _internal_rx_pause_en();
}
inline void PortSpec::_internal_set_rx_pause_en(bool value) {
  
  rx_pause_en_ = value;
}
inline void PortSpec::set_rx_pause_en(bool value) {
  _internal_set_rx_pause_en(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.rx_pause_en)
}

// .opi_api.network.cloud.v1alpha1.PortLoopBackMode loopback_mode = 13;
inline void PortSpec::clear_loopback_mode() {
  loopback_mode_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortLoopBackMode PortSpec::_internal_loopback_mode() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortLoopBackMode >(loopback_mode_);
}
inline ::opi_api::network::cloud::v1alpha1::PortLoopBackMode PortSpec::loopback_mode() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.loopback_mode)
  return _internal_loopback_mode();
}
inline void PortSpec::_internal_set_loopback_mode(::opi_api::network::cloud::v1alpha1::PortLoopBackMode value) {
  
  loopback_mode_ = value;
}
inline void PortSpec::set_loopback_mode(::opi_api::network::cloud::v1alpha1::PortLoopBackMode value) {
  _internal_set_loopback_mode(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.loopback_mode)
}

// int32 lanes_count = 14;
inline void PortSpec::clear_lanes_count() {
  lanes_count_ = 0;
}
inline int32_t PortSpec::_internal_lanes_count() const {
  return lanes_count_;
}
inline int32_t PortSpec::lanes_count() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortSpec.lanes_count)
  return _internal_lanes_count();
}
inline void PortSpec::_internal_set_lanes_count(int32_t value) {
  
  lanes_count_ = value;
}
inline void PortSpec::set_lanes_count(int32_t value) {
  _internal_set_lanes_count(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortSpec.lanes_count)
}

// -------------------------------------------------------------------

// PortStatus

// uint32 if_index = 1;
inline void PortStatus::clear_if_index() {
  if_index_ = 0u;
}
inline uint32_t PortStatus::_internal_if_index() const {
  return if_index_;
}
inline uint32_t PortStatus::if_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.if_index)
  return _internal_if_index();
}
inline void PortStatus::_internal_set_if_index(uint32_t value) {
  
  if_index_ = value;
}
inline void PortStatus::set_if_index(uint32_t value) {
  _internal_set_if_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortStatus.if_index)
}

// .opi_api.network.cloud.v1alpha1.PortLinkStatus link_status = 2;
inline bool PortStatus::_internal_has_link_status() const {
  return this != internal_default_instance() && link_status_ != nullptr;
}
inline bool PortStatus::has_link_status() const {
  return _internal_has_link_status();
}
inline void PortStatus::clear_link_status() {
  if (GetArenaForAllocation() == nullptr && link_status_ != nullptr) {
    delete link_status_;
  }
  link_status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::PortLinkStatus& PortStatus::_internal_link_status() const {
  const ::opi_api::network::cloud::v1alpha1::PortLinkStatus* p = link_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::PortLinkStatus&>(
      ::opi_api::network::cloud::v1alpha1::_PortLinkStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::PortLinkStatus& PortStatus::link_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.link_status)
  return _internal_link_status();
}
inline void PortStatus::unsafe_arena_set_allocated_link_status(
    ::opi_api::network::cloud::v1alpha1::PortLinkStatus* link_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_status_);
  }
  link_status_ = link_status;
  if (link_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.PortStatus.link_status)
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkStatus* PortStatus::release_link_status() {
  
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* temp = link_status_;
  link_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkStatus* PortStatus::unsafe_arena_release_link_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortStatus.link_status)
  
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* temp = link_status_;
  link_status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkStatus* PortStatus::_internal_mutable_link_status() {
  
  if (link_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortLinkStatus>(GetArenaForAllocation());
    link_status_ = p;
  }
  return link_status_;
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkStatus* PortStatus::mutable_link_status() {
  ::opi_api::network::cloud::v1alpha1::PortLinkStatus* _msg = _internal_mutable_link_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortStatus.link_status)
  return _msg;
}
inline void PortStatus::set_allocated_link_status(::opi_api::network::cloud::v1alpha1::PortLinkStatus* link_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete link_status_;
  }
  if (link_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::PortLinkStatus>::GetOwningArena(link_status);
    if (message_arena != submessage_arena) {
      link_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_status, submessage_arena);
    }
    
  } else {
    
  }
  link_status_ = link_status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortStatus.link_status)
}

// .opi_api.network.cloud.v1alpha1.PortXcvrStatus xcvr_status = 3;
inline bool PortStatus::_internal_has_xcvr_status() const {
  return this != internal_default_instance() && xcvr_status_ != nullptr;
}
inline bool PortStatus::has_xcvr_status() const {
  return _internal_has_xcvr_status();
}
inline void PortStatus::clear_xcvr_status() {
  if (GetArenaForAllocation() == nullptr && xcvr_status_ != nullptr) {
    delete xcvr_status_;
  }
  xcvr_status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus& PortStatus::_internal_xcvr_status() const {
  const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* p = xcvr_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus&>(
      ::opi_api::network::cloud::v1alpha1::_PortXcvrStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::PortXcvrStatus& PortStatus::xcvr_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.xcvr_status)
  return _internal_xcvr_status();
}
inline void PortStatus::unsafe_arena_set_allocated_xcvr_status(
    ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* xcvr_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xcvr_status_);
  }
  xcvr_status_ = xcvr_status;
  if (xcvr_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.PortStatus.xcvr_status)
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* PortStatus::release_xcvr_status() {
  
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* temp = xcvr_status_;
  xcvr_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* PortStatus::unsafe_arena_release_xcvr_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortStatus.xcvr_status)
  
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* temp = xcvr_status_;
  xcvr_status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* PortStatus::_internal_mutable_xcvr_status() {
  
  if (xcvr_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::PortXcvrStatus>(GetArenaForAllocation());
    xcvr_status_ = p;
  }
  return xcvr_status_;
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* PortStatus::mutable_xcvr_status() {
  ::opi_api::network::cloud::v1alpha1::PortXcvrStatus* _msg = _internal_mutable_xcvr_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortStatus.xcvr_status)
  return _msg;
}
inline void PortStatus::set_allocated_xcvr_status(::opi_api::network::cloud::v1alpha1::PortXcvrStatus* xcvr_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete xcvr_status_;
  }
  if (xcvr_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::PortXcvrStatus>::GetOwningArena(xcvr_status);
    if (message_arena != submessage_arena) {
      xcvr_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xcvr_status, submessage_arena);
    }
    
  } else {
    
  }
  xcvr_status_ = xcvr_status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortStatus.xcvr_status)
}

// .opi_api.network.cloud.v1alpha1.PortLinkFSM fsm_state = 4;
inline void PortStatus::clear_fsm_state() {
  fsm_state_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSM PortStatus::_internal_fsm_state() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortLinkFSM >(fsm_state_);
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSM PortStatus::fsm_state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.fsm_state)
  return _internal_fsm_state();
}
inline void PortStatus::_internal_set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value) {
  
  fsm_state_ = value;
}
inline void PortStatus::set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value) {
  _internal_set_fsm_state(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortStatus.fsm_state)
}

// int32 mac_id = 5;
inline void PortStatus::clear_mac_id() {
  mac_id_ = 0;
}
inline int32_t PortStatus::_internal_mac_id() const {
  return mac_id_;
}
inline int32_t PortStatus::mac_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.mac_id)
  return _internal_mac_id();
}
inline void PortStatus::_internal_set_mac_id(int32_t value) {
  
  mac_id_ = value;
}
inline void PortStatus::set_mac_id(int32_t value) {
  _internal_set_mac_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortStatus.mac_id)
}

// int32 mac_ch = 6;
inline void PortStatus::clear_mac_ch() {
  mac_ch_ = 0;
}
inline int32_t PortStatus::_internal_mac_ch() const {
  return mac_ch_;
}
inline int32_t PortStatus::mac_ch() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.mac_ch)
  return _internal_mac_ch();
}
inline void PortStatus::_internal_set_mac_ch(int32_t value) {
  
  mac_ch_ = value;
}
inline void PortStatus::set_mac_ch(int32_t value) {
  _internal_set_mac_ch(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortStatus.mac_ch)
}

// repeated .opi_api.network.cloud.v1alpha1.PortLinkFSMRecord fsm_record = 7;
inline int PortStatus::_internal_fsm_record_size() const {
  return fsm_record_.size();
}
inline int PortStatus::fsm_record_size() const {
  return _internal_fsm_record_size();
}
inline void PortStatus::clear_fsm_record() {
  fsm_record_.Clear();
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* PortStatus::mutable_fsm_record(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortStatus.fsm_record)
  return fsm_record_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord >*
PortStatus::mutable_fsm_record() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.PortStatus.fsm_record)
  return &fsm_record_;
}
inline const ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord& PortStatus::_internal_fsm_record(int index) const {
  return fsm_record_.Get(index);
}
inline const ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord& PortStatus::fsm_record(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortStatus.fsm_record)
  return _internal_fsm_record(index);
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* PortStatus::_internal_add_fsm_record() {
  return fsm_record_.Add();
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* PortStatus::add_fsm_record() {
  ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord* _add = _internal_add_fsm_record();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.PortStatus.fsm_record)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::PortLinkFSMRecord >&
PortStatus::fsm_record() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.PortStatus.fsm_record)
  return fsm_record_;
}

// -------------------------------------------------------------------

// PortLinkStatus

// .opi_api.network.cloud.v1alpha1.PortOperState oper_state = 1;
inline void PortLinkStatus::clear_oper_state() {
  oper_state_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortOperState PortLinkStatus::_internal_oper_state() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortOperState >(oper_state_);
}
inline ::opi_api::network::cloud::v1alpha1::PortOperState PortLinkStatus::oper_state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkStatus.oper_state)
  return _internal_oper_state();
}
inline void PortLinkStatus::_internal_set_oper_state(::opi_api::network::cloud::v1alpha1::PortOperState value) {
  
  oper_state_ = value;
}
inline void PortLinkStatus::set_oper_state(::opi_api::network::cloud::v1alpha1::PortOperState value) {
  _internal_set_oper_state(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkStatus.oper_state)
}

// .opi_api.network.cloud.v1alpha1.PortSpeed port_speed = 2;
inline void PortLinkStatus::clear_port_speed() {
  port_speed_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortSpeed PortLinkStatus::_internal_port_speed() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortSpeed >(port_speed_);
}
inline ::opi_api::network::cloud::v1alpha1::PortSpeed PortLinkStatus::port_speed() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkStatus.port_speed)
  return _internal_port_speed();
}
inline void PortLinkStatus::_internal_set_port_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value) {
  
  port_speed_ = value;
}
inline void PortLinkStatus::set_port_speed(::opi_api::network::cloud::v1alpha1::PortSpeed value) {
  _internal_set_port_speed(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkStatus.port_speed)
}

// bool autoneg_en = 3;
inline void PortLinkStatus::clear_autoneg_en() {
  autoneg_en_ = false;
}
inline bool PortLinkStatus::_internal_autoneg_en() const {
  return autoneg_en_;
}
inline bool PortLinkStatus::autoneg_en() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkStatus.autoneg_en)
  return _internal_autoneg_en();
}
inline void PortLinkStatus::_internal_set_autoneg_en(bool value) {
  
  autoneg_en_ = value;
}
inline void PortLinkStatus::set_autoneg_en(bool value) {
  _internal_set_autoneg_en(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkStatus.autoneg_en)
}

// int32 lanes_count = 4;
inline void PortLinkStatus::clear_lanes_count() {
  lanes_count_ = 0;
}
inline int32_t PortLinkStatus::_internal_lanes_count() const {
  return lanes_count_;
}
inline int32_t PortLinkStatus::lanes_count() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkStatus.lanes_count)
  return _internal_lanes_count();
}
inline void PortLinkStatus::_internal_set_lanes_count(int32_t value) {
  
  lanes_count_ = value;
}
inline void PortLinkStatus::set_lanes_count(int32_t value) {
  _internal_set_lanes_count(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkStatus.lanes_count)
}

// .opi_api.network.cloud.v1alpha1.PortFecType fec_type = 5;
inline void PortLinkStatus::clear_fec_type() {
  fec_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortFecType PortLinkStatus::_internal_fec_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortFecType >(fec_type_);
}
inline ::opi_api::network::cloud::v1alpha1::PortFecType PortLinkStatus::fec_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkStatus.fec_type)
  return _internal_fec_type();
}
inline void PortLinkStatus::_internal_set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value) {
  
  fec_type_ = value;
}
inline void PortLinkStatus::set_fec_type(::opi_api::network::cloud::v1alpha1::PortFecType value) {
  _internal_set_fec_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkStatus.fec_type)
}

// -------------------------------------------------------------------

// PortXcvrStatus

// int32 port = 1;
inline void PortXcvrStatus::clear_port() {
  port_ = 0;
}
inline int32_t PortXcvrStatus::_internal_port() const {
  return port_;
}
inline int32_t PortXcvrStatus::port() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.port)
  return _internal_port();
}
inline void PortXcvrStatus::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void PortXcvrStatus::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.port)
}

// .opi_api.network.cloud.v1alpha1.PortXcvrState state = 2;
inline void PortXcvrStatus::clear_state() {
  state_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrState PortXcvrStatus::_internal_state() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortXcvrState >(state_);
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrState PortXcvrStatus::state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.state)
  return _internal_state();
}
inline void PortXcvrStatus::_internal_set_state(::opi_api::network::cloud::v1alpha1::PortXcvrState value) {
  
  state_ = value;
}
inline void PortXcvrStatus::set_state(::opi_api::network::cloud::v1alpha1::PortXcvrState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.state)
}

// .opi_api.network.cloud.v1alpha1.PortXcvrPid pid = 3;
inline void PortXcvrStatus::clear_pid() {
  pid_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrPid PortXcvrStatus::_internal_pid() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortXcvrPid >(pid_);
}
inline ::opi_api::network::cloud::v1alpha1::PortXcvrPid PortXcvrStatus::pid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.pid)
  return _internal_pid();
}
inline void PortXcvrStatus::_internal_set_pid(::opi_api::network::cloud::v1alpha1::PortXcvrPid value) {
  
  pid_ = value;
}
inline void PortXcvrStatus::set_pid(::opi_api::network::cloud::v1alpha1::PortXcvrPid value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.pid)
}

// .opi_api.network.cloud.v1alpha1.MediaType media_type = 4;
inline void PortXcvrStatus::clear_media_type() {
  media_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MediaType PortXcvrStatus::_internal_media_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MediaType >(media_type_);
}
inline ::opi_api::network::cloud::v1alpha1::MediaType PortXcvrStatus::media_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.media_type)
  return _internal_media_type();
}
inline void PortXcvrStatus::_internal_set_media_type(::opi_api::network::cloud::v1alpha1::MediaType value) {
  
  media_type_ = value;
}
inline void PortXcvrStatus::set_media_type(::opi_api::network::cloud::v1alpha1::MediaType value) {
  _internal_set_media_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.media_type)
}

// bytes xcvr_sprom = 5;
inline void PortXcvrStatus::clear_xcvr_sprom() {
  xcvr_sprom_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::xcvr_sprom() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.xcvr_sprom)
  return _internal_xcvr_sprom();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_xcvr_sprom(ArgT0&& arg0, ArgT... args) {
 
 xcvr_sprom_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.xcvr_sprom)
}
inline std::string* PortXcvrStatus::mutable_xcvr_sprom() {
  std::string* _s = _internal_mutable_xcvr_sprom();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.xcvr_sprom)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_xcvr_sprom() const {
  return xcvr_sprom_.Get();
}
inline void PortXcvrStatus::_internal_set_xcvr_sprom(const std::string& value) {
  
  xcvr_sprom_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_xcvr_sprom() {
  
  return xcvr_sprom_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_xcvr_sprom() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.xcvr_sprom)
  return xcvr_sprom_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_xcvr_sprom(std::string* xcvr_sprom) {
  if (xcvr_sprom != nullptr) {
    
  } else {
    
  }
  xcvr_sprom_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xcvr_sprom,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (xcvr_sprom_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    xcvr_sprom_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.xcvr_sprom)
}

// string vendorname = 6;
inline void PortXcvrStatus::clear_vendorname() {
  vendorname_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::vendorname() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendorname)
  return _internal_vendorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_vendorname(ArgT0&& arg0, ArgT... args) {
 
 vendorname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendorname)
}
inline std::string* PortXcvrStatus::mutable_vendorname() {
  std::string* _s = _internal_mutable_vendorname();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendorname)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_vendorname() const {
  return vendorname_.Get();
}
inline void PortXcvrStatus::_internal_set_vendorname(const std::string& value) {
  
  vendorname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_vendorname() {
  
  return vendorname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_vendorname() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendorname)
  return vendorname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_vendorname(std::string* vendorname) {
  if (vendorname != nullptr) {
    
  } else {
    
  }
  vendorname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendorname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendorname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vendorname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendorname)
}

// string vendor_oui = 7;
inline void PortXcvrStatus::clear_vendor_oui() {
  vendor_oui_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::vendor_oui() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendor_oui)
  return _internal_vendor_oui();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_vendor_oui(ArgT0&& arg0, ArgT... args) {
 
 vendor_oui_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendor_oui)
}
inline std::string* PortXcvrStatus::mutable_vendor_oui() {
  std::string* _s = _internal_mutable_vendor_oui();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendor_oui)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_vendor_oui() const {
  return vendor_oui_.Get();
}
inline void PortXcvrStatus::_internal_set_vendor_oui(const std::string& value) {
  
  vendor_oui_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_vendor_oui() {
  
  return vendor_oui_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_vendor_oui() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendor_oui)
  return vendor_oui_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_vendor_oui(std::string* vendor_oui) {
  if (vendor_oui != nullptr) {
    
  } else {
    
  }
  vendor_oui_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendor_oui,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_oui_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vendor_oui_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.vendor_oui)
}

// int32 encoding_type = 8;
inline void PortXcvrStatus::clear_encoding_type() {
  encoding_type_ = 0;
}
inline int32_t PortXcvrStatus::_internal_encoding_type() const {
  return encoding_type_;
}
inline int32_t PortXcvrStatus::encoding_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.encoding_type)
  return _internal_encoding_type();
}
inline void PortXcvrStatus::_internal_set_encoding_type(int32_t value) {
  
  encoding_type_ = value;
}
inline void PortXcvrStatus::set_encoding_type(int32_t value) {
  _internal_set_encoding_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.encoding_type)
}

// string serial_number = 9;
inline void PortXcvrStatus::clear_serial_number() {
  serial_number_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::serial_number() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.serial_number)
}
inline std::string* PortXcvrStatus::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.serial_number)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void PortXcvrStatus::_internal_set_serial_number(const std::string& value) {
  
  serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_serial_number() {
  
  return serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_serial_number() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.serial_number)
  return serial_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.serial_number)
}

// string part_number = 10;
inline void PortXcvrStatus::clear_part_number() {
  part_number_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::part_number() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.part_number)
  return _internal_part_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_part_number(ArgT0&& arg0, ArgT... args) {
 
 part_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.part_number)
}
inline std::string* PortXcvrStatus::mutable_part_number() {
  std::string* _s = _internal_mutable_part_number();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.part_number)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_part_number() const {
  return part_number_.Get();
}
inline void PortXcvrStatus::_internal_set_part_number(const std::string& value) {
  
  part_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_part_number() {
  
  return part_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_part_number() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.part_number)
  return part_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_part_number(std::string* part_number) {
  if (part_number != nullptr) {
    
  } else {
    
  }
  part_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), part_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (part_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    part_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.part_number)
}

// string revision = 11;
inline void PortXcvrStatus::clear_revision() {
  revision_.ClearToEmpty();
}
inline const std::string& PortXcvrStatus::revision() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortXcvrStatus::set_revision(ArgT0&& arg0, ArgT... args) {
 
 revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.revision)
}
inline std::string* PortXcvrStatus::mutable_revision() {
  std::string* _s = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortXcvrStatus.revision)
  return _s;
}
inline const std::string& PortXcvrStatus::_internal_revision() const {
  return revision_.Get();
}
inline void PortXcvrStatus::_internal_set_revision(const std::string& value) {
  
  revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::_internal_mutable_revision() {
  
  return revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortXcvrStatus::release_revision() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortXcvrStatus.revision)
  return revision_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortXcvrStatus::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    
  } else {
    
  }
  revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), revision,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (revision_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortXcvrStatus.revision)
}

// int32 temperature = 12;
inline void PortXcvrStatus::clear_temperature() {
  temperature_ = 0;
}
inline int32_t PortXcvrStatus::_internal_temperature() const {
  return temperature_;
}
inline int32_t PortXcvrStatus::temperature() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.temperature)
  return _internal_temperature();
}
inline void PortXcvrStatus::_internal_set_temperature(int32_t value) {
  
  temperature_ = value;
}
inline void PortXcvrStatus::set_temperature(int32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.temperature)
}

// int32 warn_temperature = 13;
inline void PortXcvrStatus::clear_warn_temperature() {
  warn_temperature_ = 0;
}
inline int32_t PortXcvrStatus::_internal_warn_temperature() const {
  return warn_temperature_;
}
inline int32_t PortXcvrStatus::warn_temperature() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.warn_temperature)
  return _internal_warn_temperature();
}
inline void PortXcvrStatus::_internal_set_warn_temperature(int32_t value) {
  
  warn_temperature_ = value;
}
inline void PortXcvrStatus::set_warn_temperature(int32_t value) {
  _internal_set_warn_temperature(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.warn_temperature)
}

// int32 alarm_temperature = 14;
inline void PortXcvrStatus::clear_alarm_temperature() {
  alarm_temperature_ = 0;
}
inline int32_t PortXcvrStatus::_internal_alarm_temperature() const {
  return alarm_temperature_;
}
inline int32_t PortXcvrStatus::alarm_temperature() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortXcvrStatus.alarm_temperature)
  return _internal_alarm_temperature();
}
inline void PortXcvrStatus::_internal_set_alarm_temperature(int32_t value) {
  
  alarm_temperature_ = value;
}
inline void PortXcvrStatus::set_alarm_temperature(int32_t value) {
  _internal_set_alarm_temperature(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortXcvrStatus.alarm_temperature)
}

// -------------------------------------------------------------------

// PortLinkFSMRecord

// .opi_api.network.cloud.v1alpha1.PortLinkFSM fsm_state = 1;
inline void PortLinkFSMRecord::clear_fsm_state() {
  fsm_state_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSM PortLinkFSMRecord::_internal_fsm_state() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::PortLinkFSM >(fsm_state_);
}
inline ::opi_api::network::cloud::v1alpha1::PortLinkFSM PortLinkFSMRecord::fsm_state() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.fsm_state)
  return _internal_fsm_state();
}
inline void PortLinkFSMRecord::_internal_set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value) {
  
  fsm_state_ = value;
}
inline void PortLinkFSMRecord::set_fsm_state(::opi_api::network::cloud::v1alpha1::PortLinkFSM value) {
  _internal_set_fsm_state(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.fsm_state)
}

// .google.protobuf.Timestamp state_time = 2;
inline bool PortLinkFSMRecord::_internal_has_state_time() const {
  return this != internal_default_instance() && state_time_ != nullptr;
}
inline bool PortLinkFSMRecord::has_state_time() const {
  return _internal_has_state_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PortLinkFSMRecord::_internal_state_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = state_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PortLinkFSMRecord::state_time() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.state_time)
  return _internal_state_time();
}
inline void PortLinkFSMRecord::unsafe_arena_set_allocated_state_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* state_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_time_);
  }
  state_time_ = state_time;
  if (state_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.state_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PortLinkFSMRecord::release_state_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = state_time_;
  state_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PortLinkFSMRecord::unsafe_arena_release_state_time() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.state_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = state_time_;
  state_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PortLinkFSMRecord::_internal_mutable_state_time() {
  
  if (state_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    state_time_ = p;
  }
  return state_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PortLinkFSMRecord::mutable_state_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_state_time();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.state_time)
  return _msg;
}
inline void PortLinkFSMRecord::set_allocated_state_time(::PROTOBUF_NAMESPACE_ID::Timestamp* state_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_time_);
  }
  if (state_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_time));
    if (message_arena != submessage_arena) {
      state_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_time, submessage_arena);
    }
    
  } else {
    
  }
  state_time_ = state_time;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.state_time)
}

// string duration = 3;
inline void PortLinkFSMRecord::clear_duration() {
  duration_.ClearToEmpty();
}
inline const std::string& PortLinkFSMRecord::duration() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.duration)
  return _internal_duration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortLinkFSMRecord::set_duration(ArgT0&& arg0, ArgT... args) {
 
 duration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.duration)
}
inline std::string* PortLinkFSMRecord::mutable_duration() {
  std::string* _s = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.duration)
  return _s;
}
inline const std::string& PortLinkFSMRecord::_internal_duration() const {
  return duration_.Get();
}
inline void PortLinkFSMRecord::_internal_set_duration(const std::string& value) {
  
  duration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortLinkFSMRecord::_internal_mutable_duration() {
  
  return duration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortLinkFSMRecord::release_duration() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.duration)
  return duration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortLinkFSMRecord::set_allocated_duration(std::string* duration) {
  if (duration != nullptr) {
    
  } else {
    
  }
  duration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), duration,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (duration_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    duration_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.PortLinkFSMRecord.duration)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortAdminState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortAdminState>() {
  return ::opi_api::network::cloud::v1alpha1::PortAdminState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortXcvrState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortXcvrState>() {
  return ::opi_api::network::cloud::v1alpha1::PortXcvrState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortXcvrPid> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortXcvrPid>() {
  return ::opi_api::network::cloud::v1alpha1::PortXcvrPid_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::MediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::MediaType>() {
  return ::opi_api::network::cloud::v1alpha1::MediaType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortOperState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortOperState>() {
  return ::opi_api::network::cloud::v1alpha1::PortOperState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortPauseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortPauseType>() {
  return ::opi_api::network::cloud::v1alpha1::PortPauseType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortLinkFSM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortLinkFSM>() {
  return ::opi_api::network::cloud::v1alpha1::PortLinkFSM_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortLoopBackMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortLoopBackMode>() {
  return ::opi_api::network::cloud::v1alpha1::PortLoopBackMode_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortFecType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortFecType>() {
  return ::opi_api::network::cloud::v1alpha1::PortFecType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortType>() {
  return ::opi_api::network::cloud::v1alpha1::PortType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::PortSpeed> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::PortSpeed>() {
  return ::opi_api::network::cloud::v1alpha1::PortSpeed_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_port_2eproto
