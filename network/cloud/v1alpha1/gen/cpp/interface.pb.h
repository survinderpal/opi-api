// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_interface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "object_key.pb.h"
#include "networktypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_interface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_interface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_interface_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class BGPCommunity;
struct BGPCommunityDefaultTypeInternal;
extern BGPCommunityDefaultTypeInternal _BGPCommunity_default_instance_;
class ControlIfSpec;
struct ControlIfSpecDefaultTypeInternal;
extern ControlIfSpecDefaultTypeInternal _ControlIfSpec_default_instance_;
class HostIfSpec;
struct HostIfSpecDefaultTypeInternal;
extern HostIfSpecDefaultTypeInternal _HostIfSpec_default_instance_;
class HostIfStatus;
struct HostIfStatusDefaultTypeInternal;
extern HostIfStatusDefaultTypeInternal _HostIfStatus_default_instance_;
class Interface;
struct InterfaceDefaultTypeInternal;
extern InterfaceDefaultTypeInternal _Interface_default_instance_;
class InterfaceSpec;
struct InterfaceSpecDefaultTypeInternal;
extern InterfaceSpecDefaultTypeInternal _InterfaceSpec_default_instance_;
class InterfaceStatus;
struct InterfaceStatusDefaultTypeInternal;
extern InterfaceStatusDefaultTypeInternal _InterfaceStatus_default_instance_;
class L3IfSpec;
struct L3IfSpecDefaultTypeInternal;
extern L3IfSpecDefaultTypeInternal _L3IfSpec_default_instance_;
class LoopbackIfSpec;
struct LoopbackIfSpecDefaultTypeInternal;
extern LoopbackIfSpecDefaultTypeInternal _LoopbackIfSpec_default_instance_;
class LoopbackIfStatus;
struct LoopbackIfStatusDefaultTypeInternal;
extern LoopbackIfStatusDefaultTypeInternal _LoopbackIfStatus_default_instance_;
class UplinkIfStatus;
struct UplinkIfStatusDefaultTypeInternal;
extern UplinkIfStatusDefaultTypeInternal _UplinkIfStatus_default_instance_;
class UplinkPCSpec;
struct UplinkPCSpecDefaultTypeInternal;
extern UplinkPCSpecDefaultTypeInternal _UplinkPCSpec_default_instance_;
class UplinkSpec;
struct UplinkSpecDefaultTypeInternal;
extern UplinkSpecDefaultTypeInternal _UplinkSpec_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::BGPCommunity* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::BGPCommunity>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::ControlIfSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::ControlIfSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::HostIfSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::HostIfSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::HostIfStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::HostIfStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::Interface* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::Interface>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::InterfaceSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::InterfaceSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::InterfaceStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::InterfaceStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::L3IfSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::L3IfSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::LoopbackIfSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::LoopbackIfStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::UplinkIfStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::UplinkPCSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::UplinkSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::UplinkSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum IfType : int {
  IF_TYPE_UNSPECIFIED = 0,
  IF_TYPE_UPLINK = 1,
  IF_TYPE_UPLINK_PC = 2,
  IF_TYPE_L3 = 3,
  IF_TYPE_LOOPBACK = 4,
  IF_TYPE_CONTROL = 5,
  IF_TYPE_HOST = 6,
  IfType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IfType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IfType_IsValid(int value);
constexpr IfType IfType_MIN = IF_TYPE_UNSPECIFIED;
constexpr IfType IfType_MAX = IF_TYPE_HOST;
constexpr int IfType_ARRAYSIZE = IfType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IfType_descriptor();
template<typename T>
inline const std::string& IfType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IfType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IfType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IfType_descriptor(), enum_t_value);
}
inline bool IfType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IfType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IfType>(
    IfType_descriptor(), name, value);
}
enum IfStatus : int {
  IF_STATUS_UNSPECIFIED = 0,
  IF_STATUS_UP = 1,
  IF_STATUS_DOWN = 2,
  IfStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IfStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IfStatus_IsValid(int value);
constexpr IfStatus IfStatus_MIN = IF_STATUS_UNSPECIFIED;
constexpr IfStatus IfStatus_MAX = IF_STATUS_DOWN;
constexpr int IfStatus_ARRAYSIZE = IfStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IfStatus_descriptor();
template<typename T>
inline const std::string& IfStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IfStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IfStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IfStatus_descriptor(), enum_t_value);
}
inline bool IfStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IfStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IfStatus>(
    IfStatus_descriptor(), name, value);
}
// ===================================================================

class Interface final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.Interface) */ {
 public:
  inline Interface() : Interface(nullptr) {}
  ~Interface() override;
  explicit constexpr Interface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interface(const Interface& from);
  Interface(Interface&& from) noexcept
    : Interface() {
    *this = ::std::move(from);
  }

  inline Interface& operator=(const Interface& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interface& operator=(Interface&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Interface& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interface* internal_default_instance() {
    return reinterpret_cast<const Interface*>(
               &_Interface_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Interface& a, Interface& b) {
    a.Swap(&b);
  }
  inline void Swap(Interface* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interface* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Interface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Interface>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Interface& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Interface& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interface* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.Interface";
  }
  protected:
  explicit Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.network.cloud.v1alpha1.InterfaceSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::InterfaceSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::InterfaceSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::InterfaceSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::InterfaceSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::InterfaceSpec* spec);
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.InterfaceStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::InterfaceStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::InterfaceStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::InterfaceStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::InterfaceStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::InterfaceStatus* status);
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.Interface)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* spec_;
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InterfaceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.InterfaceSpec) */ {
 public:
  inline InterfaceSpec() : InterfaceSpec(nullptr) {}
  ~InterfaceSpec() override;
  explicit constexpr InterfaceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceSpec(const InterfaceSpec& from);
  InterfaceSpec(InterfaceSpec&& from) noexcept
    : InterfaceSpec() {
    *this = ::std::move(from);
  }

  inline InterfaceSpec& operator=(const InterfaceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceSpec& operator=(InterfaceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceSpec& default_instance() {
    return *internal_default_instance();
  }
  enum IfinfoCase {
    kUplinkSpec = 4,
    kUplinkPcSpec = 5,
    kL3IfSpec = 6,
    kLoopbackIfSpec = 7,
    kControlIfSpec = 8,
    kHostIfSpec = 9,
    IFINFO_NOT_SET = 0,
  };

  static inline const InterfaceSpec* internal_default_instance() {
    return reinterpret_cast<const InterfaceSpec*>(
               &_InterfaceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InterfaceSpec& a, InterfaceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterfaceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.InterfaceSpec";
  }
  protected:
  explicit InterfaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIfidFieldNumber = 2,
    kAdminStatusFieldNumber = 3,
    kUplinkSpecFieldNumber = 4,
    kUplinkPcSpecFieldNumber = 5,
    kL3IfSpecFieldNumber = 6,
    kLoopbackIfSpecFieldNumber = 7,
    kControlIfSpecFieldNumber = 8,
    kHostIfSpecFieldNumber = 9,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // int32 ifid = 2;
  void clear_ifid();
  int32_t ifid() const;
  void set_ifid(int32_t value);
  private:
  int32_t _internal_ifid() const;
  void _internal_set_ifid(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.IfStatus admin_status = 3;
  void clear_admin_status();
  ::opi_api::network::cloud::v1alpha1::IfStatus admin_status() const;
  void set_admin_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  private:
  ::opi_api::network::cloud::v1alpha1::IfStatus _internal_admin_status() const;
  void _internal_set_admin_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  public:

  // .opi_api.network.cloud.v1alpha1.UplinkSpec uplink_spec = 4;
  bool has_uplink_spec() const;
  private:
  bool _internal_has_uplink_spec() const;
  public:
  void clear_uplink_spec();
  const ::opi_api::network::cloud::v1alpha1::UplinkSpec& uplink_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::UplinkSpec* release_uplink_spec();
  ::opi_api::network::cloud::v1alpha1::UplinkSpec* mutable_uplink_spec();
  void set_allocated_uplink_spec(::opi_api::network::cloud::v1alpha1::UplinkSpec* uplink_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::UplinkSpec& _internal_uplink_spec() const;
  ::opi_api::network::cloud::v1alpha1::UplinkSpec* _internal_mutable_uplink_spec();
  public:
  void unsafe_arena_set_allocated_uplink_spec(
      ::opi_api::network::cloud::v1alpha1::UplinkSpec* uplink_spec);
  ::opi_api::network::cloud::v1alpha1::UplinkSpec* unsafe_arena_release_uplink_spec();

  // .opi_api.network.cloud.v1alpha1.UplinkPCSpec uplink_pc_spec = 5;
  bool has_uplink_pc_spec() const;
  private:
  bool _internal_has_uplink_pc_spec() const;
  public:
  void clear_uplink_pc_spec();
  const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec& uplink_pc_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* release_uplink_pc_spec();
  ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* mutable_uplink_pc_spec();
  void set_allocated_uplink_pc_spec(::opi_api::network::cloud::v1alpha1::UplinkPCSpec* uplink_pc_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec& _internal_uplink_pc_spec() const;
  ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* _internal_mutable_uplink_pc_spec();
  public:
  void unsafe_arena_set_allocated_uplink_pc_spec(
      ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* uplink_pc_spec);
  ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* unsafe_arena_release_uplink_pc_spec();

  // .opi_api.network.cloud.v1alpha1.L3IfSpec l3_if_spec = 6;
  bool has_l3_if_spec() const;
  private:
  bool _internal_has_l3_if_spec() const;
  public:
  void clear_l3_if_spec();
  const ::opi_api::network::cloud::v1alpha1::L3IfSpec& l3_if_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L3IfSpec* release_l3_if_spec();
  ::opi_api::network::cloud::v1alpha1::L3IfSpec* mutable_l3_if_spec();
  void set_allocated_l3_if_spec(::opi_api::network::cloud::v1alpha1::L3IfSpec* l3_if_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::L3IfSpec& _internal_l3_if_spec() const;
  ::opi_api::network::cloud::v1alpha1::L3IfSpec* _internal_mutable_l3_if_spec();
  public:
  void unsafe_arena_set_allocated_l3_if_spec(
      ::opi_api::network::cloud::v1alpha1::L3IfSpec* l3_if_spec);
  ::opi_api::network::cloud::v1alpha1::L3IfSpec* unsafe_arena_release_l3_if_spec();

  // .opi_api.network.cloud.v1alpha1.LoopbackIfSpec loopback_if_spec = 7;
  bool has_loopback_if_spec() const;
  private:
  bool _internal_has_loopback_if_spec() const;
  public:
  void clear_loopback_if_spec();
  const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec& loopback_if_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* release_loopback_if_spec();
  ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* mutable_loopback_if_spec();
  void set_allocated_loopback_if_spec(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* loopback_if_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec& _internal_loopback_if_spec() const;
  ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* _internal_mutable_loopback_if_spec();
  public:
  void unsafe_arena_set_allocated_loopback_if_spec(
      ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* loopback_if_spec);
  ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* unsafe_arena_release_loopback_if_spec();

  // .opi_api.network.cloud.v1alpha1.ControlIfSpec control_if_spec = 8;
  bool has_control_if_spec() const;
  private:
  bool _internal_has_control_if_spec() const;
  public:
  void clear_control_if_spec();
  const ::opi_api::network::cloud::v1alpha1::ControlIfSpec& control_if_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::ControlIfSpec* release_control_if_spec();
  ::opi_api::network::cloud::v1alpha1::ControlIfSpec* mutable_control_if_spec();
  void set_allocated_control_if_spec(::opi_api::network::cloud::v1alpha1::ControlIfSpec* control_if_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::ControlIfSpec& _internal_control_if_spec() const;
  ::opi_api::network::cloud::v1alpha1::ControlIfSpec* _internal_mutable_control_if_spec();
  public:
  void unsafe_arena_set_allocated_control_if_spec(
      ::opi_api::network::cloud::v1alpha1::ControlIfSpec* control_if_spec);
  ::opi_api::network::cloud::v1alpha1::ControlIfSpec* unsafe_arena_release_control_if_spec();

  // .opi_api.network.cloud.v1alpha1.HostIfSpec host_if_spec = 9;
  bool has_host_if_spec() const;
  private:
  bool _internal_has_host_if_spec() const;
  public:
  void clear_host_if_spec();
  const ::opi_api::network::cloud::v1alpha1::HostIfSpec& host_if_spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::HostIfSpec* release_host_if_spec();
  ::opi_api::network::cloud::v1alpha1::HostIfSpec* mutable_host_if_spec();
  void set_allocated_host_if_spec(::opi_api::network::cloud::v1alpha1::HostIfSpec* host_if_spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::HostIfSpec& _internal_host_if_spec() const;
  ::opi_api::network::cloud::v1alpha1::HostIfSpec* _internal_mutable_host_if_spec();
  public:
  void unsafe_arena_set_allocated_host_if_spec(
      ::opi_api::network::cloud::v1alpha1::HostIfSpec* host_if_spec);
  ::opi_api::network::cloud::v1alpha1::HostIfSpec* unsafe_arena_release_host_if_spec();

  void clear_ifinfo();
  IfinfoCase ifinfo_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.InterfaceSpec)
 private:
  class _Internal;
  void set_has_uplink_spec();
  void set_has_uplink_pc_spec();
  void set_has_l3_if_spec();
  void set_has_loopback_if_spec();
  void set_has_control_if_spec();
  void set_has_host_if_spec();

  inline bool has_ifinfo() const;
  inline void clear_has_ifinfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  int32_t ifid_;
  int admin_status_;
  union IfinfoUnion {
    constexpr IfinfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::cloud::v1alpha1::UplinkSpec* uplink_spec_;
    ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* uplink_pc_spec_;
    ::opi_api::network::cloud::v1alpha1::L3IfSpec* l3_if_spec_;
    ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* loopback_if_spec_;
    ::opi_api::network::cloud::v1alpha1::ControlIfSpec* control_if_spec_;
    ::opi_api::network::cloud::v1alpha1::HostIfSpec* host_if_spec_;
  } ifinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class UplinkSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.UplinkSpec) */ {
 public:
  inline UplinkSpec() : UplinkSpec(nullptr) {}
  ~UplinkSpec() override;
  explicit constexpr UplinkSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UplinkSpec(const UplinkSpec& from);
  UplinkSpec(UplinkSpec&& from) noexcept
    : UplinkSpec() {
    *this = ::std::move(from);
  }

  inline UplinkSpec& operator=(const UplinkSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline UplinkSpec& operator=(UplinkSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UplinkSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const UplinkSpec* internal_default_instance() {
    return reinterpret_cast<const UplinkSpec*>(
               &_UplinkSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UplinkSpec& a, UplinkSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(UplinkSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UplinkSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UplinkSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UplinkSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UplinkSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UplinkSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UplinkSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.UplinkSpec";
  }
  protected:
  explicit UplinkSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kNativeVlanidFieldNumber = 2,
  };
  // .opi_api.common.v1.ObjectKey port_id = 1;
  bool has_port_id() const;
  private:
  bool _internal_has_port_id() const;
  public:
  void clear_port_id();
  const ::opi_api::common::v1::ObjectKey& port_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_port_id();
  ::opi_api::common::v1::ObjectKey* mutable_port_id();
  void set_allocated_port_id(::opi_api::common::v1::ObjectKey* port_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_port_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_port_id();
  public:
  void unsafe_arena_set_allocated_port_id(
      ::opi_api::common::v1::ObjectKey* port_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_port_id();

  // int32 native_vlanid = 2;
  void clear_native_vlanid();
  int32_t native_vlanid() const;
  void set_native_vlanid(int32_t value);
  private:
  int32_t _internal_native_vlanid() const;
  void _internal_set_native_vlanid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.UplinkSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* port_id_;
  int32_t native_vlanid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class UplinkPCSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.UplinkPCSpec) */ {
 public:
  inline UplinkPCSpec() : UplinkPCSpec(nullptr) {}
  ~UplinkPCSpec() override;
  explicit constexpr UplinkPCSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UplinkPCSpec(const UplinkPCSpec& from);
  UplinkPCSpec(UplinkPCSpec&& from) noexcept
    : UplinkPCSpec() {
    *this = ::std::move(from);
  }

  inline UplinkPCSpec& operator=(const UplinkPCSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline UplinkPCSpec& operator=(UplinkPCSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UplinkPCSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const UplinkPCSpec* internal_default_instance() {
    return reinterpret_cast<const UplinkPCSpec*>(
               &_UplinkPCSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UplinkPCSpec& a, UplinkPCSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(UplinkPCSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UplinkPCSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UplinkPCSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UplinkPCSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UplinkPCSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UplinkPCSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UplinkPCSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.UplinkPCSpec";
  }
  protected:
  explicit UplinkPCSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberIfidsBitmapFieldNumber = 1,
    kNativeVlanidFieldNumber = 2,
  };
  // uint64 member_ifids_bitmap = 1;
  void clear_member_ifids_bitmap();
  uint64_t member_ifids_bitmap() const;
  void set_member_ifids_bitmap(uint64_t value);
  private:
  uint64_t _internal_member_ifids_bitmap() const;
  void _internal_set_member_ifids_bitmap(uint64_t value);
  public:

  // int32 native_vlanid = 2;
  void clear_native_vlanid();
  int32_t native_vlanid() const;
  void set_native_vlanid(int32_t value);
  private:
  int32_t _internal_native_vlanid() const;
  void _internal_set_native_vlanid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t member_ifids_bitmap_;
  int32_t native_vlanid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class L3IfSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.L3IfSpec) */ {
 public:
  inline L3IfSpec() : L3IfSpec(nullptr) {}
  ~L3IfSpec() override;
  explicit constexpr L3IfSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L3IfSpec(const L3IfSpec& from);
  L3IfSpec(L3IfSpec&& from) noexcept
    : L3IfSpec() {
    *this = ::std::move(from);
  }

  inline L3IfSpec& operator=(const L3IfSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline L3IfSpec& operator=(L3IfSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L3IfSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const L3IfSpec* internal_default_instance() {
    return reinterpret_cast<const L3IfSpec*>(
               &_L3IfSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(L3IfSpec& a, L3IfSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(L3IfSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L3IfSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L3IfSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L3IfSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L3IfSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const L3IfSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L3IfSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.L3IfSpec";
  }
  protected:
  explicit L3IfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 2,
    kMacAddressFieldNumber = 5,
    kVpcIdFieldNumber = 1,
    kPortIdFieldNumber = 3,
    kEncapFieldNumber = 4,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 2;
  int prefix_size() const;
  private:
  int _internal_prefix_size() const;
  public:
  void clear_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_prefix(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >*
      mutable_prefix();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_prefix(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_add_prefix();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* add_prefix();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >&
      prefix() const;

  // bytes mac_address = 5;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // .opi_api.common.v1.ObjectKey vpc_id = 1;
  bool has_vpc_id() const;
  private:
  bool _internal_has_vpc_id() const;
  public:
  void clear_vpc_id();
  const ::opi_api::common::v1::ObjectKey& vpc_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_vpc_id();
  ::opi_api::common::v1::ObjectKey* mutable_vpc_id();
  void set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_vpc_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_vpc_id();
  public:
  void unsafe_arena_set_allocated_vpc_id(
      ::opi_api::common::v1::ObjectKey* vpc_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_vpc_id();

  // .opi_api.common.v1.ObjectKey port_id = 3;
  bool has_port_id() const;
  private:
  bool _internal_has_port_id() const;
  public:
  void clear_port_id();
  const ::opi_api::common::v1::ObjectKey& port_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_port_id();
  ::opi_api::common::v1::ObjectKey* mutable_port_id();
  void set_allocated_port_id(::opi_api::common::v1::ObjectKey* port_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_port_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_port_id();
  public:
  void unsafe_arena_set_allocated_port_id(
      ::opi_api::common::v1::ObjectKey* port_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_port_id();

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 4;
  bool has_encap() const;
  private:
  bool _internal_has_encap() const;
  public:
  void clear_encap();
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& encap() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::Encap* release_encap();
  ::opi_api::network::opinetcommon::v1alpha1::Encap* mutable_encap();
  void set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& _internal_encap() const;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _internal_mutable_encap();
  public:
  void unsafe_arena_set_allocated_encap(
      ::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  ::opi_api::network::opinetcommon::v1alpha1::Encap* unsafe_arena_release_encap();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.L3IfSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix > prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::opi_api::common::v1::ObjectKey* vpc_id_;
  ::opi_api::common::v1::ObjectKey* port_id_;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* encap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class BGPCommunity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.BGPCommunity) */ {
 public:
  inline BGPCommunity() : BGPCommunity(nullptr) {}
  ~BGPCommunity() override;
  explicit constexpr BGPCommunity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BGPCommunity(const BGPCommunity& from);
  BGPCommunity(BGPCommunity&& from) noexcept
    : BGPCommunity() {
    *this = ::std::move(from);
  }

  inline BGPCommunity& operator=(const BGPCommunity& from) {
    CopyFrom(from);
    return *this;
  }
  inline BGPCommunity& operator=(BGPCommunity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BGPCommunity& default_instance() {
    return *internal_default_instance();
  }
  static inline const BGPCommunity* internal_default_instance() {
    return reinterpret_cast<const BGPCommunity*>(
               &_BGPCommunity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BGPCommunity& a, BGPCommunity& b) {
    a.Swap(&b);
  }
  inline void Swap(BGPCommunity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BGPCommunity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BGPCommunity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BGPCommunity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BGPCommunity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BGPCommunity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BGPCommunity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.BGPCommunity";
  }
  protected:
  explicit BGPCommunity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsnFieldNumber = 1,
    kCommunityFieldNumber = 2,
  };
  // int32 asn = 1;
  void clear_asn();
  int32_t asn() const;
  void set_asn(int32_t value);
  private:
  int32_t _internal_asn() const;
  void _internal_set_asn(int32_t value);
  public:

  // int32 community = 2;
  void clear_community();
  int32_t community() const;
  void set_community(int32_t value);
  private:
  int32_t _internal_community() const;
  void _internal_set_community(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.BGPCommunity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t asn_;
  int32_t community_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class LoopbackIfSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.LoopbackIfSpec) */ {
 public:
  inline LoopbackIfSpec() : LoopbackIfSpec(nullptr) {}
  ~LoopbackIfSpec() override;
  explicit constexpr LoopbackIfSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoopbackIfSpec(const LoopbackIfSpec& from);
  LoopbackIfSpec(LoopbackIfSpec&& from) noexcept
    : LoopbackIfSpec() {
    *this = ::std::move(from);
  }

  inline LoopbackIfSpec& operator=(const LoopbackIfSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoopbackIfSpec& operator=(LoopbackIfSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoopbackIfSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoopbackIfSpec* internal_default_instance() {
    return reinterpret_cast<const LoopbackIfSpec*>(
               &_LoopbackIfSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoopbackIfSpec& a, LoopbackIfSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(LoopbackIfSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoopbackIfSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoopbackIfSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoopbackIfSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoopbackIfSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoopbackIfSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoopbackIfSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.LoopbackIfSpec";
  }
  protected:
  explicit LoopbackIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommunitiesFieldNumber = 2,
    kPrefixFieldNumber = 1,
  };
  // repeated .opi_api.network.cloud.v1alpha1.BGPCommunity communities = 2;
  int communities_size() const;
  private:
  int _internal_communities_size() const;
  public:
  void clear_communities();
  ::opi_api::network::cloud::v1alpha1::BGPCommunity* mutable_communities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::BGPCommunity >*
      mutable_communities();
  private:
  const ::opi_api::network::cloud::v1alpha1::BGPCommunity& _internal_communities(int index) const;
  ::opi_api::network::cloud::v1alpha1::BGPCommunity* _internal_add_communities();
  public:
  const ::opi_api::network::cloud::v1alpha1::BGPCommunity& communities(int index) const;
  ::opi_api::network::cloud::v1alpha1::BGPCommunity* add_communities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::BGPCommunity >&
      communities() const;

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_prefix();
  void set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_prefix();
  public:
  void unsafe_arena_set_allocated_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_prefix();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::BGPCommunity > communities_;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ControlIfSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.ControlIfSpec) */ {
 public:
  inline ControlIfSpec() : ControlIfSpec(nullptr) {}
  ~ControlIfSpec() override;
  explicit constexpr ControlIfSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlIfSpec(const ControlIfSpec& from);
  ControlIfSpec(ControlIfSpec&& from) noexcept
    : ControlIfSpec() {
    *this = ::std::move(from);
  }

  inline ControlIfSpec& operator=(const ControlIfSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlIfSpec& operator=(ControlIfSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlIfSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlIfSpec* internal_default_instance() {
    return reinterpret_cast<const ControlIfSpec*>(
               &_ControlIfSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControlIfSpec& a, ControlIfSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlIfSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlIfSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlIfSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlIfSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlIfSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlIfSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlIfSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.ControlIfSpec";
  }
  protected:
  explicit ControlIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 2,
    kPrefixFieldNumber = 1,
  };
  // bytes mac_address = 2;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_prefix();
  void set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_prefix();
  public:
  void unsafe_arena_set_allocated_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_prefix();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.ControlIfSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class HostIfSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.HostIfSpec) */ {
 public:
  inline HostIfSpec() : HostIfSpec(nullptr) {}
  ~HostIfSpec() override;
  explicit constexpr HostIfSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostIfSpec(const HostIfSpec& from);
  HostIfSpec(HostIfSpec&& from) noexcept
    : HostIfSpec() {
    *this = ::std::move(from);
  }

  inline HostIfSpec& operator=(const HostIfSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostIfSpec& operator=(HostIfSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostIfSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostIfSpec* internal_default_instance() {
    return reinterpret_cast<const HostIfSpec*>(
               &_HostIfSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HostIfSpec& a, HostIfSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(HostIfSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostIfSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostIfSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostIfSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostIfSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HostIfSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostIfSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.HostIfSpec";
  }
  protected:
  explicit HostIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 3,
    kIfnameFieldNumber = 4,
    kVfFieldNumber = 1,
    kEnableConnectionTrackingFieldNumber = 2,
  };
  // bytes mac_address = 3;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // string ifname = 4;
  void clear_ifname();
  const std::string& ifname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ifname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ifname();
  PROTOBUF_NODISCARD std::string* release_ifname();
  void set_allocated_ifname(std::string* ifname);
  private:
  const std::string& _internal_ifname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ifname(const std::string& value);
  std::string* _internal_mutable_ifname();
  public:

  // bool vf = 1;
  void clear_vf();
  bool vf() const;
  void set_vf(bool value);
  private:
  bool _internal_vf() const;
  void _internal_set_vf(bool value);
  public:

  // bool enable_connection_tracking = 2;
  void clear_enable_connection_tracking();
  bool enable_connection_tracking() const;
  void set_enable_connection_tracking(bool value);
  private:
  bool _internal_enable_connection_tracking() const;
  void _internal_set_enable_connection_tracking(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.HostIfSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ifname_;
  bool vf_;
  bool enable_connection_tracking_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class UplinkIfStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.UplinkIfStatus) */ {
 public:
  inline UplinkIfStatus() : UplinkIfStatus(nullptr) {}
  ~UplinkIfStatus() override;
  explicit constexpr UplinkIfStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UplinkIfStatus(const UplinkIfStatus& from);
  UplinkIfStatus(UplinkIfStatus&& from) noexcept
    : UplinkIfStatus() {
    *this = ::std::move(from);
  }

  inline UplinkIfStatus& operator=(const UplinkIfStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UplinkIfStatus& operator=(UplinkIfStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UplinkIfStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const UplinkIfStatus* internal_default_instance() {
    return reinterpret_cast<const UplinkIfStatus*>(
               &_UplinkIfStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UplinkIfStatus& a, UplinkIfStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UplinkIfStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UplinkIfStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UplinkIfStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UplinkIfStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UplinkIfStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UplinkIfStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UplinkIfStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.UplinkIfStatus";
  }
  protected:
  explicit UplinkIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHwIfIdxFieldNumber = 1,
    kHwPortNumberFieldNumber = 2,
  };
  // int32 hw_if_idx = 1;
  void clear_hw_if_idx();
  int32_t hw_if_idx() const;
  void set_hw_if_idx(int32_t value);
  private:
  int32_t _internal_hw_if_idx() const;
  void _internal_set_hw_if_idx(int32_t value);
  public:

  // int32 hw_port_number = 2;
  void clear_hw_port_number();
  int32_t hw_port_number() const;
  void set_hw_port_number(int32_t value);
  private:
  int32_t _internal_hw_port_number() const;
  void _internal_set_hw_port_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t hw_if_idx_;
  int32_t hw_port_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class LoopbackIfStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.LoopbackIfStatus) */ {
 public:
  inline LoopbackIfStatus() : LoopbackIfStatus(nullptr) {}
  ~LoopbackIfStatus() override;
  explicit constexpr LoopbackIfStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoopbackIfStatus(const LoopbackIfStatus& from);
  LoopbackIfStatus(LoopbackIfStatus&& from) noexcept
    : LoopbackIfStatus() {
    *this = ::std::move(from);
  }

  inline LoopbackIfStatus& operator=(const LoopbackIfStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoopbackIfStatus& operator=(LoopbackIfStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoopbackIfStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoopbackIfStatus* internal_default_instance() {
    return reinterpret_cast<const LoopbackIfStatus*>(
               &_LoopbackIfStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LoopbackIfStatus& a, LoopbackIfStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LoopbackIfStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoopbackIfStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoopbackIfStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoopbackIfStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoopbackIfStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoopbackIfStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoopbackIfStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.LoopbackIfStatus";
  }
  protected:
  explicit LoopbackIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfnameFieldNumber = 1,
  };
  // string ifname = 1;
  void clear_ifname();
  const std::string& ifname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ifname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ifname();
  PROTOBUF_NODISCARD std::string* release_ifname();
  void set_allocated_ifname(std::string* ifname);
  private:
  const std::string& _internal_ifname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ifname(const std::string& value);
  std::string* _internal_mutable_ifname();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ifname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class HostIfStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.HostIfStatus) */ {
 public:
  inline HostIfStatus() : HostIfStatus(nullptr) {}
  ~HostIfStatus() override;
  explicit constexpr HostIfStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostIfStatus(const HostIfStatus& from);
  HostIfStatus(HostIfStatus&& from) noexcept
    : HostIfStatus() {
    *this = ::std::move(from);
  }

  inline HostIfStatus& operator=(const HostIfStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostIfStatus& operator=(HostIfStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostIfStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostIfStatus* internal_default_instance() {
    return reinterpret_cast<const HostIfStatus*>(
               &_HostIfStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HostIfStatus& a, HostIfStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(HostIfStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostIfStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostIfStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostIfStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostIfStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HostIfStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostIfStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.HostIfStatus";
  }
  protected:
  explicit HostIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHwIfIdxesFieldNumber = 1,
    kMacAddressFieldNumber = 2,
    kIfnameFieldNumber = 4,
    kStatusFieldNumber = 3,
  };
  // repeated bytes hw_if_idxes = 1;
  int hw_if_idxes_size() const;
  private:
  int _internal_hw_if_idxes_size() const;
  public:
  void clear_hw_if_idxes();
  const std::string& hw_if_idxes(int index) const;
  std::string* mutable_hw_if_idxes(int index);
  void set_hw_if_idxes(int index, const std::string& value);
  void set_hw_if_idxes(int index, std::string&& value);
  void set_hw_if_idxes(int index, const char* value);
  void set_hw_if_idxes(int index, const void* value, size_t size);
  std::string* add_hw_if_idxes();
  void add_hw_if_idxes(const std::string& value);
  void add_hw_if_idxes(std::string&& value);
  void add_hw_if_idxes(const char* value);
  void add_hw_if_idxes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hw_if_idxes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hw_if_idxes();
  private:
  const std::string& _internal_hw_if_idxes(int index) const;
  std::string* _internal_add_hw_if_idxes();
  public:

  // bytes mac_address = 2;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // string ifname = 4;
  void clear_ifname();
  const std::string& ifname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ifname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ifname();
  PROTOBUF_NODISCARD std::string* release_ifname();
  void set_allocated_ifname(std::string* ifname);
  private:
  const std::string& _internal_ifname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ifname(const std::string& value);
  std::string* _internal_mutable_ifname();
  public:

  // .opi_api.network.cloud.v1alpha1.IfStatus status = 3;
  void clear_status();
  ::opi_api::network::cloud::v1alpha1::IfStatus status() const;
  void set_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  private:
  ::opi_api::network::cloud::v1alpha1::IfStatus _internal_status() const;
  void _internal_set_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.HostIfStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hw_if_idxes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ifname_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InterfaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.InterfaceStatus) */ {
 public:
  inline InterfaceStatus() : InterfaceStatus(nullptr) {}
  ~InterfaceStatus() override;
  explicit constexpr InterfaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterfaceStatus(const InterfaceStatus& from);
  InterfaceStatus(InterfaceStatus&& from) noexcept
    : InterfaceStatus() {
    *this = ::std::move(from);
  }

  inline InterfaceStatus& operator=(const InterfaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterfaceStatus& operator=(InterfaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterfaceStatus& default_instance() {
    return *internal_default_instance();
  }
  enum IfstatusCase {
    kUplinkIfStatus = 3,
    kLoopbackIfStatus = 4,
    kHostIfStatus = 5,
    IFSTATUS_NOT_SET = 0,
  };

  static inline const InterfaceStatus* internal_default_instance() {
    return reinterpret_cast<const InterfaceStatus*>(
               &_InterfaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InterfaceStatus& a, InterfaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(InterfaceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterfaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterfaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterfaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterfaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterfaceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.InterfaceStatus";
  }
  protected:
  explicit InterfaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfIndexFieldNumber = 1,
    kOperStatusFieldNumber = 2,
    kUplinkIfStatusFieldNumber = 3,
    kLoopbackIfStatusFieldNumber = 4,
    kHostIfStatusFieldNumber = 5,
  };
  // uint32 if_index = 1;
  void clear_if_index();
  uint32_t if_index() const;
  void set_if_index(uint32_t value);
  private:
  uint32_t _internal_if_index() const;
  void _internal_set_if_index(uint32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.IfStatus oper_status = 2;
  void clear_oper_status();
  ::opi_api::network::cloud::v1alpha1::IfStatus oper_status() const;
  void set_oper_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  private:
  ::opi_api::network::cloud::v1alpha1::IfStatus _internal_oper_status() const;
  void _internal_set_oper_status(::opi_api::network::cloud::v1alpha1::IfStatus value);
  public:

  // .opi_api.network.cloud.v1alpha1.UplinkIfStatus uplink_if_status = 3;
  bool has_uplink_if_status() const;
  private:
  bool _internal_has_uplink_if_status() const;
  public:
  void clear_uplink_if_status();
  const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus& uplink_if_status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* release_uplink_if_status();
  ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* mutable_uplink_if_status();
  void set_allocated_uplink_if_status(::opi_api::network::cloud::v1alpha1::UplinkIfStatus* uplink_if_status);
  private:
  const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus& _internal_uplink_if_status() const;
  ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* _internal_mutable_uplink_if_status();
  public:
  void unsafe_arena_set_allocated_uplink_if_status(
      ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* uplink_if_status);
  ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* unsafe_arena_release_uplink_if_status();

  // .opi_api.network.cloud.v1alpha1.LoopbackIfStatus loopback_if_status = 4;
  bool has_loopback_if_status() const;
  private:
  bool _internal_has_loopback_if_status() const;
  public:
  void clear_loopback_if_status();
  const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus& loopback_if_status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* release_loopback_if_status();
  ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* mutable_loopback_if_status();
  void set_allocated_loopback_if_status(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* loopback_if_status);
  private:
  const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus& _internal_loopback_if_status() const;
  ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* _internal_mutable_loopback_if_status();
  public:
  void unsafe_arena_set_allocated_loopback_if_status(
      ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* loopback_if_status);
  ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* unsafe_arena_release_loopback_if_status();

  // .opi_api.network.cloud.v1alpha1.HostIfStatus host_if_status = 5;
  bool has_host_if_status() const;
  private:
  bool _internal_has_host_if_status() const;
  public:
  void clear_host_if_status();
  const ::opi_api::network::cloud::v1alpha1::HostIfStatus& host_if_status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::HostIfStatus* release_host_if_status();
  ::opi_api::network::cloud::v1alpha1::HostIfStatus* mutable_host_if_status();
  void set_allocated_host_if_status(::opi_api::network::cloud::v1alpha1::HostIfStatus* host_if_status);
  private:
  const ::opi_api::network::cloud::v1alpha1::HostIfStatus& _internal_host_if_status() const;
  ::opi_api::network::cloud::v1alpha1::HostIfStatus* _internal_mutable_host_if_status();
  public:
  void unsafe_arena_set_allocated_host_if_status(
      ::opi_api::network::cloud::v1alpha1::HostIfStatus* host_if_status);
  ::opi_api::network::cloud::v1alpha1::HostIfStatus* unsafe_arena_release_host_if_status();

  void clear_ifstatus();
  IfstatusCase ifstatus_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.InterfaceStatus)
 private:
  class _Internal;
  void set_has_uplink_if_status();
  void set_has_loopback_if_status();
  void set_has_host_if_status();

  inline bool has_ifstatus() const;
  inline void clear_has_ifstatus();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t if_index_;
  int oper_status_;
  union IfstatusUnion {
    constexpr IfstatusUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* uplink_if_status_;
    ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* loopback_if_status_;
    ::opi_api::network::cloud::v1alpha1::HostIfStatus* host_if_status_;
  } ifstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_interface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Interface

// .opi_api.network.cloud.v1alpha1.InterfaceSpec spec = 1;
inline bool Interface::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Interface::has_spec() const {
  return _internal_has_spec();
}
inline void Interface::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::InterfaceSpec& Interface::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::InterfaceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::InterfaceSpec&>(
      ::opi_api::network::cloud::v1alpha1::_InterfaceSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::InterfaceSpec& Interface::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Interface.spec)
  return _internal_spec();
}
inline void Interface::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::InterfaceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Interface.spec)
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceSpec* Interface::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceSpec* Interface::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Interface.spec)
  
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceSpec* Interface::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::InterfaceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceSpec* Interface::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::InterfaceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Interface.spec)
  return _msg;
}
inline void Interface::set_allocated_spec(::opi_api::network::cloud::v1alpha1::InterfaceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::InterfaceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Interface.spec)
}

// .opi_api.network.cloud.v1alpha1.InterfaceStatus status = 2;
inline bool Interface::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Interface::has_status() const {
  return _internal_has_status();
}
inline void Interface::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::InterfaceStatus& Interface::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::InterfaceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::InterfaceStatus&>(
      ::opi_api::network::cloud::v1alpha1::_InterfaceStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::InterfaceStatus& Interface::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Interface.status)
  return _internal_status();
}
inline void Interface::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::InterfaceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Interface.status)
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceStatus* Interface::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceStatus* Interface::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Interface.status)
  
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceStatus* Interface::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::InterfaceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::cloud::v1alpha1::InterfaceStatus* Interface::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::InterfaceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Interface.status)
  return _msg;
}
inline void Interface::set_allocated_status(::opi_api::network::cloud::v1alpha1::InterfaceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::InterfaceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Interface.status)
}

// -------------------------------------------------------------------

// InterfaceSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool InterfaceSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool InterfaceSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& InterfaceSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& InterfaceSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.id)
  return _internal_id();
}
inline void InterfaceSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* InterfaceSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* InterfaceSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* InterfaceSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* InterfaceSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.id)
  return _msg;
}
inline void InterfaceSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.id)
}

// int32 ifid = 2;
inline void InterfaceSpec::clear_ifid() {
  ifid_ = 0;
}
inline int32_t InterfaceSpec::_internal_ifid() const {
  return ifid_;
}
inline int32_t InterfaceSpec::ifid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.ifid)
  return _internal_ifid();
}
inline void InterfaceSpec::_internal_set_ifid(int32_t value) {
  
  ifid_ = value;
}
inline void InterfaceSpec::set_ifid(int32_t value) {
  _internal_set_ifid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.InterfaceSpec.ifid)
}

// .opi_api.network.cloud.v1alpha1.IfStatus admin_status = 3;
inline void InterfaceSpec::clear_admin_status() {
  admin_status_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus InterfaceSpec::_internal_admin_status() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::IfStatus >(admin_status_);
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus InterfaceSpec::admin_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.admin_status)
  return _internal_admin_status();
}
inline void InterfaceSpec::_internal_set_admin_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  
  admin_status_ = value;
}
inline void InterfaceSpec::set_admin_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  _internal_set_admin_status(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.InterfaceSpec.admin_status)
}

// .opi_api.network.cloud.v1alpha1.UplinkSpec uplink_spec = 4;
inline bool InterfaceSpec::_internal_has_uplink_spec() const {
  return ifinfo_case() == kUplinkSpec;
}
inline bool InterfaceSpec::has_uplink_spec() const {
  return _internal_has_uplink_spec();
}
inline void InterfaceSpec::set_has_uplink_spec() {
  _oneof_case_[0] = kUplinkSpec;
}
inline void InterfaceSpec::clear_uplink_spec() {
  if (_internal_has_uplink_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.uplink_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::UplinkSpec* InterfaceSpec::release_uplink_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
  if (_internal_has_uplink_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::UplinkSpec* temp = ifinfo_.uplink_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.uplink_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkSpec& InterfaceSpec::_internal_uplink_spec() const {
  return _internal_has_uplink_spec()
      ? *ifinfo_.uplink_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::UplinkSpec&>(::opi_api::network::cloud::v1alpha1::_UplinkSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkSpec& InterfaceSpec::uplink_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
  return _internal_uplink_spec();
}
inline ::opi_api::network::cloud::v1alpha1::UplinkSpec* InterfaceSpec::unsafe_arena_release_uplink_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
  if (_internal_has_uplink_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::UplinkSpec* temp = ifinfo_.uplink_spec_;
    ifinfo_.uplink_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_uplink_spec(::opi_api::network::cloud::v1alpha1::UplinkSpec* uplink_spec) {
  clear_ifinfo();
  if (uplink_spec) {
    set_has_uplink_spec();
    ifinfo_.uplink_spec_ = uplink_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
}
inline ::opi_api::network::cloud::v1alpha1::UplinkSpec* InterfaceSpec::_internal_mutable_uplink_spec() {
  if (!_internal_has_uplink_spec()) {
    clear_ifinfo();
    set_has_uplink_spec();
    ifinfo_.uplink_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkSpec >(GetArenaForAllocation());
  }
  return ifinfo_.uplink_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::UplinkSpec* InterfaceSpec::mutable_uplink_spec() {
  ::opi_api::network::cloud::v1alpha1::UplinkSpec* _msg = _internal_mutable_uplink_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.UplinkPCSpec uplink_pc_spec = 5;
inline bool InterfaceSpec::_internal_has_uplink_pc_spec() const {
  return ifinfo_case() == kUplinkPcSpec;
}
inline bool InterfaceSpec::has_uplink_pc_spec() const {
  return _internal_has_uplink_pc_spec();
}
inline void InterfaceSpec::set_has_uplink_pc_spec() {
  _oneof_case_[0] = kUplinkPcSpec;
}
inline void InterfaceSpec::clear_uplink_pc_spec() {
  if (_internal_has_uplink_pc_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.uplink_pc_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* InterfaceSpec::release_uplink_pc_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
  if (_internal_has_uplink_pc_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* temp = ifinfo_.uplink_pc_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.uplink_pc_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec& InterfaceSpec::_internal_uplink_pc_spec() const {
  return _internal_has_uplink_pc_spec()
      ? *ifinfo_.uplink_pc_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::UplinkPCSpec&>(::opi_api::network::cloud::v1alpha1::_UplinkPCSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec& InterfaceSpec::uplink_pc_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
  return _internal_uplink_pc_spec();
}
inline ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* InterfaceSpec::unsafe_arena_release_uplink_pc_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
  if (_internal_has_uplink_pc_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* temp = ifinfo_.uplink_pc_spec_;
    ifinfo_.uplink_pc_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_uplink_pc_spec(::opi_api::network::cloud::v1alpha1::UplinkPCSpec* uplink_pc_spec) {
  clear_ifinfo();
  if (uplink_pc_spec) {
    set_has_uplink_pc_spec();
    ifinfo_.uplink_pc_spec_ = uplink_pc_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
}
inline ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* InterfaceSpec::_internal_mutable_uplink_pc_spec() {
  if (!_internal_has_uplink_pc_spec()) {
    clear_ifinfo();
    set_has_uplink_pc_spec();
    ifinfo_.uplink_pc_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkPCSpec >(GetArenaForAllocation());
  }
  return ifinfo_.uplink_pc_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* InterfaceSpec::mutable_uplink_pc_spec() {
  ::opi_api::network::cloud::v1alpha1::UplinkPCSpec* _msg = _internal_mutable_uplink_pc_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.L3IfSpec l3_if_spec = 6;
inline bool InterfaceSpec::_internal_has_l3_if_spec() const {
  return ifinfo_case() == kL3IfSpec;
}
inline bool InterfaceSpec::has_l3_if_spec() const {
  return _internal_has_l3_if_spec();
}
inline void InterfaceSpec::set_has_l3_if_spec() {
  _oneof_case_[0] = kL3IfSpec;
}
inline void InterfaceSpec::clear_l3_if_spec() {
  if (_internal_has_l3_if_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.l3_if_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L3IfSpec* InterfaceSpec::release_l3_if_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
  if (_internal_has_l3_if_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::L3IfSpec* temp = ifinfo_.l3_if_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.l3_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L3IfSpec& InterfaceSpec::_internal_l3_if_spec() const {
  return _internal_has_l3_if_spec()
      ? *ifinfo_.l3_if_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L3IfSpec&>(::opi_api::network::cloud::v1alpha1::_L3IfSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L3IfSpec& InterfaceSpec::l3_if_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
  return _internal_l3_if_spec();
}
inline ::opi_api::network::cloud::v1alpha1::L3IfSpec* InterfaceSpec::unsafe_arena_release_l3_if_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
  if (_internal_has_l3_if_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::L3IfSpec* temp = ifinfo_.l3_if_spec_;
    ifinfo_.l3_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_l3_if_spec(::opi_api::network::cloud::v1alpha1::L3IfSpec* l3_if_spec) {
  clear_ifinfo();
  if (l3_if_spec) {
    set_has_l3_if_spec();
    ifinfo_.l3_if_spec_ = l3_if_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
}
inline ::opi_api::network::cloud::v1alpha1::L3IfSpec* InterfaceSpec::_internal_mutable_l3_if_spec() {
  if (!_internal_has_l3_if_spec()) {
    clear_ifinfo();
    set_has_l3_if_spec();
    ifinfo_.l3_if_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3IfSpec >(GetArenaForAllocation());
  }
  return ifinfo_.l3_if_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::L3IfSpec* InterfaceSpec::mutable_l3_if_spec() {
  ::opi_api::network::cloud::v1alpha1::L3IfSpec* _msg = _internal_mutable_l3_if_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.LoopbackIfSpec loopback_if_spec = 7;
inline bool InterfaceSpec::_internal_has_loopback_if_spec() const {
  return ifinfo_case() == kLoopbackIfSpec;
}
inline bool InterfaceSpec::has_loopback_if_spec() const {
  return _internal_has_loopback_if_spec();
}
inline void InterfaceSpec::set_has_loopback_if_spec() {
  _oneof_case_[0] = kLoopbackIfSpec;
}
inline void InterfaceSpec::clear_loopback_if_spec() {
  if (_internal_has_loopback_if_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.loopback_if_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* InterfaceSpec::release_loopback_if_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
  if (_internal_has_loopback_if_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* temp = ifinfo_.loopback_if_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.loopback_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec& InterfaceSpec::_internal_loopback_if_spec() const {
  return _internal_has_loopback_if_spec()
      ? *ifinfo_.loopback_if_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec&>(::opi_api::network::cloud::v1alpha1::_LoopbackIfSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec& InterfaceSpec::loopback_if_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
  return _internal_loopback_if_spec();
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* InterfaceSpec::unsafe_arena_release_loopback_if_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
  if (_internal_has_loopback_if_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* temp = ifinfo_.loopback_if_spec_;
    ifinfo_.loopback_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_loopback_if_spec(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* loopback_if_spec) {
  clear_ifinfo();
  if (loopback_if_spec) {
    set_has_loopback_if_spec();
    ifinfo_.loopback_if_spec_ = loopback_if_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* InterfaceSpec::_internal_mutable_loopback_if_spec() {
  if (!_internal_has_loopback_if_spec()) {
    clear_ifinfo();
    set_has_loopback_if_spec();
    ifinfo_.loopback_if_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec >(GetArenaForAllocation());
  }
  return ifinfo_.loopback_if_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* InterfaceSpec::mutable_loopback_if_spec() {
  ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* _msg = _internal_mutable_loopback_if_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.ControlIfSpec control_if_spec = 8;
inline bool InterfaceSpec::_internal_has_control_if_spec() const {
  return ifinfo_case() == kControlIfSpec;
}
inline bool InterfaceSpec::has_control_if_spec() const {
  return _internal_has_control_if_spec();
}
inline void InterfaceSpec::set_has_control_if_spec() {
  _oneof_case_[0] = kControlIfSpec;
}
inline void InterfaceSpec::clear_control_if_spec() {
  if (_internal_has_control_if_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.control_if_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::ControlIfSpec* InterfaceSpec::release_control_if_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
  if (_internal_has_control_if_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::ControlIfSpec* temp = ifinfo_.control_if_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.control_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::ControlIfSpec& InterfaceSpec::_internal_control_if_spec() const {
  return _internal_has_control_if_spec()
      ? *ifinfo_.control_if_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::ControlIfSpec&>(::opi_api::network::cloud::v1alpha1::_ControlIfSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::ControlIfSpec& InterfaceSpec::control_if_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
  return _internal_control_if_spec();
}
inline ::opi_api::network::cloud::v1alpha1::ControlIfSpec* InterfaceSpec::unsafe_arena_release_control_if_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
  if (_internal_has_control_if_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::ControlIfSpec* temp = ifinfo_.control_if_spec_;
    ifinfo_.control_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_control_if_spec(::opi_api::network::cloud::v1alpha1::ControlIfSpec* control_if_spec) {
  clear_ifinfo();
  if (control_if_spec) {
    set_has_control_if_spec();
    ifinfo_.control_if_spec_ = control_if_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
}
inline ::opi_api::network::cloud::v1alpha1::ControlIfSpec* InterfaceSpec::_internal_mutable_control_if_spec() {
  if (!_internal_has_control_if_spec()) {
    clear_ifinfo();
    set_has_control_if_spec();
    ifinfo_.control_if_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::ControlIfSpec >(GetArenaForAllocation());
  }
  return ifinfo_.control_if_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::ControlIfSpec* InterfaceSpec::mutable_control_if_spec() {
  ::opi_api::network::cloud::v1alpha1::ControlIfSpec* _msg = _internal_mutable_control_if_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.HostIfSpec host_if_spec = 9;
inline bool InterfaceSpec::_internal_has_host_if_spec() const {
  return ifinfo_case() == kHostIfSpec;
}
inline bool InterfaceSpec::has_host_if_spec() const {
  return _internal_has_host_if_spec();
}
inline void InterfaceSpec::set_has_host_if_spec() {
  _oneof_case_[0] = kHostIfSpec;
}
inline void InterfaceSpec::clear_host_if_spec() {
  if (_internal_has_host_if_spec()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifinfo_.host_if_spec_;
    }
    clear_has_ifinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::HostIfSpec* InterfaceSpec::release_host_if_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
  if (_internal_has_host_if_spec()) {
    clear_has_ifinfo();
      ::opi_api::network::cloud::v1alpha1::HostIfSpec* temp = ifinfo_.host_if_spec_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifinfo_.host_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::HostIfSpec& InterfaceSpec::_internal_host_if_spec() const {
  return _internal_has_host_if_spec()
      ? *ifinfo_.host_if_spec_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::HostIfSpec&>(::opi_api::network::cloud::v1alpha1::_HostIfSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::HostIfSpec& InterfaceSpec::host_if_spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
  return _internal_host_if_spec();
}
inline ::opi_api::network::cloud::v1alpha1::HostIfSpec* InterfaceSpec::unsafe_arena_release_host_if_spec() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
  if (_internal_has_host_if_spec()) {
    clear_has_ifinfo();
    ::opi_api::network::cloud::v1alpha1::HostIfSpec* temp = ifinfo_.host_if_spec_;
    ifinfo_.host_if_spec_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceSpec::unsafe_arena_set_allocated_host_if_spec(::opi_api::network::cloud::v1alpha1::HostIfSpec* host_if_spec) {
  clear_ifinfo();
  if (host_if_spec) {
    set_has_host_if_spec();
    ifinfo_.host_if_spec_ = host_if_spec;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
}
inline ::opi_api::network::cloud::v1alpha1::HostIfSpec* InterfaceSpec::_internal_mutable_host_if_spec() {
  if (!_internal_has_host_if_spec()) {
    clear_ifinfo();
    set_has_host_if_spec();
    ifinfo_.host_if_spec_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::HostIfSpec >(GetArenaForAllocation());
  }
  return ifinfo_.host_if_spec_;
}
inline ::opi_api::network::cloud::v1alpha1::HostIfSpec* InterfaceSpec::mutable_host_if_spec() {
  ::opi_api::network::cloud::v1alpha1::HostIfSpec* _msg = _internal_mutable_host_if_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
  return _msg;
}

inline bool InterfaceSpec::has_ifinfo() const {
  return ifinfo_case() != IFINFO_NOT_SET;
}
inline void InterfaceSpec::clear_has_ifinfo() {
  _oneof_case_[0] = IFINFO_NOT_SET;
}
inline InterfaceSpec::IfinfoCase InterfaceSpec::ifinfo_case() const {
  return InterfaceSpec::IfinfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UplinkSpec

// .opi_api.common.v1.ObjectKey port_id = 1;
inline bool UplinkSpec::_internal_has_port_id() const {
  return this != internal_default_instance() && port_id_ != nullptr;
}
inline bool UplinkSpec::has_port_id() const {
  return _internal_has_port_id();
}
inline const ::opi_api::common::v1::ObjectKey& UplinkSpec::_internal_port_id() const {
  const ::opi_api::common::v1::ObjectKey* p = port_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& UplinkSpec::port_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkSpec.port_id)
  return _internal_port_id();
}
inline void UplinkSpec::unsafe_arena_set_allocated_port_id(
    ::opi_api::common::v1::ObjectKey* port_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id_);
  }
  port_id_ = port_id;
  if (port_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.UplinkSpec.port_id)
}
inline ::opi_api::common::v1::ObjectKey* UplinkSpec::release_port_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = port_id_;
  port_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* UplinkSpec::unsafe_arena_release_port_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.UplinkSpec.port_id)
  
  ::opi_api::common::v1::ObjectKey* temp = port_id_;
  port_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* UplinkSpec::_internal_mutable_port_id() {
  
  if (port_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    port_id_ = p;
  }
  return port_id_;
}
inline ::opi_api::common::v1::ObjectKey* UplinkSpec::mutable_port_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.UplinkSpec.port_id)
  return _msg;
}
inline void UplinkSpec::set_allocated_port_id(::opi_api::common::v1::ObjectKey* port_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id_);
  }
  if (port_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id));
    if (message_arena != submessage_arena) {
      port_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_id, submessage_arena);
    }
    
  } else {
    
  }
  port_id_ = port_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.UplinkSpec.port_id)
}

// int32 native_vlanid = 2;
inline void UplinkSpec::clear_native_vlanid() {
  native_vlanid_ = 0;
}
inline int32_t UplinkSpec::_internal_native_vlanid() const {
  return native_vlanid_;
}
inline int32_t UplinkSpec::native_vlanid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkSpec.native_vlanid)
  return _internal_native_vlanid();
}
inline void UplinkSpec::_internal_set_native_vlanid(int32_t value) {
  
  native_vlanid_ = value;
}
inline void UplinkSpec::set_native_vlanid(int32_t value) {
  _internal_set_native_vlanid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UplinkSpec.native_vlanid)
}

// -------------------------------------------------------------------

// UplinkPCSpec

// uint64 member_ifids_bitmap = 1;
inline void UplinkPCSpec::clear_member_ifids_bitmap() {
  member_ifids_bitmap_ = uint64_t{0u};
}
inline uint64_t UplinkPCSpec::_internal_member_ifids_bitmap() const {
  return member_ifids_bitmap_;
}
inline uint64_t UplinkPCSpec::member_ifids_bitmap() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkPCSpec.member_ifids_bitmap)
  return _internal_member_ifids_bitmap();
}
inline void UplinkPCSpec::_internal_set_member_ifids_bitmap(uint64_t value) {
  
  member_ifids_bitmap_ = value;
}
inline void UplinkPCSpec::set_member_ifids_bitmap(uint64_t value) {
  _internal_set_member_ifids_bitmap(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UplinkPCSpec.member_ifids_bitmap)
}

// int32 native_vlanid = 2;
inline void UplinkPCSpec::clear_native_vlanid() {
  native_vlanid_ = 0;
}
inline int32_t UplinkPCSpec::_internal_native_vlanid() const {
  return native_vlanid_;
}
inline int32_t UplinkPCSpec::native_vlanid() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkPCSpec.native_vlanid)
  return _internal_native_vlanid();
}
inline void UplinkPCSpec::_internal_set_native_vlanid(int32_t value) {
  
  native_vlanid_ = value;
}
inline void UplinkPCSpec::set_native_vlanid(int32_t value) {
  _internal_set_native_vlanid(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UplinkPCSpec.native_vlanid)
}

// -------------------------------------------------------------------

// L3IfSpec

// .opi_api.common.v1.ObjectKey vpc_id = 1;
inline bool L3IfSpec::_internal_has_vpc_id() const {
  return this != internal_default_instance() && vpc_id_ != nullptr;
}
inline bool L3IfSpec::has_vpc_id() const {
  return _internal_has_vpc_id();
}
inline const ::opi_api::common::v1::ObjectKey& L3IfSpec::_internal_vpc_id() const {
  const ::opi_api::common::v1::ObjectKey* p = vpc_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& L3IfSpec::vpc_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id)
  return _internal_vpc_id();
}
inline void L3IfSpec::unsafe_arena_set_allocated_vpc_id(
    ::opi_api::common::v1::ObjectKey* vpc_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id_);
  }
  vpc_id_ = vpc_id;
  if (vpc_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id)
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::release_vpc_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = vpc_id_;
  vpc_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::unsafe_arena_release_vpc_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id)
  
  ::opi_api::common::v1::ObjectKey* temp = vpc_id_;
  vpc_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::_internal_mutable_vpc_id() {
  
  if (vpc_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    vpc_id_ = p;
  }
  return vpc_id_;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::mutable_vpc_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_vpc_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id)
  return _msg;
}
inline void L3IfSpec::set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id_);
  }
  if (vpc_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id));
    if (message_arena != submessage_arena) {
      vpc_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpc_id, submessage_arena);
    }
    
  } else {
    
  }
  vpc_id_ = vpc_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id)
}

// .opi_api.common.v1.ObjectKey port_id = 3;
inline bool L3IfSpec::_internal_has_port_id() const {
  return this != internal_default_instance() && port_id_ != nullptr;
}
inline bool L3IfSpec::has_port_id() const {
  return _internal_has_port_id();
}
inline const ::opi_api::common::v1::ObjectKey& L3IfSpec::_internal_port_id() const {
  const ::opi_api::common::v1::ObjectKey* p = port_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& L3IfSpec::port_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3IfSpec.port_id)
  return _internal_port_id();
}
inline void L3IfSpec::unsafe_arena_set_allocated_port_id(
    ::opi_api::common::v1::ObjectKey* port_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id_);
  }
  port_id_ = port_id;
  if (port_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.port_id)
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::release_port_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = port_id_;
  port_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::unsafe_arena_release_port_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3IfSpec.port_id)
  
  ::opi_api::common::v1::ObjectKey* temp = port_id_;
  port_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::_internal_mutable_port_id() {
  
  if (port_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    port_id_ = p;
  }
  return port_id_;
}
inline ::opi_api::common::v1::ObjectKey* L3IfSpec::mutable_port_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3IfSpec.port_id)
  return _msg;
}
inline void L3IfSpec::set_allocated_port_id(::opi_api::common::v1::ObjectKey* port_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id_);
  }
  if (port_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_id));
    if (message_arena != submessage_arena) {
      port_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_id, submessage_arena);
    }
    
  } else {
    
  }
  port_id_ = port_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.port_id)
}

// repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 2;
inline int L3IfSpec::_internal_prefix_size() const {
  return prefix_.size();
}
inline int L3IfSpec::prefix_size() const {
  return _internal_prefix_size();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* L3IfSpec::mutable_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3IfSpec.prefix)
  return prefix_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >*
L3IfSpec::mutable_prefix() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.L3IfSpec.prefix)
  return &prefix_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& L3IfSpec::_internal_prefix(int index) const {
  return prefix_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& L3IfSpec::prefix(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3IfSpec.prefix)
  return _internal_prefix(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* L3IfSpec::_internal_add_prefix() {
  return prefix_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* L3IfSpec::add_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _add = _internal_add_prefix();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.L3IfSpec.prefix)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPPrefix >&
L3IfSpec::prefix() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.L3IfSpec.prefix)
  return prefix_;
}

// .opi_api.network.opinetcommon.v1alpha1.Encap encap = 4;
inline bool L3IfSpec::_internal_has_encap() const {
  return this != internal_default_instance() && encap_ != nullptr;
}
inline bool L3IfSpec::has_encap() const {
  return _internal_has_encap();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& L3IfSpec::_internal_encap() const {
  const ::opi_api::network::opinetcommon::v1alpha1::Encap* p = encap_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::Encap&>(
      ::opi_api::network::opinetcommon::v1alpha1::_Encap_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& L3IfSpec::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3IfSpec.encap)
  return _internal_encap();
}
inline void L3IfSpec::unsafe_arena_set_allocated_encap(
    ::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  encap_ = encap;
  if (encap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.encap)
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* L3IfSpec::release_encap() {
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* L3IfSpec::unsafe_arena_release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3IfSpec.encap)
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* L3IfSpec::_internal_mutable_encap() {
  
  if (encap_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::Encap>(GetArenaForAllocation());
    encap_ = p;
  }
  return encap_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* L3IfSpec::mutable_encap() {
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _msg = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3IfSpec.encap)
  return _msg;
}
inline void L3IfSpec::set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  if (encap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap));
    if (message_arena != submessage_arena) {
      encap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encap, submessage_arena);
    }
    
  } else {
    
  }
  encap_ = encap;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.encap)
}

// bytes mac_address = 5;
inline void L3IfSpec::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& L3IfSpec::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3IfSpec.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L3IfSpec::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.L3IfSpec.mac_address)
}
inline std::string* L3IfSpec::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3IfSpec.mac_address)
  return _s;
}
inline const std::string& L3IfSpec::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void L3IfSpec::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* L3IfSpec::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* L3IfSpec::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3IfSpec.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void L3IfSpec::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3IfSpec.mac_address)
}

// -------------------------------------------------------------------

// BGPCommunity

// int32 asn = 1;
inline void BGPCommunity::clear_asn() {
  asn_ = 0;
}
inline int32_t BGPCommunity::_internal_asn() const {
  return asn_;
}
inline int32_t BGPCommunity::asn() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.BGPCommunity.asn)
  return _internal_asn();
}
inline void BGPCommunity::_internal_set_asn(int32_t value) {
  
  asn_ = value;
}
inline void BGPCommunity::set_asn(int32_t value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.BGPCommunity.asn)
}

// int32 community = 2;
inline void BGPCommunity::clear_community() {
  community_ = 0;
}
inline int32_t BGPCommunity::_internal_community() const {
  return community_;
}
inline int32_t BGPCommunity::community() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.BGPCommunity.community)
  return _internal_community();
}
inline void BGPCommunity::_internal_set_community(int32_t value) {
  
  community_ = value;
}
inline void BGPCommunity::set_community(int32_t value) {
  _internal_set_community(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.BGPCommunity.community)
}

// -------------------------------------------------------------------

// LoopbackIfSpec

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
inline bool LoopbackIfSpec::_internal_has_prefix() const {
  return this != internal_default_instance() && prefix_ != nullptr;
}
inline bool LoopbackIfSpec::has_prefix() const {
  return _internal_has_prefix();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& LoopbackIfSpec::_internal_prefix() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* p = prefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& LoopbackIfSpec::prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix)
  return _internal_prefix();
}
inline void LoopbackIfSpec::unsafe_arena_set_allocated_prefix(
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  prefix_ = prefix;
  if (prefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* LoopbackIfSpec::release_prefix() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* LoopbackIfSpec::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* LoopbackIfSpec::_internal_mutable_prefix() {
  
  if (prefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPPrefix>(GetArenaForAllocation());
    prefix_ = p;
  }
  return prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* LoopbackIfSpec::mutable_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix)
  return _msg;
}
inline void LoopbackIfSpec::set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  if (prefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix));
    if (message_arena != submessage_arena) {
      prefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prefix, submessage_arena);
    }
    
  } else {
    
  }
  prefix_ = prefix;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix)
}

// repeated .opi_api.network.cloud.v1alpha1.BGPCommunity communities = 2;
inline int LoopbackIfSpec::_internal_communities_size() const {
  return communities_.size();
}
inline int LoopbackIfSpec::communities_size() const {
  return _internal_communities_size();
}
inline void LoopbackIfSpec::clear_communities() {
  communities_.Clear();
}
inline ::opi_api::network::cloud::v1alpha1::BGPCommunity* LoopbackIfSpec::mutable_communities(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities)
  return communities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::BGPCommunity >*
LoopbackIfSpec::mutable_communities() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities)
  return &communities_;
}
inline const ::opi_api::network::cloud::v1alpha1::BGPCommunity& LoopbackIfSpec::_internal_communities(int index) const {
  return communities_.Get(index);
}
inline const ::opi_api::network::cloud::v1alpha1::BGPCommunity& LoopbackIfSpec::communities(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities)
  return _internal_communities(index);
}
inline ::opi_api::network::cloud::v1alpha1::BGPCommunity* LoopbackIfSpec::_internal_add_communities() {
  return communities_.Add();
}
inline ::opi_api::network::cloud::v1alpha1::BGPCommunity* LoopbackIfSpec::add_communities() {
  ::opi_api::network::cloud::v1alpha1::BGPCommunity* _add = _internal_add_communities();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::BGPCommunity >&
LoopbackIfSpec::communities() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities)
  return communities_;
}

// -------------------------------------------------------------------

// ControlIfSpec

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
inline bool ControlIfSpec::_internal_has_prefix() const {
  return this != internal_default_instance() && prefix_ != nullptr;
}
inline bool ControlIfSpec::has_prefix() const {
  return _internal_has_prefix();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& ControlIfSpec::_internal_prefix() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* p = prefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& ControlIfSpec::prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix)
  return _internal_prefix();
}
inline void ControlIfSpec::unsafe_arena_set_allocated_prefix(
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  prefix_ = prefix;
  if (prefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* ControlIfSpec::release_prefix() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* ControlIfSpec::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* ControlIfSpec::_internal_mutable_prefix() {
  
  if (prefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPPrefix>(GetArenaForAllocation());
    prefix_ = p;
  }
  return prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* ControlIfSpec::mutable_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix)
  return _msg;
}
inline void ControlIfSpec::set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  if (prefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix));
    if (message_arena != submessage_arena) {
      prefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prefix, submessage_arena);
    }
    
  } else {
    
  }
  prefix_ = prefix;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix)
}

// bytes mac_address = 2;
inline void ControlIfSpec::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& ControlIfSpec::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.ControlIfSpec.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlIfSpec::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.ControlIfSpec.mac_address)
}
inline std::string* ControlIfSpec::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.ControlIfSpec.mac_address)
  return _s;
}
inline const std::string& ControlIfSpec::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void ControlIfSpec::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlIfSpec::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlIfSpec::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.ControlIfSpec.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlIfSpec::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.ControlIfSpec.mac_address)
}

// -------------------------------------------------------------------

// HostIfSpec

// bool vf = 1;
inline void HostIfSpec::clear_vf() {
  vf_ = false;
}
inline bool HostIfSpec::_internal_vf() const {
  return vf_;
}
inline bool HostIfSpec::vf() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfSpec.vf)
  return _internal_vf();
}
inline void HostIfSpec::_internal_set_vf(bool value) {
  
  vf_ = value;
}
inline void HostIfSpec::set_vf(bool value) {
  _internal_set_vf(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfSpec.vf)
}

// bool enable_connection_tracking = 2;
inline void HostIfSpec::clear_enable_connection_tracking() {
  enable_connection_tracking_ = false;
}
inline bool HostIfSpec::_internal_enable_connection_tracking() const {
  return enable_connection_tracking_;
}
inline bool HostIfSpec::enable_connection_tracking() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfSpec.enable_connection_tracking)
  return _internal_enable_connection_tracking();
}
inline void HostIfSpec::_internal_set_enable_connection_tracking(bool value) {
  
  enable_connection_tracking_ = value;
}
inline void HostIfSpec::set_enable_connection_tracking(bool value) {
  _internal_set_enable_connection_tracking(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfSpec.enable_connection_tracking)
}

// bytes mac_address = 3;
inline void HostIfSpec::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& HostIfSpec::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfSpec.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIfSpec::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfSpec.mac_address)
}
inline std::string* HostIfSpec::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.HostIfSpec.mac_address)
  return _s;
}
inline const std::string& HostIfSpec::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void HostIfSpec::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HostIfSpec::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HostIfSpec::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.HostIfSpec.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HostIfSpec::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.HostIfSpec.mac_address)
}

// string ifname = 4;
inline void HostIfSpec::clear_ifname() {
  ifname_.ClearToEmpty();
}
inline const std::string& HostIfSpec::ifname() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfSpec.ifname)
  return _internal_ifname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIfSpec::set_ifname(ArgT0&& arg0, ArgT... args) {
 
 ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfSpec.ifname)
}
inline std::string* HostIfSpec::mutable_ifname() {
  std::string* _s = _internal_mutable_ifname();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.HostIfSpec.ifname)
  return _s;
}
inline const std::string& HostIfSpec::_internal_ifname() const {
  return ifname_.Get();
}
inline void HostIfSpec::_internal_set_ifname(const std::string& value) {
  
  ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HostIfSpec::_internal_mutable_ifname() {
  
  return ifname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HostIfSpec::release_ifname() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.HostIfSpec.ifname)
  return ifname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HostIfSpec::set_allocated_ifname(std::string* ifname) {
  if (ifname != nullptr) {
    
  } else {
    
  }
  ifname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ifname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ifname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ifname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.HostIfSpec.ifname)
}

// -------------------------------------------------------------------

// UplinkIfStatus

// int32 hw_if_idx = 1;
inline void UplinkIfStatus::clear_hw_if_idx() {
  hw_if_idx_ = 0;
}
inline int32_t UplinkIfStatus::_internal_hw_if_idx() const {
  return hw_if_idx_;
}
inline int32_t UplinkIfStatus::hw_if_idx() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkIfStatus.hw_if_idx)
  return _internal_hw_if_idx();
}
inline void UplinkIfStatus::_internal_set_hw_if_idx(int32_t value) {
  
  hw_if_idx_ = value;
}
inline void UplinkIfStatus::set_hw_if_idx(int32_t value) {
  _internal_set_hw_if_idx(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UplinkIfStatus.hw_if_idx)
}

// int32 hw_port_number = 2;
inline void UplinkIfStatus::clear_hw_port_number() {
  hw_port_number_ = 0;
}
inline int32_t UplinkIfStatus::_internal_hw_port_number() const {
  return hw_port_number_;
}
inline int32_t UplinkIfStatus::hw_port_number() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UplinkIfStatus.hw_port_number)
  return _internal_hw_port_number();
}
inline void UplinkIfStatus::_internal_set_hw_port_number(int32_t value) {
  
  hw_port_number_ = value;
}
inline void UplinkIfStatus::set_hw_port_number(int32_t value) {
  _internal_set_hw_port_number(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UplinkIfStatus.hw_port_number)
}

// -------------------------------------------------------------------

// LoopbackIfStatus

// string ifname = 1;
inline void LoopbackIfStatus::clear_ifname() {
  ifname_.ClearToEmpty();
}
inline const std::string& LoopbackIfStatus::ifname() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname)
  return _internal_ifname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoopbackIfStatus::set_ifname(ArgT0&& arg0, ArgT... args) {
 
 ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname)
}
inline std::string* LoopbackIfStatus::mutable_ifname() {
  std::string* _s = _internal_mutable_ifname();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname)
  return _s;
}
inline const std::string& LoopbackIfStatus::_internal_ifname() const {
  return ifname_.Get();
}
inline void LoopbackIfStatus::_internal_set_ifname(const std::string& value) {
  
  ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoopbackIfStatus::_internal_mutable_ifname() {
  
  return ifname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoopbackIfStatus::release_ifname() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname)
  return ifname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoopbackIfStatus::set_allocated_ifname(std::string* ifname) {
  if (ifname != nullptr) {
    
  } else {
    
  }
  ifname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ifname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ifname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ifname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname)
}

// -------------------------------------------------------------------

// HostIfStatus

// repeated bytes hw_if_idxes = 1;
inline int HostIfStatus::_internal_hw_if_idxes_size() const {
  return hw_if_idxes_.size();
}
inline int HostIfStatus::hw_if_idxes_size() const {
  return _internal_hw_if_idxes_size();
}
inline void HostIfStatus::clear_hw_if_idxes() {
  hw_if_idxes_.Clear();
}
inline std::string* HostIfStatus::add_hw_if_idxes() {
  std::string* _s = _internal_add_hw_if_idxes();
  // @@protoc_insertion_point(field_add_mutable:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
  return _s;
}
inline const std::string& HostIfStatus::_internal_hw_if_idxes(int index) const {
  return hw_if_idxes_.Get(index);
}
inline const std::string& HostIfStatus::hw_if_idxes(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
  return _internal_hw_if_idxes(index);
}
inline std::string* HostIfStatus::mutable_hw_if_idxes(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
  return hw_if_idxes_.Mutable(index);
}
inline void HostIfStatus::set_hw_if_idxes(int index, const std::string& value) {
  hw_if_idxes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::set_hw_if_idxes(int index, std::string&& value) {
  hw_if_idxes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::set_hw_if_idxes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hw_if_idxes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::set_hw_if_idxes(int index, const void* value, size_t size) {
  hw_if_idxes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline std::string* HostIfStatus::_internal_add_hw_if_idxes() {
  return hw_if_idxes_.Add();
}
inline void HostIfStatus::add_hw_if_idxes(const std::string& value) {
  hw_if_idxes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::add_hw_if_idxes(std::string&& value) {
  hw_if_idxes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::add_hw_if_idxes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hw_if_idxes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline void HostIfStatus::add_hw_if_idxes(const void* value, size_t size) {
  hw_if_idxes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HostIfStatus::hw_if_idxes() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
  return hw_if_idxes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HostIfStatus::mutable_hw_if_idxes() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.HostIfStatus.hw_if_idxes)
  return &hw_if_idxes_;
}

// bytes mac_address = 2;
inline void HostIfStatus::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& HostIfStatus::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfStatus.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIfStatus::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfStatus.mac_address)
}
inline std::string* HostIfStatus::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.HostIfStatus.mac_address)
  return _s;
}
inline const std::string& HostIfStatus::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void HostIfStatus::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HostIfStatus::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HostIfStatus::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.HostIfStatus.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HostIfStatus::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.HostIfStatus.mac_address)
}

// .opi_api.network.cloud.v1alpha1.IfStatus status = 3;
inline void HostIfStatus::clear_status() {
  status_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus HostIfStatus::_internal_status() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::IfStatus >(status_);
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus HostIfStatus::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfStatus.status)
  return _internal_status();
}
inline void HostIfStatus::_internal_set_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  
  status_ = value;
}
inline void HostIfStatus::set_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfStatus.status)
}

// string ifname = 4;
inline void HostIfStatus::clear_ifname() {
  ifname_.ClearToEmpty();
}
inline const std::string& HostIfStatus::ifname() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.HostIfStatus.ifname)
  return _internal_ifname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostIfStatus::set_ifname(ArgT0&& arg0, ArgT... args) {
 
 ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.HostIfStatus.ifname)
}
inline std::string* HostIfStatus::mutable_ifname() {
  std::string* _s = _internal_mutable_ifname();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.HostIfStatus.ifname)
  return _s;
}
inline const std::string& HostIfStatus::_internal_ifname() const {
  return ifname_.Get();
}
inline void HostIfStatus::_internal_set_ifname(const std::string& value) {
  
  ifname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HostIfStatus::_internal_mutable_ifname() {
  
  return ifname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HostIfStatus::release_ifname() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.HostIfStatus.ifname)
  return ifname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HostIfStatus::set_allocated_ifname(std::string* ifname) {
  if (ifname != nullptr) {
    
  } else {
    
  }
  ifname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ifname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ifname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ifname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.HostIfStatus.ifname)
}

// -------------------------------------------------------------------

// InterfaceStatus

// uint32 if_index = 1;
inline void InterfaceStatus::clear_if_index() {
  if_index_ = 0u;
}
inline uint32_t InterfaceStatus::_internal_if_index() const {
  return if_index_;
}
inline uint32_t InterfaceStatus::if_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceStatus.if_index)
  return _internal_if_index();
}
inline void InterfaceStatus::_internal_set_if_index(uint32_t value) {
  
  if_index_ = value;
}
inline void InterfaceStatus::set_if_index(uint32_t value) {
  _internal_set_if_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.InterfaceStatus.if_index)
}

// .opi_api.network.cloud.v1alpha1.IfStatus oper_status = 2;
inline void InterfaceStatus::clear_oper_status() {
  oper_status_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus InterfaceStatus::_internal_oper_status() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::IfStatus >(oper_status_);
}
inline ::opi_api::network::cloud::v1alpha1::IfStatus InterfaceStatus::oper_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceStatus.oper_status)
  return _internal_oper_status();
}
inline void InterfaceStatus::_internal_set_oper_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  
  oper_status_ = value;
}
inline void InterfaceStatus::set_oper_status(::opi_api::network::cloud::v1alpha1::IfStatus value) {
  _internal_set_oper_status(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.InterfaceStatus.oper_status)
}

// .opi_api.network.cloud.v1alpha1.UplinkIfStatus uplink_if_status = 3;
inline bool InterfaceStatus::_internal_has_uplink_if_status() const {
  return ifstatus_case() == kUplinkIfStatus;
}
inline bool InterfaceStatus::has_uplink_if_status() const {
  return _internal_has_uplink_if_status();
}
inline void InterfaceStatus::set_has_uplink_if_status() {
  _oneof_case_[0] = kUplinkIfStatus;
}
inline void InterfaceStatus::clear_uplink_if_status() {
  if (_internal_has_uplink_if_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifstatus_.uplink_if_status_;
    }
    clear_has_ifstatus();
  }
}
inline ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* InterfaceStatus::release_uplink_if_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
  if (_internal_has_uplink_if_status()) {
    clear_has_ifstatus();
      ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* temp = ifstatus_.uplink_if_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifstatus_.uplink_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus& InterfaceStatus::_internal_uplink_if_status() const {
  return _internal_has_uplink_if_status()
      ? *ifstatus_.uplink_if_status_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::UplinkIfStatus&>(::opi_api::network::cloud::v1alpha1::_UplinkIfStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus& InterfaceStatus::uplink_if_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
  return _internal_uplink_if_status();
}
inline ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* InterfaceStatus::unsafe_arena_release_uplink_if_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
  if (_internal_has_uplink_if_status()) {
    clear_has_ifstatus();
    ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* temp = ifstatus_.uplink_if_status_;
    ifstatus_.uplink_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceStatus::unsafe_arena_set_allocated_uplink_if_status(::opi_api::network::cloud::v1alpha1::UplinkIfStatus* uplink_if_status) {
  clear_ifstatus();
  if (uplink_if_status) {
    set_has_uplink_if_status();
    ifstatus_.uplink_if_status_ = uplink_if_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
}
inline ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* InterfaceStatus::_internal_mutable_uplink_if_status() {
  if (!_internal_has_uplink_if_status()) {
    clear_ifstatus();
    set_has_uplink_if_status();
    ifstatus_.uplink_if_status_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkIfStatus >(GetArenaForAllocation());
  }
  return ifstatus_.uplink_if_status_;
}
inline ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* InterfaceStatus::mutable_uplink_if_status() {
  ::opi_api::network::cloud::v1alpha1::UplinkIfStatus* _msg = _internal_mutable_uplink_if_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.LoopbackIfStatus loopback_if_status = 4;
inline bool InterfaceStatus::_internal_has_loopback_if_status() const {
  return ifstatus_case() == kLoopbackIfStatus;
}
inline bool InterfaceStatus::has_loopback_if_status() const {
  return _internal_has_loopback_if_status();
}
inline void InterfaceStatus::set_has_loopback_if_status() {
  _oneof_case_[0] = kLoopbackIfStatus;
}
inline void InterfaceStatus::clear_loopback_if_status() {
  if (_internal_has_loopback_if_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifstatus_.loopback_if_status_;
    }
    clear_has_ifstatus();
  }
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* InterfaceStatus::release_loopback_if_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
  if (_internal_has_loopback_if_status()) {
    clear_has_ifstatus();
      ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* temp = ifstatus_.loopback_if_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifstatus_.loopback_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus& InterfaceStatus::_internal_loopback_if_status() const {
  return _internal_has_loopback_if_status()
      ? *ifstatus_.loopback_if_status_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus&>(::opi_api::network::cloud::v1alpha1::_LoopbackIfStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus& InterfaceStatus::loopback_if_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
  return _internal_loopback_if_status();
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* InterfaceStatus::unsafe_arena_release_loopback_if_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
  if (_internal_has_loopback_if_status()) {
    clear_has_ifstatus();
    ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* temp = ifstatus_.loopback_if_status_;
    ifstatus_.loopback_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceStatus::unsafe_arena_set_allocated_loopback_if_status(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* loopback_if_status) {
  clear_ifstatus();
  if (loopback_if_status) {
    set_has_loopback_if_status();
    ifstatus_.loopback_if_status_ = loopback_if_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* InterfaceStatus::_internal_mutable_loopback_if_status() {
  if (!_internal_has_loopback_if_status()) {
    clear_ifstatus();
    set_has_loopback_if_status();
    ifstatus_.loopback_if_status_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus >(GetArenaForAllocation());
  }
  return ifstatus_.loopback_if_status_;
}
inline ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* InterfaceStatus::mutable_loopback_if_status() {
  ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* _msg = _internal_mutable_loopback_if_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.HostIfStatus host_if_status = 5;
inline bool InterfaceStatus::_internal_has_host_if_status() const {
  return ifstatus_case() == kHostIfStatus;
}
inline bool InterfaceStatus::has_host_if_status() const {
  return _internal_has_host_if_status();
}
inline void InterfaceStatus::set_has_host_if_status() {
  _oneof_case_[0] = kHostIfStatus;
}
inline void InterfaceStatus::clear_host_if_status() {
  if (_internal_has_host_if_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ifstatus_.host_if_status_;
    }
    clear_has_ifstatus();
  }
}
inline ::opi_api::network::cloud::v1alpha1::HostIfStatus* InterfaceStatus::release_host_if_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
  if (_internal_has_host_if_status()) {
    clear_has_ifstatus();
      ::opi_api::network::cloud::v1alpha1::HostIfStatus* temp = ifstatus_.host_if_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ifstatus_.host_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::HostIfStatus& InterfaceStatus::_internal_host_if_status() const {
  return _internal_has_host_if_status()
      ? *ifstatus_.host_if_status_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::HostIfStatus&>(::opi_api::network::cloud::v1alpha1::_HostIfStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::HostIfStatus& InterfaceStatus::host_if_status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
  return _internal_host_if_status();
}
inline ::opi_api::network::cloud::v1alpha1::HostIfStatus* InterfaceStatus::unsafe_arena_release_host_if_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
  if (_internal_has_host_if_status()) {
    clear_has_ifstatus();
    ::opi_api::network::cloud::v1alpha1::HostIfStatus* temp = ifstatus_.host_if_status_;
    ifstatus_.host_if_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterfaceStatus::unsafe_arena_set_allocated_host_if_status(::opi_api::network::cloud::v1alpha1::HostIfStatus* host_if_status) {
  clear_ifstatus();
  if (host_if_status) {
    set_has_host_if_status();
    ifstatus_.host_if_status_ = host_if_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
}
inline ::opi_api::network::cloud::v1alpha1::HostIfStatus* InterfaceStatus::_internal_mutable_host_if_status() {
  if (!_internal_has_host_if_status()) {
    clear_ifstatus();
    set_has_host_if_status();
    ifstatus_.host_if_status_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::HostIfStatus >(GetArenaForAllocation());
  }
  return ifstatus_.host_if_status_;
}
inline ::opi_api::network::cloud::v1alpha1::HostIfStatus* InterfaceStatus::mutable_host_if_status() {
  ::opi_api::network::cloud::v1alpha1::HostIfStatus* _msg = _internal_mutable_host_if_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
  return _msg;
}

inline bool InterfaceStatus::has_ifstatus() const {
  return ifstatus_case() != IFSTATUS_NOT_SET;
}
inline void InterfaceStatus::clear_has_ifstatus() {
  _oneof_case_[0] = IFSTATUS_NOT_SET;
}
inline InterfaceStatus::IfstatusCase InterfaceStatus::ifstatus_case() const {
  return InterfaceStatus::IfstatusCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::IfType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::IfType>() {
  return ::opi_api::network::cloud::v1alpha1::IfType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::IfStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::IfStatus>() {
  return ::opi_api::network::cloud::v1alpha1::IfStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
