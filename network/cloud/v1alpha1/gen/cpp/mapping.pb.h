// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mapping.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "object_key.pb.h"
#include "networktypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mapping_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mapping_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mapping_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class L2MappingKey;
struct L2MappingKeyDefaultTypeInternal;
extern L2MappingKeyDefaultTypeInternal _L2MappingKey_default_instance_;
class L3MappingKey;
struct L3MappingKeyDefaultTypeInternal;
extern L3MappingKeyDefaultTypeInternal _L3MappingKey_default_instance_;
class Mapping;
struct MappingDefaultTypeInternal;
extern MappingDefaultTypeInternal _Mapping_default_instance_;
class MappingLookupFilter;
struct MappingLookupFilterDefaultTypeInternal;
extern MappingLookupFilterDefaultTypeInternal _MappingLookupFilter_default_instance_;
class MappingSpec;
struct MappingSpecDefaultTypeInternal;
extern MappingSpecDefaultTypeInternal _MappingSpec_default_instance_;
class MappingStatus;
struct MappingStatusDefaultTypeInternal;
extern MappingStatusDefaultTypeInternal _MappingStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::L2MappingKey* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::L2MappingKey>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::L3MappingKey* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::L3MappingKey>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::Mapping* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::Mapping>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingLookupFilter* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingLookupFilter>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum MappingType : int {
  MAPPING_TYPE_UNSPECIFIED = 0,
  MAPPING_TYPE_VPC = 1,
  MAPPING_TYPE_SERVICE = 2,
  MAPPING_TYPE_LB_VIP = 3,
  MappingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MappingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MappingType_IsValid(int value);
constexpr MappingType MappingType_MIN = MAPPING_TYPE_UNSPECIFIED;
constexpr MappingType MappingType_MAX = MAPPING_TYPE_LB_VIP;
constexpr int MappingType_ARRAYSIZE = MappingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MappingType_descriptor();
template<typename T>
inline const std::string& MappingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MappingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MappingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MappingType_descriptor(), enum_t_value);
}
inline bool MappingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MappingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MappingType>(
    MappingType_descriptor(), name, value);
}
enum MappingKeyType : int {
  MAPPING_KEY_TYPE_UNSPECIFIED = 0,
  MAPPING_KEY_TYPE_L2 = 1,
  MAPPING_KEY_TYPE_L3 = 2,
  MappingKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MappingKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MappingKeyType_IsValid(int value);
constexpr MappingKeyType MappingKeyType_MIN = MAPPING_KEY_TYPE_UNSPECIFIED;
constexpr MappingKeyType MappingKeyType_MAX = MAPPING_KEY_TYPE_L3;
constexpr int MappingKeyType_ARRAYSIZE = MappingKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MappingKeyType_descriptor();
template<typename T>
inline const std::string& MappingKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MappingKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MappingKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MappingKeyType_descriptor(), enum_t_value);
}
inline bool MappingKeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MappingKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MappingKeyType>(
    MappingKeyType_descriptor(), name, value);
}
// ===================================================================

class Mapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.Mapping) */ {
 public:
  inline Mapping() : Mapping(nullptr) {}
  ~Mapping() override;
  explicit constexpr Mapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mapping(const Mapping& from);
  Mapping(Mapping&& from) noexcept
    : Mapping() {
    *this = ::std::move(from);
  }

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mapping& operator=(Mapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mapping* internal_default_instance() {
    return reinterpret_cast<const Mapping*>(
               &_Mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Mapping& a, Mapping& b) {
    a.Swap(&b);
  }
  inline void Swap(Mapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Mapping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.Mapping";
  }
  protected:
  explicit Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.network.cloud.v1alpha1.MappingSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::MappingSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::MappingSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::MappingSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::MappingSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::MappingSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::MappingSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::MappingSpec* spec);
  ::opi_api::network::cloud::v1alpha1::MappingSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.MappingStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::MappingStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::MappingStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::MappingStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::MappingStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::MappingStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::MappingStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::MappingStatus* status);
  ::opi_api::network::cloud::v1alpha1::MappingStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.Mapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::network::cloud::v1alpha1::MappingSpec* spec_;
  ::opi_api::network::cloud::v1alpha1::MappingStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingSpec) */ {
 public:
  inline MappingSpec() : MappingSpec(nullptr) {}
  ~MappingSpec() override;
  explicit constexpr MappingSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingSpec(const MappingSpec& from);
  MappingSpec(MappingSpec&& from) noexcept
    : MappingSpec() {
    *this = ::std::move(from);
  }

  inline MappingSpec& operator=(const MappingSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingSpec& operator=(MappingSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingSpec& default_instance() {
    return *internal_default_instance();
  }
  enum MacOrIpCase {
    kIpKey = 2,
    kMacKey = 3,
    MAC_OR_IP_NOT_SET = 0,
  };

  enum DstinfoCase {
    kVnicId = 5,
    kTunnelId = 6,
    kNhGroupId = 7,
    DSTINFO_NOT_SET = 0,
  };

  static inline const MappingSpec* internal_default_instance() {
    return reinterpret_cast<const MappingSpec*>(
               &_MappingSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MappingSpec& a, MappingSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MappingSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingSpec";
  }
  protected:
  explicit MappingSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 11,
    kMacAddrFieldNumber = 8,
    kIdFieldNumber = 1,
    kSubnetIdFieldNumber = 4,
    kEncapFieldNumber = 9,
    kPublicIpFieldNumber = 10,
    kTypeFieldNumber = 12,
    kIpKeyFieldNumber = 2,
    kMacKeyFieldNumber = 3,
    kVnicIdFieldNumber = 5,
    kTunnelIdFieldNumber = 6,
    kNhGroupIdFieldNumber = 7,
  };
  // repeated uint32 tags = 11;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  uint32_t _internal_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_tags() const;
  void _internal_add_tags(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_tags();
  public:
  uint32_t tags(int index) const;
  void set_tags(int index, uint32_t value);
  void add_tags(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_tags();

  // bytes mac_addr = 8;
  void clear_mac_addr();
  const std::string& mac_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_addr();
  PROTOBUF_NODISCARD std::string* release_mac_addr();
  void set_allocated_mac_addr(std::string* mac_addr);
  private:
  const std::string& _internal_mac_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_addr(const std::string& value);
  std::string* _internal_mutable_mac_addr();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subnet_id = 4;
  bool has_subnet_id() const;
  private:
  bool _internal_has_subnet_id() const;
  public:
  void clear_subnet_id();
  const ::opi_api::common::v1::ObjectKey& subnet_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subnet_id();
  ::opi_api::common::v1::ObjectKey* mutable_subnet_id();
  void set_allocated_subnet_id(::opi_api::common::v1::ObjectKey* subnet_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subnet_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subnet_id();
  public:
  void unsafe_arena_set_allocated_subnet_id(
      ::opi_api::common::v1::ObjectKey* subnet_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subnet_id();

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 9;
  bool has_encap() const;
  private:
  bool _internal_has_encap() const;
  public:
  void clear_encap();
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& encap() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::Encap* release_encap();
  ::opi_api::network::opinetcommon::v1alpha1::Encap* mutable_encap();
  void set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& _internal_encap() const;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _internal_mutable_encap();
  public:
  void unsafe_arena_set_allocated_encap(
      ::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  ::opi_api::network::opinetcommon::v1alpha1::Encap* unsafe_arena_release_encap();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress public_ip = 10;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_public_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_public_ip();
  void set_allocated_public_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_public_ip() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_public_ip();

  // .opi_api.network.cloud.v1alpha1.MappingType type = 12;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::MappingType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  public:

  // .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 2;
  bool has_ip_key() const;
  private:
  bool _internal_has_ip_key() const;
  public:
  void clear_ip_key();
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& ip_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L3MappingKey* release_ip_key();
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* mutable_ip_key();
  void set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& _internal_ip_key() const;
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _internal_mutable_ip_key();
  public:
  void unsafe_arena_set_allocated_ip_key(
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* unsafe_arena_release_ip_key();

  // .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 3;
  bool has_mac_key() const;
  private:
  bool _internal_has_mac_key() const;
  public:
  void clear_mac_key();
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& mac_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L2MappingKey* release_mac_key();
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* mutable_mac_key();
  void set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& _internal_mac_key() const;
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _internal_mutable_mac_key();
  public:
  void unsafe_arena_set_allocated_mac_key(
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* unsafe_arena_release_mac_key();

  // .opi_api.common.v1.ObjectKey vnic_id = 5;
  bool has_vnic_id() const;
  private:
  bool _internal_has_vnic_id() const;
  public:
  void clear_vnic_id();
  const ::opi_api::common::v1::ObjectKey& vnic_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_vnic_id();
  ::opi_api::common::v1::ObjectKey* mutable_vnic_id();
  void set_allocated_vnic_id(::opi_api::common::v1::ObjectKey* vnic_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_vnic_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_vnic_id();
  public:
  void unsafe_arena_set_allocated_vnic_id(
      ::opi_api::common::v1::ObjectKey* vnic_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_vnic_id();

  // .opi_api.common.v1.ObjectKey tunnel_id = 6;
  bool has_tunnel_id() const;
  private:
  bool _internal_has_tunnel_id() const;
  public:
  void clear_tunnel_id();
  const ::opi_api::common::v1::ObjectKey& tunnel_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_tunnel_id();
  ::opi_api::common::v1::ObjectKey* mutable_tunnel_id();
  void set_allocated_tunnel_id(::opi_api::common::v1::ObjectKey* tunnel_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_tunnel_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_tunnel_id();
  public:
  void unsafe_arena_set_allocated_tunnel_id(
      ::opi_api::common::v1::ObjectKey* tunnel_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_tunnel_id();

  // .opi_api.common.v1.ObjectKey nh_group_id = 7;
  bool has_nh_group_id() const;
  private:
  bool _internal_has_nh_group_id() const;
  public:
  void clear_nh_group_id();
  const ::opi_api::common::v1::ObjectKey& nh_group_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_nh_group_id();
  ::opi_api::common::v1::ObjectKey* mutable_nh_group_id();
  void set_allocated_nh_group_id(::opi_api::common::v1::ObjectKey* nh_group_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_nh_group_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_nh_group_id();
  public:
  void unsafe_arena_set_allocated_nh_group_id(
      ::opi_api::common::v1::ObjectKey* nh_group_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_nh_group_id();

  void clear_mac_or_ip();
  MacOrIpCase mac_or_ip_case() const;
  void clear_dstinfo();
  DstinfoCase dstinfo_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingSpec)
 private:
  class _Internal;
  void set_has_ip_key();
  void set_has_mac_key();
  void set_has_vnic_id();
  void set_has_tunnel_id();
  void set_has_nh_group_id();

  inline bool has_mac_or_ip() const;
  inline void clear_has_mac_or_ip();

  inline bool has_dstinfo() const;
  inline void clear_has_dstinfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > tags_;
  mutable std::atomic<int> _tags_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_addr_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subnet_id_;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* encap_;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip_;
  int type_;
  union MacOrIpUnion {
    constexpr MacOrIpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key_;
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key_;
  } mac_or_ip_;
  union DstinfoUnion {
    constexpr DstinfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::common::v1::ObjectKey* vnic_id_;
    ::opi_api::common::v1::ObjectKey* tunnel_id_;
    ::opi_api::common::v1::ObjectKey* nh_group_id_;
  } dstinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingStatus) */ {
 public:
  inline MappingStatus() : MappingStatus(nullptr) {}
  ~MappingStatus() override;
  explicit constexpr MappingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingStatus(const MappingStatus& from);
  MappingStatus(MappingStatus&& from) noexcept
    : MappingStatus() {
    *this = ::std::move(from);
  }

  inline MappingStatus& operator=(const MappingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingStatus& operator=(MappingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const MappingStatus* internal_default_instance() {
    return reinterpret_cast<const MappingStatus*>(
               &_MappingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MappingStatus& a, MappingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MappingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingStatus";
  }
  protected:
  explicit MappingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelIpFieldNumber = 3,
    kSvcPortMapHwHandleFieldNumber = 4,
    kVnfTunnelHwHandleFieldNumber = 5,
    kPublicNatIndexFieldNumber = 1,
    kPrivateNatIndexFieldNumber = 2,
    kRewriteIndexFieldNumber = 6,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 3;
  int tunnel_ip_size() const;
  private:
  int _internal_tunnel_ip_size() const;
  public:
  void clear_tunnel_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_tunnel_ip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
      mutable_tunnel_ip();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_tunnel_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_add_tunnel_ip();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& tunnel_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* add_tunnel_ip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
      tunnel_ip() const;

  // .opi_api.network.opinetcommon.v1alpha1.HwHandle svc_port_map_hw_handle = 4;
  bool has_svc_port_map_hw_handle() const;
  private:
  bool _internal_has_svc_port_map_hw_handle() const;
  public:
  void clear_svc_port_map_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& svc_port_map_hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_svc_port_map_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_svc_port_map_hw_handle();
  void set_allocated_svc_port_map_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_svc_port_map_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_svc_port_map_hw_handle();
  public:
  void unsafe_arena_set_allocated_svc_port_map_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_svc_port_map_hw_handle();

  // .opi_api.network.opinetcommon.v1alpha1.HwHandle vnf_tunnel_hw_handle = 5;
  bool has_vnf_tunnel_hw_handle() const;
  private:
  bool _internal_has_vnf_tunnel_hw_handle() const;
  public:
  void clear_vnf_tunnel_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& vnf_tunnel_hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_vnf_tunnel_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_vnf_tunnel_hw_handle();
  void set_allocated_vnf_tunnel_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_vnf_tunnel_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_vnf_tunnel_hw_handle();
  public:
  void unsafe_arena_set_allocated_vnf_tunnel_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_vnf_tunnel_hw_handle();

  // int32 public_nat_index = 1;
  void clear_public_nat_index();
  int32_t public_nat_index() const;
  void set_public_nat_index(int32_t value);
  private:
  int32_t _internal_public_nat_index() const;
  void _internal_set_public_nat_index(int32_t value);
  public:

  // int32 private_nat_index = 2;
  void clear_private_nat_index();
  int32_t private_nat_index() const;
  void set_private_nat_index(int32_t value);
  private:
  int32_t _internal_private_nat_index() const;
  void _internal_set_private_nat_index(int32_t value);
  public:

  // int32 rewrite_index = 6;
  void clear_rewrite_index();
  int32_t rewrite_index() const;
  void set_rewrite_index(int32_t value);
  private:
  int32_t _internal_rewrite_index() const;
  void _internal_set_rewrite_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress > tunnel_ip_;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle_;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle_;
  int32_t public_nat_index_;
  int32_t private_nat_index_;
  int32_t rewrite_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class L3MappingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.L3MappingKey) */ {
 public:
  inline L3MappingKey() : L3MappingKey(nullptr) {}
  ~L3MappingKey() override;
  explicit constexpr L3MappingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L3MappingKey(const L3MappingKey& from);
  L3MappingKey(L3MappingKey&& from) noexcept
    : L3MappingKey() {
    *this = ::std::move(from);
  }

  inline L3MappingKey& operator=(const L3MappingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline L3MappingKey& operator=(L3MappingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L3MappingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const L3MappingKey* internal_default_instance() {
    return reinterpret_cast<const L3MappingKey*>(
               &_L3MappingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(L3MappingKey& a, L3MappingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(L3MappingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L3MappingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L3MappingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L3MappingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L3MappingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const L3MappingKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L3MappingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.L3MappingKey";
  }
  protected:
  explicit L3MappingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpcIdFieldNumber = 1,
    kIpAddressFieldNumber = 2,
  };
  // .opi_api.common.v1.ObjectKey vpc_id = 1;
  bool has_vpc_id() const;
  private:
  bool _internal_has_vpc_id() const;
  public:
  void clear_vpc_id();
  const ::opi_api::common::v1::ObjectKey& vpc_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_vpc_id();
  ::opi_api::common::v1::ObjectKey* mutable_vpc_id();
  void set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_vpc_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_vpc_id();
  public:
  void unsafe_arena_set_allocated_vpc_id(
      ::opi_api::common::v1::ObjectKey* vpc_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_vpc_id();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& ip_address() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_ip_address();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_ip_address() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_ip_address();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.L3MappingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* vpc_id_;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class L2MappingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.L2MappingKey) */ {
 public:
  inline L2MappingKey() : L2MappingKey(nullptr) {}
  ~L2MappingKey() override;
  explicit constexpr L2MappingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L2MappingKey(const L2MappingKey& from);
  L2MappingKey(L2MappingKey&& from) noexcept
    : L2MappingKey() {
    *this = ::std::move(from);
  }

  inline L2MappingKey& operator=(const L2MappingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline L2MappingKey& operator=(L2MappingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L2MappingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const L2MappingKey* internal_default_instance() {
    return reinterpret_cast<const L2MappingKey*>(
               &_L2MappingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(L2MappingKey& a, L2MappingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(L2MappingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L2MappingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L2MappingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L2MappingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L2MappingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const L2MappingKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L2MappingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.L2MappingKey";
  }
  protected:
  explicit L2MappingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 2,
    kSubnetIdFieldNumber = 1,
  };
  // bytes mac_address = 2;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // .opi_api.common.v1.ObjectKey subnet_id = 1;
  bool has_subnet_id() const;
  private:
  bool _internal_has_subnet_id() const;
  public:
  void clear_subnet_id();
  const ::opi_api::common::v1::ObjectKey& subnet_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subnet_id();
  ::opi_api::common::v1::ObjectKey* mutable_subnet_id();
  void set_allocated_subnet_id(::opi_api::common::v1::ObjectKey* subnet_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subnet_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subnet_id();
  public:
  void unsafe_arena_set_allocated_subnet_id(
      ::opi_api::common::v1::ObjectKey* subnet_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subnet_id();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.L2MappingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::opi_api::common::v1::ObjectKey* subnet_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingLookupFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingLookupFilter) */ {
 public:
  inline MappingLookupFilter() : MappingLookupFilter(nullptr) {}
  ~MappingLookupFilter() override;
  explicit constexpr MappingLookupFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingLookupFilter(const MappingLookupFilter& from);
  MappingLookupFilter(MappingLookupFilter&& from) noexcept
    : MappingLookupFilter() {
    *this = ::std::move(from);
  }

  inline MappingLookupFilter& operator=(const MappingLookupFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingLookupFilter& operator=(MappingLookupFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingLookupFilter& default_instance() {
    return *internal_default_instance();
  }
  enum IpOrMacCase {
    kIpKey = 4,
    kMacKey = 5,
    kIpAddress = 6,
    kMacAddress = 7,
    kVpcId = 8,
    IP_OR_MAC_NOT_SET = 0,
  };

  static inline const MappingLookupFilter* internal_default_instance() {
    return reinterpret_cast<const MappingLookupFilter*>(
               &_MappingLookupFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MappingLookupFilter& a, MappingLookupFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingLookupFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingLookupFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingLookupFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingLookupFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingLookupFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MappingLookupFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingLookupFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingLookupFilter";
  }
  protected:
  explicit MappingLookupFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalFieldNumber = 1,
    kKeyTypeFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIpKeyFieldNumber = 4,
    kMacKeyFieldNumber = 5,
    kIpAddressFieldNumber = 6,
    kMacAddressFieldNumber = 7,
    kVpcIdFieldNumber = 8,
  };
  // bool local = 1;
  void clear_local();
  bool local() const;
  void set_local(bool value);
  private:
  bool _internal_local() const;
  void _internal_set_local(bool value);
  public:

  // .opi_api.network.cloud.v1alpha1.MappingKeyType key_type = 2;
  void clear_key_type();
  ::opi_api::network::cloud::v1alpha1::MappingKeyType key_type() const;
  void set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingKeyType _internal_key_type() const;
  void _internal_set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value);
  public:

  // .opi_api.network.cloud.v1alpha1.MappingType type = 3;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::MappingType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  public:

  // .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 4;
  bool has_ip_key() const;
  private:
  bool _internal_has_ip_key() const;
  public:
  void clear_ip_key();
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& ip_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L3MappingKey* release_ip_key();
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* mutable_ip_key();
  void set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& _internal_ip_key() const;
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _internal_mutable_ip_key();
  public:
  void unsafe_arena_set_allocated_ip_key(
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* unsafe_arena_release_ip_key();

  // .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 5;
  bool has_mac_key() const;
  private:
  bool _internal_has_mac_key() const;
  public:
  void clear_mac_key();
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& mac_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L2MappingKey* release_mac_key();
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* mutable_mac_key();
  void set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& _internal_mac_key() const;
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _internal_mutable_mac_key();
  public:
  void unsafe_arena_set_allocated_mac_key(
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* unsafe_arena_release_mac_key();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 6;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& ip_address() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_ip_address();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_ip_address() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_ip_address();

  // bytes mac_address = 7;
  bool has_mac_address() const;
  private:
  bool _internal_has_mac_address() const;
  public:
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // .opi_api.common.v1.ObjectKey vpc_id = 8;
  bool has_vpc_id() const;
  private:
  bool _internal_has_vpc_id() const;
  public:
  void clear_vpc_id();
  const ::opi_api::common::v1::ObjectKey& vpc_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_vpc_id();
  ::opi_api::common::v1::ObjectKey* mutable_vpc_id();
  void set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_vpc_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_vpc_id();
  public:
  void unsafe_arena_set_allocated_vpc_id(
      ::opi_api::common::v1::ObjectKey* vpc_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_vpc_id();

  void clear_ip_or_mac();
  IpOrMacCase ip_or_mac_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingLookupFilter)
 private:
  class _Internal;
  void set_has_ip_key();
  void set_has_mac_key();
  void set_has_ip_address();
  void set_has_mac_address();
  void set_has_vpc_id();

  inline bool has_ip_or_mac() const;
  inline void clear_has_ip_or_mac();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool local_;
  int key_type_;
  int type_;
  union IpOrMacUnion {
    constexpr IpOrMacUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key_;
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key_;
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
    ::opi_api::common::v1::ObjectKey* vpc_id_;
  } ip_or_mac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_mapping_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Mapping

// .opi_api.network.cloud.v1alpha1.MappingSpec spec = 1;
inline bool Mapping::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Mapping::has_spec() const {
  return _internal_has_spec();
}
inline void Mapping::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::MappingSpec& Mapping::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::MappingSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::MappingSpec&>(
      ::opi_api::network::cloud::v1alpha1::_MappingSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::MappingSpec& Mapping::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Mapping.spec)
  return _internal_spec();
}
inline void Mapping::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::MappingSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.spec)
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::MappingSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Mapping.spec)
  
  ::opi_api::network::cloud::v1alpha1::MappingSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::MappingSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Mapping.spec)
  return _msg;
}
inline void Mapping::set_allocated_spec(::opi_api::network::cloud::v1alpha1::MappingSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::MappingSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.spec)
}

// .opi_api.network.cloud.v1alpha1.MappingStatus status = 2;
inline bool Mapping::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Mapping::has_status() const {
  return _internal_has_status();
}
inline void Mapping::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::MappingStatus& Mapping::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::MappingStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::MappingStatus&>(
      ::opi_api::network::cloud::v1alpha1::_MappingStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::MappingStatus& Mapping::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Mapping.status)
  return _internal_status();
}
inline void Mapping::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::MappingStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.status)
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::MappingStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Mapping.status)
  
  ::opi_api::network::cloud::v1alpha1::MappingStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::MappingStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Mapping.status)
  return _msg;
}
inline void Mapping::set_allocated_status(::opi_api::network::cloud::v1alpha1::MappingStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::MappingStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.status)
}

// -------------------------------------------------------------------

// MappingSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool MappingSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool MappingSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.id)
  return _internal_id();
}
inline void MappingSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.id)
  return _msg;
}
inline void MappingSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.id)
}

// .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 2;
inline bool MappingSpec::_internal_has_ip_key() const {
  return mac_or_ip_case() == kIpKey;
}
inline bool MappingSpec::has_ip_key() const {
  return _internal_has_ip_key();
}
inline void MappingSpec::set_has_ip_key() {
  _oneof_case_[0] = kIpKey;
}
inline void MappingSpec::clear_ip_key() {
  if (_internal_has_ip_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete mac_or_ip_.ip_key_;
    }
    clear_has_mac_or_ip();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::release_ip_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_mac_or_ip();
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = mac_or_ip_.ip_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mac_or_ip_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingSpec::_internal_ip_key() const {
  return _internal_has_ip_key()
      ? *mac_or_ip_.ip_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L3MappingKey&>(::opi_api::network::cloud::v1alpha1::_L3MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingSpec::ip_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  return _internal_ip_key();
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::unsafe_arena_release_ip_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = mac_or_ip_.ip_key_;
    mac_or_ip_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key) {
  clear_mac_or_ip();
  if (ip_key) {
    set_has_ip_key();
    mac_or_ip_.ip_key_ = ip_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::_internal_mutable_ip_key() {
  if (!_internal_has_ip_key()) {
    clear_mac_or_ip();
    set_has_ip_key();
    mac_or_ip_.ip_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3MappingKey >(GetArenaForAllocation());
  }
  return mac_or_ip_.ip_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::mutable_ip_key() {
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _msg = _internal_mutable_ip_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 3;
inline bool MappingSpec::_internal_has_mac_key() const {
  return mac_or_ip_case() == kMacKey;
}
inline bool MappingSpec::has_mac_key() const {
  return _internal_has_mac_key();
}
inline void MappingSpec::set_has_mac_key() {
  _oneof_case_[0] = kMacKey;
}
inline void MappingSpec::clear_mac_key() {
  if (_internal_has_mac_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete mac_or_ip_.mac_key_;
    }
    clear_has_mac_or_ip();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::release_mac_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_mac_or_ip();
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = mac_or_ip_.mac_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mac_or_ip_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingSpec::_internal_mac_key() const {
  return _internal_has_mac_key()
      ? *mac_or_ip_.mac_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L2MappingKey&>(::opi_api::network::cloud::v1alpha1::_L2MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingSpec::mac_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  return _internal_mac_key();
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::unsafe_arena_release_mac_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = mac_or_ip_.mac_key_;
    mac_or_ip_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key) {
  clear_mac_or_ip();
  if (mac_key) {
    set_has_mac_key();
    mac_or_ip_.mac_key_ = mac_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::_internal_mutable_mac_key() {
  if (!_internal_has_mac_key()) {
    clear_mac_or_ip();
    set_has_mac_key();
    mac_or_ip_.mac_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L2MappingKey >(GetArenaForAllocation());
  }
  return mac_or_ip_.mac_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::mutable_mac_key() {
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _msg = _internal_mutable_mac_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  return _msg;
}

// .opi_api.common.v1.ObjectKey subnet_id = 4;
inline bool MappingSpec::_internal_has_subnet_id() const {
  return this != internal_default_instance() && subnet_id_ != nullptr;
}
inline bool MappingSpec::has_subnet_id() const {
  return _internal_has_subnet_id();
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::_internal_subnet_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subnet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::subnet_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id)
  return _internal_subnet_id();
}
inline void MappingSpec::unsafe_arena_set_allocated_subnet_id(
    ::opi_api::common::v1::ObjectKey* subnet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id_);
  }
  subnet_id_ = subnet_id;
  if (subnet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id)
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::release_subnet_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subnet_id_;
  subnet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::unsafe_arena_release_subnet_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subnet_id_;
  subnet_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::_internal_mutable_subnet_id() {
  
  if (subnet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subnet_id_ = p;
  }
  return subnet_id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::mutable_subnet_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subnet_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id)
  return _msg;
}
inline void MappingSpec::set_allocated_subnet_id(::opi_api::common::v1::ObjectKey* subnet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id_);
  }
  if (subnet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id));
    if (message_arena != submessage_arena) {
      subnet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnet_id, submessage_arena);
    }
    
  } else {
    
  }
  subnet_id_ = subnet_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id)
}

// .opi_api.common.v1.ObjectKey vnic_id = 5;
inline bool MappingSpec::_internal_has_vnic_id() const {
  return dstinfo_case() == kVnicId;
}
inline bool MappingSpec::has_vnic_id() const {
  return _internal_has_vnic_id();
}
inline void MappingSpec::set_has_vnic_id() {
  _oneof_case_[1] = kVnicId;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::release_vnic_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id)
  if (_internal_has_vnic_id()) {
    clear_has_dstinfo();
      ::opi_api::common::v1::ObjectKey* temp = dstinfo_.vnic_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstinfo_.vnic_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::_internal_vnic_id() const {
  return _internal_has_vnic_id()
      ? *dstinfo_.vnic_id_
      : reinterpret_cast< ::opi_api::common::v1::ObjectKey&>(::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::vnic_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id)
  return _internal_vnic_id();
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::unsafe_arena_release_vnic_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id)
  if (_internal_has_vnic_id()) {
    clear_has_dstinfo();
    ::opi_api::common::v1::ObjectKey* temp = dstinfo_.vnic_id_;
    dstinfo_.vnic_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_vnic_id(::opi_api::common::v1::ObjectKey* vnic_id) {
  clear_dstinfo();
  if (vnic_id) {
    set_has_vnic_id();
    dstinfo_.vnic_id_ = vnic_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id)
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::_internal_mutable_vnic_id() {
  if (!_internal_has_vnic_id()) {
    clear_dstinfo();
    set_has_vnic_id();
    dstinfo_.vnic_id_ = CreateMaybeMessage< ::opi_api::common::v1::ObjectKey >(GetArenaForAllocation());
  }
  return dstinfo_.vnic_id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::mutable_vnic_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_vnic_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id)
  return _msg;
}

// .opi_api.common.v1.ObjectKey tunnel_id = 6;
inline bool MappingSpec::_internal_has_tunnel_id() const {
  return dstinfo_case() == kTunnelId;
}
inline bool MappingSpec::has_tunnel_id() const {
  return _internal_has_tunnel_id();
}
inline void MappingSpec::set_has_tunnel_id() {
  _oneof_case_[1] = kTunnelId;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::release_tunnel_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id)
  if (_internal_has_tunnel_id()) {
    clear_has_dstinfo();
      ::opi_api::common::v1::ObjectKey* temp = dstinfo_.tunnel_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstinfo_.tunnel_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::_internal_tunnel_id() const {
  return _internal_has_tunnel_id()
      ? *dstinfo_.tunnel_id_
      : reinterpret_cast< ::opi_api::common::v1::ObjectKey&>(::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::tunnel_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id)
  return _internal_tunnel_id();
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::unsafe_arena_release_tunnel_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id)
  if (_internal_has_tunnel_id()) {
    clear_has_dstinfo();
    ::opi_api::common::v1::ObjectKey* temp = dstinfo_.tunnel_id_;
    dstinfo_.tunnel_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_tunnel_id(::opi_api::common::v1::ObjectKey* tunnel_id) {
  clear_dstinfo();
  if (tunnel_id) {
    set_has_tunnel_id();
    dstinfo_.tunnel_id_ = tunnel_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id)
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::_internal_mutable_tunnel_id() {
  if (!_internal_has_tunnel_id()) {
    clear_dstinfo();
    set_has_tunnel_id();
    dstinfo_.tunnel_id_ = CreateMaybeMessage< ::opi_api::common::v1::ObjectKey >(GetArenaForAllocation());
  }
  return dstinfo_.tunnel_id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::mutable_tunnel_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_tunnel_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id)
  return _msg;
}

// .opi_api.common.v1.ObjectKey nh_group_id = 7;
inline bool MappingSpec::_internal_has_nh_group_id() const {
  return dstinfo_case() == kNhGroupId;
}
inline bool MappingSpec::has_nh_group_id() const {
  return _internal_has_nh_group_id();
}
inline void MappingSpec::set_has_nh_group_id() {
  _oneof_case_[1] = kNhGroupId;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::release_nh_group_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id)
  if (_internal_has_nh_group_id()) {
    clear_has_dstinfo();
      ::opi_api::common::v1::ObjectKey* temp = dstinfo_.nh_group_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    dstinfo_.nh_group_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::_internal_nh_group_id() const {
  return _internal_has_nh_group_id()
      ? *dstinfo_.nh_group_id_
      : reinterpret_cast< ::opi_api::common::v1::ObjectKey&>(::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingSpec::nh_group_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id)
  return _internal_nh_group_id();
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::unsafe_arena_release_nh_group_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id)
  if (_internal_has_nh_group_id()) {
    clear_has_dstinfo();
    ::opi_api::common::v1::ObjectKey* temp = dstinfo_.nh_group_id_;
    dstinfo_.nh_group_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_nh_group_id(::opi_api::common::v1::ObjectKey* nh_group_id) {
  clear_dstinfo();
  if (nh_group_id) {
    set_has_nh_group_id();
    dstinfo_.nh_group_id_ = nh_group_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id)
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::_internal_mutable_nh_group_id() {
  if (!_internal_has_nh_group_id()) {
    clear_dstinfo();
    set_has_nh_group_id();
    dstinfo_.nh_group_id_ = CreateMaybeMessage< ::opi_api::common::v1::ObjectKey >(GetArenaForAllocation());
  }
  return dstinfo_.nh_group_id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingSpec::mutable_nh_group_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_nh_group_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id)
  return _msg;
}

// bytes mac_addr = 8;
inline void MappingSpec::clear_mac_addr() {
  mac_addr_.ClearToEmpty();
}
inline const std::string& MappingSpec::mac_addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return _internal_mac_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MappingSpec::set_mac_addr(ArgT0&& arg0, ArgT... args) {
 
 mac_addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
}
inline std::string* MappingSpec::mutable_mac_addr() {
  std::string* _s = _internal_mutable_mac_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return _s;
}
inline const std::string& MappingSpec::_internal_mac_addr() const {
  return mac_addr_.Get();
}
inline void MappingSpec::_internal_set_mac_addr(const std::string& value) {
  
  mac_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_mac_addr() {
  
  return mac_addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MappingSpec::release_mac_addr() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return mac_addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MappingSpec::set_allocated_mac_addr(std::string* mac_addr) {
  if (mac_addr != nullptr) {
    
  } else {
    
  }
  mac_addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
}

// .opi_api.network.opinetcommon.v1alpha1.Encap encap = 9;
inline bool MappingSpec::_internal_has_encap() const {
  return this != internal_default_instance() && encap_ != nullptr;
}
inline bool MappingSpec::has_encap() const {
  return _internal_has_encap();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& MappingSpec::_internal_encap() const {
  const ::opi_api::network::opinetcommon::v1alpha1::Encap* p = encap_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::Encap&>(
      ::opi_api::network::opinetcommon::v1alpha1::_Encap_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& MappingSpec::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  return _internal_encap();
}
inline void MappingSpec::unsafe_arena_set_allocated_encap(
    ::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  encap_ = encap;
  if (encap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::release_encap() {
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::unsafe_arena_release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::_internal_mutable_encap() {
  
  if (encap_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::Encap>(GetArenaForAllocation());
    encap_ = p;
  }
  return encap_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::mutable_encap() {
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _msg = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  return _msg;
}
inline void MappingSpec::set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  if (encap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap));
    if (message_arena != submessage_arena) {
      encap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encap, submessage_arena);
    }
    
  } else {
    
  }
  encap_ = encap;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress public_ip = 10;
inline bool MappingSpec::_internal_has_public_ip() const {
  return this != internal_default_instance() && public_ip_ != nullptr;
}
inline bool MappingSpec::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingSpec::_internal_public_ip() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingSpec::public_ip() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  return _internal_public_ip();
}
inline void MappingSpec::unsafe_arena_set_allocated_public_ip(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  public_ip_ = public_ip;
  if (public_ip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::release_public_ip() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = public_ip_;
  public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = public_ip_;
  public_ip_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::_internal_mutable_public_ip() {
  
  if (public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    public_ip_ = p;
  }
  return public_ip_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::mutable_public_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  return _msg;
}
inline void MappingSpec::set_allocated_public_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    
  } else {
    
  }
  public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
}

// repeated uint32 tags = 11;
inline int MappingSpec::_internal_tags_size() const {
  return tags_.size();
}
inline int MappingSpec::tags_size() const {
  return _internal_tags_size();
}
inline void MappingSpec::clear_tags() {
  tags_.Clear();
}
inline uint32_t MappingSpec::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline uint32_t MappingSpec::tags(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_tags(index);
}
inline void MappingSpec::set_tags(int index, uint32_t value) {
  tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
}
inline void MappingSpec::_internal_add_tags(uint32_t value) {
  tags_.Add(value);
}
inline void MappingSpec::add_tags(uint32_t value) {
  _internal_add_tags(value);
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MappingSpec::_internal_tags() const {
  return tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MappingSpec::tags() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MappingSpec::_internal_mutable_tags() {
  return &tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MappingSpec::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_mutable_tags();
}

// .opi_api.network.cloud.v1alpha1.MappingType type = 12;
inline void MappingSpec::clear_type() {
  type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingSpec::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingType >(type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingSpec::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.type)
  return _internal_type();
}
inline void MappingSpec::_internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  
  type_ = value;
}
inline void MappingSpec::set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.type)
}

inline bool MappingSpec::has_mac_or_ip() const {
  return mac_or_ip_case() != MAC_OR_IP_NOT_SET;
}
inline void MappingSpec::clear_has_mac_or_ip() {
  _oneof_case_[0] = MAC_OR_IP_NOT_SET;
}
inline bool MappingSpec::has_dstinfo() const {
  return dstinfo_case() != DSTINFO_NOT_SET;
}
inline void MappingSpec::clear_has_dstinfo() {
  _oneof_case_[1] = DSTINFO_NOT_SET;
}
inline MappingSpec::MacOrIpCase MappingSpec::mac_or_ip_case() const {
  return MappingSpec::MacOrIpCase(_oneof_case_[0]);
}
inline MappingSpec::DstinfoCase MappingSpec::dstinfo_case() const {
  return MappingSpec::DstinfoCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// MappingStatus

// int32 public_nat_index = 1;
inline void MappingStatus::clear_public_nat_index() {
  public_nat_index_ = 0;
}
inline int32_t MappingStatus::_internal_public_nat_index() const {
  return public_nat_index_;
}
inline int32_t MappingStatus::public_nat_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.public_nat_index)
  return _internal_public_nat_index();
}
inline void MappingStatus::_internal_set_public_nat_index(int32_t value) {
  
  public_nat_index_ = value;
}
inline void MappingStatus::set_public_nat_index(int32_t value) {
  _internal_set_public_nat_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.public_nat_index)
}

// int32 private_nat_index = 2;
inline void MappingStatus::clear_private_nat_index() {
  private_nat_index_ = 0;
}
inline int32_t MappingStatus::_internal_private_nat_index() const {
  return private_nat_index_;
}
inline int32_t MappingStatus::private_nat_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.private_nat_index)
  return _internal_private_nat_index();
}
inline void MappingStatus::_internal_set_private_nat_index(int32_t value) {
  
  private_nat_index_ = value;
}
inline void MappingStatus::set_private_nat_index(int32_t value) {
  _internal_set_private_nat_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.private_nat_index)
}

// repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 3;
inline int MappingStatus::_internal_tunnel_ip_size() const {
  return tunnel_ip_.size();
}
inline int MappingStatus::tunnel_ip_size() const {
  return _internal_tunnel_ip_size();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::mutable_tunnel_ip(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return tunnel_ip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
MappingStatus::mutable_tunnel_ip() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return &tunnel_ip_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingStatus::_internal_tunnel_ip(int index) const {
  return tunnel_ip_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingStatus::tunnel_ip(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _internal_tunnel_ip(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::_internal_add_tunnel_ip() {
  return tunnel_ip_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::add_tunnel_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _add = _internal_add_tunnel_ip();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
MappingStatus::tunnel_ip() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return tunnel_ip_;
}

// .opi_api.network.opinetcommon.v1alpha1.HwHandle svc_port_map_hw_handle = 4;
inline bool MappingStatus::_internal_has_svc_port_map_hw_handle() const {
  return this != internal_default_instance() && svc_port_map_hw_handle_ != nullptr;
}
inline bool MappingStatus::has_svc_port_map_hw_handle() const {
  return _internal_has_svc_port_map_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::_internal_svc_port_map_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = svc_port_map_hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::svc_port_map_hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  return _internal_svc_port_map_hw_handle();
}
inline void MappingStatus::unsafe_arena_set_allocated_svc_port_map_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(svc_port_map_hw_handle_);
  }
  svc_port_map_hw_handle_ = svc_port_map_hw_handle;
  if (svc_port_map_hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::release_svc_port_map_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = svc_port_map_hw_handle_;
  svc_port_map_hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::unsafe_arena_release_svc_port_map_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = svc_port_map_hw_handle_;
  svc_port_map_hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::_internal_mutable_svc_port_map_hw_handle() {
  
  if (svc_port_map_hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    svc_port_map_hw_handle_ = p;
  }
  return svc_port_map_hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::mutable_svc_port_map_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_svc_port_map_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  return _msg;
}
inline void MappingStatus::set_allocated_svc_port_map_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(svc_port_map_hw_handle_);
  }
  if (svc_port_map_hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(svc_port_map_hw_handle));
    if (message_arena != submessage_arena) {
      svc_port_map_hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, svc_port_map_hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  svc_port_map_hw_handle_ = svc_port_map_hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
}

// .opi_api.network.opinetcommon.v1alpha1.HwHandle vnf_tunnel_hw_handle = 5;
inline bool MappingStatus::_internal_has_vnf_tunnel_hw_handle() const {
  return this != internal_default_instance() && vnf_tunnel_hw_handle_ != nullptr;
}
inline bool MappingStatus::has_vnf_tunnel_hw_handle() const {
  return _internal_has_vnf_tunnel_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::_internal_vnf_tunnel_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = vnf_tunnel_hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::vnf_tunnel_hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  return _internal_vnf_tunnel_hw_handle();
}
inline void MappingStatus::unsafe_arena_set_allocated_vnf_tunnel_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vnf_tunnel_hw_handle_);
  }
  vnf_tunnel_hw_handle_ = vnf_tunnel_hw_handle;
  if (vnf_tunnel_hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::release_vnf_tunnel_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = vnf_tunnel_hw_handle_;
  vnf_tunnel_hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::unsafe_arena_release_vnf_tunnel_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = vnf_tunnel_hw_handle_;
  vnf_tunnel_hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::_internal_mutable_vnf_tunnel_hw_handle() {
  
  if (vnf_tunnel_hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    vnf_tunnel_hw_handle_ = p;
  }
  return vnf_tunnel_hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::mutable_vnf_tunnel_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_vnf_tunnel_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  return _msg;
}
inline void MappingStatus::set_allocated_vnf_tunnel_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vnf_tunnel_hw_handle_);
  }
  if (vnf_tunnel_hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vnf_tunnel_hw_handle));
    if (message_arena != submessage_arena) {
      vnf_tunnel_hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vnf_tunnel_hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  vnf_tunnel_hw_handle_ = vnf_tunnel_hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
}

// int32 rewrite_index = 6;
inline void MappingStatus::clear_rewrite_index() {
  rewrite_index_ = 0;
}
inline int32_t MappingStatus::_internal_rewrite_index() const {
  return rewrite_index_;
}
inline int32_t MappingStatus::rewrite_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.rewrite_index)
  return _internal_rewrite_index();
}
inline void MappingStatus::_internal_set_rewrite_index(int32_t value) {
  
  rewrite_index_ = value;
}
inline void MappingStatus::set_rewrite_index(int32_t value) {
  _internal_set_rewrite_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.rewrite_index)
}

// -------------------------------------------------------------------

// L3MappingKey

// .opi_api.common.v1.ObjectKey vpc_id = 1;
inline bool L3MappingKey::_internal_has_vpc_id() const {
  return this != internal_default_instance() && vpc_id_ != nullptr;
}
inline bool L3MappingKey::has_vpc_id() const {
  return _internal_has_vpc_id();
}
inline const ::opi_api::common::v1::ObjectKey& L3MappingKey::_internal_vpc_id() const {
  const ::opi_api::common::v1::ObjectKey* p = vpc_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& L3MappingKey::vpc_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id)
  return _internal_vpc_id();
}
inline void L3MappingKey::unsafe_arena_set_allocated_vpc_id(
    ::opi_api::common::v1::ObjectKey* vpc_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id_);
  }
  vpc_id_ = vpc_id;
  if (vpc_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id)
}
inline ::opi_api::common::v1::ObjectKey* L3MappingKey::release_vpc_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = vpc_id_;
  vpc_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3MappingKey::unsafe_arena_release_vpc_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id)
  
  ::opi_api::common::v1::ObjectKey* temp = vpc_id_;
  vpc_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L3MappingKey::_internal_mutable_vpc_id() {
  
  if (vpc_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    vpc_id_ = p;
  }
  return vpc_id_;
}
inline ::opi_api::common::v1::ObjectKey* L3MappingKey::mutable_vpc_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_vpc_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id)
  return _msg;
}
inline void L3MappingKey::set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id_);
  }
  if (vpc_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vpc_id));
    if (message_arena != submessage_arena) {
      vpc_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vpc_id, submessage_arena);
    }
    
  } else {
    
  }
  vpc_id_ = vpc_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
inline bool L3MappingKey::_internal_has_ip_address() const {
  return this != internal_default_instance() && ip_address_ != nullptr;
}
inline bool L3MappingKey::has_ip_address() const {
  return _internal_has_ip_address();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& L3MappingKey::_internal_ip_address() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = ip_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& L3MappingKey::ip_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  return _internal_ip_address();
}
inline void L3MappingKey::unsafe_arena_set_allocated_ip_address(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address_);
  }
  ip_address_ = ip_address;
  if (ip_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::release_ip_address() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = ip_address_;
  ip_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = ip_address_;
  ip_address_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::_internal_mutable_ip_address() {
  
  if (ip_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    ip_address_ = p;
  }
  return ip_address_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::mutable_ip_address() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  return _msg;
}
inline void L3MappingKey::set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address_);
  }
  if (ip_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address));
    if (message_arena != submessage_arena) {
      ip_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_address, submessage_arena);
    }
    
  } else {
    
  }
  ip_address_ = ip_address;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
}

// -------------------------------------------------------------------

// L2MappingKey

// .opi_api.common.v1.ObjectKey subnet_id = 1;
inline bool L2MappingKey::_internal_has_subnet_id() const {
  return this != internal_default_instance() && subnet_id_ != nullptr;
}
inline bool L2MappingKey::has_subnet_id() const {
  return _internal_has_subnet_id();
}
inline const ::opi_api::common::v1::ObjectKey& L2MappingKey::_internal_subnet_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subnet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& L2MappingKey::subnet_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id)
  return _internal_subnet_id();
}
inline void L2MappingKey::unsafe_arena_set_allocated_subnet_id(
    ::opi_api::common::v1::ObjectKey* subnet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id_);
  }
  subnet_id_ = subnet_id;
  if (subnet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id)
}
inline ::opi_api::common::v1::ObjectKey* L2MappingKey::release_subnet_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subnet_id_;
  subnet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L2MappingKey::unsafe_arena_release_subnet_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subnet_id_;
  subnet_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* L2MappingKey::_internal_mutable_subnet_id() {
  
  if (subnet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subnet_id_ = p;
  }
  return subnet_id_;
}
inline ::opi_api::common::v1::ObjectKey* L2MappingKey::mutable_subnet_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subnet_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id)
  return _msg;
}
inline void L2MappingKey::set_allocated_subnet_id(::opi_api::common::v1::ObjectKey* subnet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id_);
  }
  if (subnet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subnet_id));
    if (message_arena != submessage_arena) {
      subnet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subnet_id, submessage_arena);
    }
    
  } else {
    
  }
  subnet_id_ = subnet_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id)
}

// bytes mac_address = 2;
inline void L2MappingKey::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& L2MappingKey::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L2MappingKey::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
}
inline std::string* L2MappingKey::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return _s;
}
inline const std::string& L2MappingKey::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void L2MappingKey::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* L2MappingKey::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* L2MappingKey::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void L2MappingKey::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
}

// -------------------------------------------------------------------

// MappingLookupFilter

// bool local = 1;
inline void MappingLookupFilter::clear_local() {
  local_ = false;
}
inline bool MappingLookupFilter::_internal_local() const {
  return local_;
}
inline bool MappingLookupFilter::local() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.local)
  return _internal_local();
}
inline void MappingLookupFilter::_internal_set_local(bool value) {
  
  local_ = value;
}
inline void MappingLookupFilter::set_local(bool value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.local)
}

// .opi_api.network.cloud.v1alpha1.MappingKeyType key_type = 2;
inline void MappingLookupFilter::clear_key_type() {
  key_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingKeyType MappingLookupFilter::_internal_key_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingKeyType >(key_type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingKeyType MappingLookupFilter::key_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.key_type)
  return _internal_key_type();
}
inline void MappingLookupFilter::_internal_set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value) {
  
  key_type_ = value;
}
inline void MappingLookupFilter::set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.key_type)
}

// .opi_api.network.cloud.v1alpha1.MappingType type = 3;
inline void MappingLookupFilter::clear_type() {
  type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingLookupFilter::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingType >(type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingLookupFilter::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.type)
  return _internal_type();
}
inline void MappingLookupFilter::_internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  
  type_ = value;
}
inline void MappingLookupFilter::set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.type)
}

// .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 4;
inline bool MappingLookupFilter::_internal_has_ip_key() const {
  return ip_or_mac_case() == kIpKey;
}
inline bool MappingLookupFilter::has_ip_key() const {
  return _internal_has_ip_key();
}
inline void MappingLookupFilter::set_has_ip_key() {
  _oneof_case_[0] = kIpKey;
}
inline void MappingLookupFilter::clear_ip_key() {
  if (_internal_has_ip_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_or_mac_.ip_key_;
    }
    clear_has_ip_or_mac();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::release_ip_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_ip_or_mac();
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = ip_or_mac_.ip_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_or_mac_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingLookupFilter::_internal_ip_key() const {
  return _internal_has_ip_key()
      ? *ip_or_mac_.ip_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L3MappingKey&>(::opi_api::network::cloud::v1alpha1::_L3MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingLookupFilter::ip_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  return _internal_ip_key();
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::unsafe_arena_release_ip_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = ip_or_mac_.ip_key_;
    ip_or_mac_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key) {
  clear_ip_or_mac();
  if (ip_key) {
    set_has_ip_key();
    ip_or_mac_.ip_key_ = ip_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::_internal_mutable_ip_key() {
  if (!_internal_has_ip_key()) {
    clear_ip_or_mac();
    set_has_ip_key();
    ip_or_mac_.ip_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3MappingKey >(GetArenaForAllocation());
  }
  return ip_or_mac_.ip_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::mutable_ip_key() {
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _msg = _internal_mutable_ip_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 5;
inline bool MappingLookupFilter::_internal_has_mac_key() const {
  return ip_or_mac_case() == kMacKey;
}
inline bool MappingLookupFilter::has_mac_key() const {
  return _internal_has_mac_key();
}
inline void MappingLookupFilter::set_has_mac_key() {
  _oneof_case_[0] = kMacKey;
}
inline void MappingLookupFilter::clear_mac_key() {
  if (_internal_has_mac_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ip_or_mac_.mac_key_;
    }
    clear_has_ip_or_mac();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::release_mac_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_ip_or_mac();
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = ip_or_mac_.mac_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_or_mac_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingLookupFilter::_internal_mac_key() const {
  return _internal_has_mac_key()
      ? *ip_or_mac_.mac_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L2MappingKey&>(::opi_api::network::cloud::v1alpha1::_L2MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingLookupFilter::mac_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  return _internal_mac_key();
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::unsafe_arena_release_mac_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = ip_or_mac_.mac_key_;
    ip_or_mac_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key) {
  clear_ip_or_mac();
  if (mac_key) {
    set_has_mac_key();
    ip_or_mac_.mac_key_ = mac_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::_internal_mutable_mac_key() {
  if (!_internal_has_mac_key()) {
    clear_ip_or_mac();
    set_has_mac_key();
    ip_or_mac_.mac_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L2MappingKey >(GetArenaForAllocation());
  }
  return ip_or_mac_.mac_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::mutable_mac_key() {
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _msg = _internal_mutable_mac_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 6;
inline bool MappingLookupFilter::_internal_has_ip_address() const {
  return ip_or_mac_case() == kIpAddress;
}
inline bool MappingLookupFilter::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void MappingLookupFilter::set_has_ip_address() {
  _oneof_case_[0] = kIpAddress;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::release_ip_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  if (_internal_has_ip_address()) {
    clear_has_ip_or_mac();
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = ip_or_mac_.ip_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_or_mac_.ip_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingLookupFilter::_internal_ip_address() const {
  return _internal_has_ip_address()
      ? *ip_or_mac_.ip_address_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingLookupFilter::ip_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  return _internal_ip_address();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  if (_internal_has_ip_address()) {
    clear_has_ip_or_mac();
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = ip_or_mac_.ip_address_;
    ip_or_mac_.ip_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  clear_ip_or_mac();
  if (ip_address) {
    set_has_ip_address();
    ip_or_mac_.ip_address_ = ip_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::_internal_mutable_ip_address() {
  if (!_internal_has_ip_address()) {
    clear_ip_or_mac();
    set_has_ip_address();
    ip_or_mac_.ip_address_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >(GetArenaForAllocation());
  }
  return ip_or_mac_.ip_address_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::mutable_ip_address() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  return _msg;
}

// bytes mac_address = 7;
inline bool MappingLookupFilter::_internal_has_mac_address() const {
  return ip_or_mac_case() == kMacAddress;
}
inline bool MappingLookupFilter::has_mac_address() const {
  return _internal_has_mac_address();
}
inline void MappingLookupFilter::set_has_mac_address() {
  _oneof_case_[0] = kMacAddress;
}
inline void MappingLookupFilter::clear_mac_address() {
  if (_internal_has_mac_address()) {
    ip_or_mac_.mac_address_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_ip_or_mac();
  }
}
inline const std::string& MappingLookupFilter::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline void MappingLookupFilter::set_mac_address(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    ip_or_mac_.mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ip_or_mac_.mac_address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
}
inline std::string* MappingLookupFilter::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  return _s;
}
inline const std::string& MappingLookupFilter::_internal_mac_address() const {
  if (_internal_has_mac_address()) {
    return ip_or_mac_.mac_address_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingLookupFilter::_internal_set_mac_address(const std::string& value) {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    ip_or_mac_.mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  ip_or_mac_.mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::_internal_mutable_mac_address() {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    ip_or_mac_.mac_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return ip_or_mac_.mac_address_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  if (_internal_has_mac_address()) {
    clear_has_ip_or_mac();
    return ip_or_mac_.mac_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::set_allocated_mac_address(std::string* mac_address) {
  if (has_ip_or_mac()) {
    clear_ip_or_mac();
  }
  if (mac_address != nullptr) {
    set_has_mac_address();
    ip_or_mac_.mac_address_.UnsafeSetDefault(mac_address);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(mac_address);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
}

// .opi_api.common.v1.ObjectKey vpc_id = 8;
inline bool MappingLookupFilter::_internal_has_vpc_id() const {
  return ip_or_mac_case() == kVpcId;
}
inline bool MappingLookupFilter::has_vpc_id() const {
  return _internal_has_vpc_id();
}
inline void MappingLookupFilter::set_has_vpc_id() {
  _oneof_case_[0] = kVpcId;
}
inline ::opi_api::common::v1::ObjectKey* MappingLookupFilter::release_vpc_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id)
  if (_internal_has_vpc_id()) {
    clear_has_ip_or_mac();
      ::opi_api::common::v1::ObjectKey* temp = ip_or_mac_.vpc_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ip_or_mac_.vpc_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::common::v1::ObjectKey& MappingLookupFilter::_internal_vpc_id() const {
  return _internal_has_vpc_id()
      ? *ip_or_mac_.vpc_id_
      : reinterpret_cast< ::opi_api::common::v1::ObjectKey&>(::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& MappingLookupFilter::vpc_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id)
  return _internal_vpc_id();
}
inline ::opi_api::common::v1::ObjectKey* MappingLookupFilter::unsafe_arena_release_vpc_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id)
  if (_internal_has_vpc_id()) {
    clear_has_ip_or_mac();
    ::opi_api::common::v1::ObjectKey* temp = ip_or_mac_.vpc_id_;
    ip_or_mac_.vpc_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_vpc_id(::opi_api::common::v1::ObjectKey* vpc_id) {
  clear_ip_or_mac();
  if (vpc_id) {
    set_has_vpc_id();
    ip_or_mac_.vpc_id_ = vpc_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id)
}
inline ::opi_api::common::v1::ObjectKey* MappingLookupFilter::_internal_mutable_vpc_id() {
  if (!_internal_has_vpc_id()) {
    clear_ip_or_mac();
    set_has_vpc_id();
    ip_or_mac_.vpc_id_ = CreateMaybeMessage< ::opi_api::common::v1::ObjectKey >(GetArenaForAllocation());
  }
  return ip_or_mac_.vpc_id_;
}
inline ::opi_api::common::v1::ObjectKey* MappingLookupFilter::mutable_vpc_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_vpc_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id)
  return _msg;
}

inline bool MappingLookupFilter::has_ip_or_mac() const {
  return ip_or_mac_case() != IP_OR_MAC_NOT_SET;
}
inline void MappingLookupFilter::clear_has_ip_or_mac() {
  _oneof_case_[0] = IP_OR_MAC_NOT_SET;
}
inline MappingLookupFilter::IpOrMacCase MappingLookupFilter::ip_or_mac_case() const {
  return MappingLookupFilter::IpOrMacCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::MappingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::MappingType>() {
  return ::opi_api::network::cloud::v1alpha1::MappingType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::MappingKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::MappingKeyType>() {
  return ::opi_api::network::cloud::v1alpha1::MappingKeyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto
