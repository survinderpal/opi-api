// Copyright (c) 2023 Pensando, AMD Inc, or its subsidiaries.
// protobuf specification for interface (layer2 and layer3 configuration) related objects

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: interface.proto

package _go

import (
	_go "github.com/opiproject/opi-api/common/v1/gen/go"
	_go1 "github.com/opiproject/opi-api/network/opinetcommon/v1alpha1/gen/go"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// types of interfaces
type IfType int32

const (
	// unspecified
	IfType_IF_TYPE_UNSPECIFIED IfType = 0
	// uplink interface
	IfType_IF_TYPE_UPLINK IfType = 1
	// uplink port-channel interface
	IfType_IF_TYPE_UPLINK_PC IfType = 2
	// L3 interface
	IfType_IF_TYPE_L3 IfType = 3
	// loopback interface
	IfType_IF_TYPE_LOOPBACK IfType = 4
	// inband management/control interface
	IfType_IF_TYPE_CONTROL IfType = 5
	// host visible PF/VF device
	IfType_IF_TYPE_HOST IfType = 6
)

// Enum value maps for IfType.
var (
	IfType_name = map[int32]string{
		0: "IF_TYPE_UNSPECIFIED",
		1: "IF_TYPE_UPLINK",
		2: "IF_TYPE_UPLINK_PC",
		3: "IF_TYPE_L3",
		4: "IF_TYPE_LOOPBACK",
		5: "IF_TYPE_CONTROL",
		6: "IF_TYPE_HOST",
	}
	IfType_value = map[string]int32{
		"IF_TYPE_UNSPECIFIED": 0,
		"IF_TYPE_UPLINK":      1,
		"IF_TYPE_UPLINK_PC":   2,
		"IF_TYPE_L3":          3,
		"IF_TYPE_LOOPBACK":    4,
		"IF_TYPE_CONTROL":     5,
		"IF_TYPE_HOST":        6,
	}
)

func (x IfType) Enum() *IfType {
	p := new(IfType)
	*p = x
	return p
}

func (x IfType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IfType) Descriptor() protoreflect.EnumDescriptor {
	return file_interface_proto_enumTypes[0].Descriptor()
}

func (IfType) Type() protoreflect.EnumType {
	return &file_interface_proto_enumTypes[0]
}

func (x IfType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IfType.Descriptor instead.
func (IfType) EnumDescriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{0}
}

// IfStatus status reflects the operational status of Interface
// (-- api-linter: core::0216::synonyms=disabled
//     aip.dev/not-precedent: interface status is up or down, not interface state. --)
type IfStatus int32

const (
	// unknown
	IfStatus_IF_STATUS_UNSPECIFIED IfStatus = 0
	// interface is up
	IfStatus_IF_STATUS_UP IfStatus = 1
	// interface is down
	IfStatus_IF_STATUS_DOWN IfStatus = 2
)

// Enum value maps for IfStatus.
var (
	IfStatus_name = map[int32]string{
		0: "IF_STATUS_UNSPECIFIED",
		1: "IF_STATUS_UP",
		2: "IF_STATUS_DOWN",
	}
	IfStatus_value = map[string]int32{
		"IF_STATUS_UNSPECIFIED": 0,
		"IF_STATUS_UP":          1,
		"IF_STATUS_DOWN":        2,
	}
)

func (x IfStatus) Enum() *IfStatus {
	p := new(IfStatus)
	*p = x
	return p
}

func (x IfStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IfStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_interface_proto_enumTypes[1].Descriptor()
}

func (IfStatus) Type() protoreflect.EnumType {
	return &file_interface_proto_enumTypes[1]
}

func (x IfStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IfStatus.Descriptor instead.
func (IfStatus) EnumDescriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{1}
}

// interface - ethernet interface (layer2 and layer3 configuration)
type Interface struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// interface configuration
	Spec *InterfaceSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// interface status
	Status *InterfaceStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *Interface) Reset() {
	*x = Interface{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Interface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Interface) ProtoMessage() {}

func (x *Interface) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Interface.ProtoReflect.Descriptor instead.
func (*Interface) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{0}
}

func (x *Interface) GetSpec() *InterfaceSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Interface) GetStatus() *InterfaceStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// InterfaceSpec is used to add or update of an interface
type InterfaceSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// interface key
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// interface number is numerical port identifier starting from 1 range [1...max-ports#]
	Ifid int32 `protobuf:"varint,2,opt,name=ifid,proto3" json:"ifid,omitempty"`
	// admin state - default up
	// for host facing interfaces (PF/VFs) it will drop the traffic to/from cloud infra
	AdminStatus IfStatus `protobuf:"varint,3,opt,name=admin_status,json=adminStatus,proto3,enum=opi_api.network.cloud.v1alpha1.IfStatus" json:"admin_status,omitempty"`
	// interface type specific configuration
	//
	// Types that are assignable to Ifinfo:
	//	*InterfaceSpec_UplinkSpec
	//	*InterfaceSpec_UplinkPcSpec
	//	*InterfaceSpec_L3IfSpec
	//	*InterfaceSpec_LoopbackIfSpec
	//	*InterfaceSpec_ControlIfSpec
	//	*InterfaceSpec_HostIfSpec
	Ifinfo isInterfaceSpec_Ifinfo `protobuf_oneof:"ifinfo"`
}

func (x *InterfaceSpec) Reset() {
	*x = InterfaceSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InterfaceSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceSpec) ProtoMessage() {}

func (x *InterfaceSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceSpec.ProtoReflect.Descriptor instead.
func (*InterfaceSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{1}
}

func (x *InterfaceSpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *InterfaceSpec) GetIfid() int32 {
	if x != nil {
		return x.Ifid
	}
	return 0
}

func (x *InterfaceSpec) GetAdminStatus() IfStatus {
	if x != nil {
		return x.AdminStatus
	}
	return IfStatus_IF_STATUS_UNSPECIFIED
}

func (m *InterfaceSpec) GetIfinfo() isInterfaceSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (x *InterfaceSpec) GetUplinkSpec() *UplinkSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_UplinkSpec); ok {
		return x.UplinkSpec
	}
	return nil
}

func (x *InterfaceSpec) GetUplinkPcSpec() *UplinkPCSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_UplinkPcSpec); ok {
		return x.UplinkPcSpec
	}
	return nil
}

func (x *InterfaceSpec) GetL3IfSpec() *L3IfSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_L3IfSpec); ok {
		return x.L3IfSpec
	}
	return nil
}

func (x *InterfaceSpec) GetLoopbackIfSpec() *LoopbackIfSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_LoopbackIfSpec); ok {
		return x.LoopbackIfSpec
	}
	return nil
}

func (x *InterfaceSpec) GetControlIfSpec() *ControlIfSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_ControlIfSpec); ok {
		return x.ControlIfSpec
	}
	return nil
}

func (x *InterfaceSpec) GetHostIfSpec() *HostIfSpec {
	if x, ok := x.GetIfinfo().(*InterfaceSpec_HostIfSpec); ok {
		return x.HostIfSpec
	}
	return nil
}

type isInterfaceSpec_Ifinfo interface {
	isInterfaceSpec_Ifinfo()
}

type InterfaceSpec_UplinkSpec struct {
	// uplink specific configuration
	UplinkSpec *UplinkSpec `protobuf:"bytes,4,opt,name=uplink_spec,json=uplinkSpec,proto3,oneof"`
}

type InterfaceSpec_UplinkPcSpec struct {
	// uplink port-channel configuration
	UplinkPcSpec *UplinkPCSpec `protobuf:"bytes,5,opt,name=uplink_pc_spec,json=uplinkPcSpec,proto3,oneof"`
}

type InterfaceSpec_L3IfSpec struct {
	// layer3 interface configuration
	L3IfSpec *L3IfSpec `protobuf:"bytes,6,opt,name=l3_if_spec,json=l3IfSpec,proto3,oneof"`
}

type InterfaceSpec_LoopbackIfSpec struct {
	// loopback interface configuration
	LoopbackIfSpec *LoopbackIfSpec `protobuf:"bytes,7,opt,name=loopback_if_spec,json=loopbackIfSpec,proto3,oneof"`
}

type InterfaceSpec_ControlIfSpec struct {
	// control interface configuration
	ControlIfSpec *ControlIfSpec `protobuf:"bytes,8,opt,name=control_if_spec,json=controlIfSpec,proto3,oneof"`
}

type InterfaceSpec_HostIfSpec struct {
	// host facing interface's configuration
	HostIfSpec *HostIfSpec `protobuf:"bytes,9,opt,name=host_if_spec,json=hostIfSpec,proto3,oneof"`
}

func (*InterfaceSpec_UplinkSpec) isInterfaceSpec_Ifinfo() {}

func (*InterfaceSpec_UplinkPcSpec) isInterfaceSpec_Ifinfo() {}

func (*InterfaceSpec_L3IfSpec) isInterfaceSpec_Ifinfo() {}

func (*InterfaceSpec_LoopbackIfSpec) isInterfaceSpec_Ifinfo() {}

func (*InterfaceSpec_ControlIfSpec) isInterfaceSpec_Ifinfo() {}

func (*InterfaceSpec_HostIfSpec) isInterfaceSpec_Ifinfo() {}

// Uplink configuration; interface type IF_TYPE_UPLINK
type UplinkSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// physical port id corresponding to this interface
	PortId *_go.ObjectKey `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// native vlan-id, untagged rx/tx vlan id
	NativeVlanid int32 `protobuf:"varint,2,opt,name=native_vlanid,json=nativeVlanid,proto3" json:"native_vlanid,omitempty"`
}

func (x *UplinkSpec) Reset() {
	*x = UplinkSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UplinkSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UplinkSpec) ProtoMessage() {}

func (x *UplinkSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UplinkSpec.ProtoReflect.Descriptor instead.
func (*UplinkSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{2}
}

func (x *UplinkSpec) GetPortId() *_go.ObjectKey {
	if x != nil {
		return x.PortId
	}
	return nil
}

func (x *UplinkSpec) GetNativeVlanid() int32 {
	if x != nil {
		return x.NativeVlanid
	}
	return 0
}

// Uplink port-channel configuration; interface type IF_TYPE_UPLINK_PC
type UplinkPCSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// bitmap of member ifids that make up this the port-channel
	// e.g. if uplink interfaces 1 and 2 part of this port channel this is set to 0x11
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: bitmap must be uint and not int. --)
	MemberIfidsBitmap uint64 `protobuf:"varint,1,opt,name=member_ifids_bitmap,json=memberIfidsBitmap,proto3" json:"member_ifids_bitmap,omitempty"`
	// native vlan-id, untagged rx/tx vlan id
	NativeVlanid int32 `protobuf:"varint,2,opt,name=native_vlanid,json=nativeVlanid,proto3" json:"native_vlanid,omitempty"`
}

func (x *UplinkPCSpec) Reset() {
	*x = UplinkPCSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UplinkPCSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UplinkPCSpec) ProtoMessage() {}

func (x *UplinkPCSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UplinkPCSpec.ProtoReflect.Descriptor instead.
func (*UplinkPCSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{3}
}

func (x *UplinkPCSpec) GetMemberIfidsBitmap() uint64 {
	if x != nil {
		return x.MemberIfidsBitmap
	}
	return 0
}

func (x *UplinkPCSpec) GetNativeVlanid() int32 {
	if x != nil {
		return x.NativeVlanid
	}
	return 0
}

// L3 interface configuration
type L3IfSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// vpc/vrf this L3 interface belongs to
	VpcId *_go.ObjectKey `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Physical port of this L3 interface
	PortId *_go.ObjectKey `protobuf:"bytes,3,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// IP address, prefix of this L3 interface
	Prefix []*_go1.IPPrefix `protobuf:"bytes,2,rep,name=prefix,proto3" json:"prefix,omitempty"`
	// encap used for packet rewrites if this is a L3 sub interface
	Encap *_go1.Encap `protobuf:"bytes,4,opt,name=encap,proto3" json:"encap,omitempty"`
	// MAC address of this L3 interface; can be set only once
	MacAddress []byte `protobuf:"bytes,5,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (x *L3IfSpec) Reset() {
	*x = L3IfSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *L3IfSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L3IfSpec) ProtoMessage() {}

func (x *L3IfSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L3IfSpec.ProtoReflect.Descriptor instead.
func (*L3IfSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{4}
}

func (x *L3IfSpec) GetVpcId() *_go.ObjectKey {
	if x != nil {
		return x.VpcId
	}
	return nil
}

func (x *L3IfSpec) GetPortId() *_go.ObjectKey {
	if x != nil {
		return x.PortId
	}
	return nil
}

func (x *L3IfSpec) GetPrefix() []*_go1.IPPrefix {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *L3IfSpec) GetEncap() *_go1.Encap {
	if x != nil {
		return x.Encap
	}
	return nil
}

func (x *L3IfSpec) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

// BGP standard community
type BGPCommunity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// first 16-bit of standard community (range:0-65535)
	Asn int32 `protobuf:"varint,1,opt,name=asn,proto3" json:"asn,omitempty"`
	// second 16-bit of standard community (range:0-65535)
	Community int32 `protobuf:"varint,2,opt,name=community,proto3" json:"community,omitempty"`
}

func (x *BGPCommunity) Reset() {
	*x = BGPCommunity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BGPCommunity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BGPCommunity) ProtoMessage() {}

func (x *BGPCommunity) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BGPCommunity.ProtoReflect.Descriptor instead.
func (*BGPCommunity) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{5}
}

func (x *BGPCommunity) GetAsn() int32 {
	if x != nil {
		return x.Asn
	}
	return 0
}

func (x *BGPCommunity) GetCommunity() int32 {
	if x != nil {
		return x.Community
	}
	return 0
}

// Loopback interface configuration
type LoopbackIfSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP address hosted on the loopback interface (also DPU's TEP IP)
	Prefix *_go1.IPPrefix `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// BGP standard community to be attached to the route advertising this loopback TEP IP
	Communities []*BGPCommunity `protobuf:"bytes,2,rep,name=communities,proto3" json:"communities,omitempty"`
}

func (x *LoopbackIfSpec) Reset() {
	*x = LoopbackIfSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoopbackIfSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoopbackIfSpec) ProtoMessage() {}

func (x *LoopbackIfSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoopbackIfSpec.ProtoReflect.Descriptor instead.
func (*LoopbackIfSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{6}
}

func (x *LoopbackIfSpec) GetPrefix() *_go1.IPPrefix {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *LoopbackIfSpec) GetCommunities() []*BGPCommunity {
	if x != nil {
		return x.Communities
	}
	return nil
}

// Inband control interface configuration
type ControlIfSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// IP address hosted on the inband control interface
	Prefix *_go1.IPPrefix `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// mac address of the interface
	MacAddress []byte `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (x *ControlIfSpec) Reset() {
	*x = ControlIfSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ControlIfSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlIfSpec) ProtoMessage() {}

func (x *ControlIfSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlIfSpec.ProtoReflect.Descriptor instead.
func (*ControlIfSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{7}
}

func (x *ControlIfSpec) GetPrefix() *_go1.IPPrefix {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *ControlIfSpec) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

// HostIfSpec represents a host visisble device (e.g. eth interface)
// Host interfaces are created based on the device configuration (see device.proto)
// This object provides cloud provider a control over the host VFs or PFs for various
// cloud infrastructure functions (e.g. rate limiting)
type HostIfSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VF has vf set to true, otherwise the interface is assumed to be a PF
	Vf bool `protobuf:"varint,1,opt,name=vf,proto3" json:"vf,omitempty"`
	// ConnTrackEnable will enable full connection tracking, enabled for new connections
	EnableConnectionTracking bool `protobuf:"varint,2,opt,name=enable_connection_tracking,json=enableConnectionTracking,proto3" json:"enable_connection_tracking,omitempty"`
	// DPU will assign a mac address to a PF, user can modify this (effective upon reboot)
	MacAddress []byte `protobuf:"bytes,3,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// interface name (this can be populated from what is obtaine from the driver
	// for easier troublsehooting, or other operations
	Ifname string `protobuf:"bytes,4,opt,name=ifname,proto3" json:"ifname,omitempty"`
}

func (x *HostIfSpec) Reset() {
	*x = HostIfSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HostIfSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostIfSpec) ProtoMessage() {}

func (x *HostIfSpec) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostIfSpec.ProtoReflect.Descriptor instead.
func (*HostIfSpec) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{8}
}

func (x *HostIfSpec) GetVf() bool {
	if x != nil {
		return x.Vf
	}
	return false
}

func (x *HostIfSpec) GetEnableConnectionTracking() bool {
	if x != nil {
		return x.EnableConnectionTracking
	}
	return false
}

func (x *HostIfSpec) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

func (x *HostIfSpec) GetIfname() string {
	if x != nil {
		return x.Ifname
	}
	return ""
}

// operational status of uplink interface
type UplinkIfStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// hw specific index associated with this uplink, useful for operations
	HwIfIdx int32 `protobuf:"varint,1,opt,name=hw_if_idx,json=hwIfIdx,proto3" json:"hw_if_idx,omitempty"`
	// hw port number is hw identifier of the port, usefor for operations
	HwPortNumber int32 `protobuf:"varint,2,opt,name=hw_port_number,json=hwPortNumber,proto3" json:"hw_port_number,omitempty"`
}

func (x *UplinkIfStatus) Reset() {
	*x = UplinkIfStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UplinkIfStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UplinkIfStatus) ProtoMessage() {}

func (x *UplinkIfStatus) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UplinkIfStatus.ProtoReflect.Descriptor instead.
func (*UplinkIfStatus) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{9}
}

func (x *UplinkIfStatus) GetHwIfIdx() int32 {
	if x != nil {
		return x.HwIfIdx
	}
	return 0
}

func (x *UplinkIfStatus) GetHwPortNumber() int32 {
	if x != nil {
		return x.HwPortNumber
	}
	return 0
}

// operational status of loopback interface
type LoopbackIfStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// loopback interface name in DPU's OS
	Ifname string `protobuf:"bytes,1,opt,name=ifname,proto3" json:"ifname,omitempty"`
}

func (x *LoopbackIfStatus) Reset() {
	*x = LoopbackIfStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoopbackIfStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoopbackIfStatus) ProtoMessage() {}

func (x *LoopbackIfStatus) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoopbackIfStatus.ProtoReflect.Descriptor instead.
func (*LoopbackIfStatus) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{10}
}

func (x *LoopbackIfStatus) GetIfname() string {
	if x != nil {
		return x.Ifname
	}
	return ""
}

// operational status of host interfaces
type HostIfStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// hw ifidx is a range of hw specifc interfaces index values associated with this host interface
	HwIfIdxes [][]byte `protobuf:"bytes,1,rep,name=hw_if_idxes,json=hwIfIdxes,proto3" json:"hw_if_idxes,omitempty"`
	// MAC address of this interface
	MacAddress []byte `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// operational status of this interface
	Status IfStatus `protobuf:"varint,3,opt,name=status,proto3,enum=opi_api.network.cloud.v1alpha1.IfStatus" json:"status,omitempty"`
	// host interface name
	Ifname string `protobuf:"bytes,4,opt,name=ifname,proto3" json:"ifname,omitempty"`
}

func (x *HostIfStatus) Reset() {
	*x = HostIfStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HostIfStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostIfStatus) ProtoMessage() {}

func (x *HostIfStatus) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostIfStatus.ProtoReflect.Descriptor instead.
func (*HostIfStatus) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{11}
}

func (x *HostIfStatus) GetHwIfIdxes() [][]byte {
	if x != nil {
		return x.HwIfIdxes
	}
	return nil
}

func (x *HostIfStatus) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

func (x *HostIfStatus) GetStatus() IfStatus {
	if x != nil {
		return x.Status
	}
	return IfStatus_IF_STATUS_UNSPECIFIED
}

func (x *HostIfStatus) GetIfname() string {
	if x != nil {
		return x.Ifname
	}
	return ""
}

// operational status of an interface, if any
type InterfaceStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// encoded interface index of this interface
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: interface index is an opaque uint32 value. --)
	IfIndex uint32 `protobuf:"varint,1,opt,name=if_index,json=ifIndex,proto3" json:"if_index,omitempty"`
	// operational status of the interface
	OperStatus IfStatus `protobuf:"varint,2,opt,name=oper_status,json=operStatus,proto3,enum=opi_api.network.cloud.v1alpha1.IfStatus" json:"oper_status,omitempty"`
	// Types that are assignable to Ifstatus:
	//	*InterfaceStatus_UplinkIfStatus
	//	*InterfaceStatus_LoopbackIfStatus
	//	*InterfaceStatus_HostIfStatus
	Ifstatus isInterfaceStatus_Ifstatus `protobuf_oneof:"ifstatus"`
}

func (x *InterfaceStatus) Reset() {
	*x = InterfaceStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_interface_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InterfaceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceStatus) ProtoMessage() {}

func (x *InterfaceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_interface_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceStatus.ProtoReflect.Descriptor instead.
func (*InterfaceStatus) Descriptor() ([]byte, []int) {
	return file_interface_proto_rawDescGZIP(), []int{12}
}

func (x *InterfaceStatus) GetIfIndex() uint32 {
	if x != nil {
		return x.IfIndex
	}
	return 0
}

func (x *InterfaceStatus) GetOperStatus() IfStatus {
	if x != nil {
		return x.OperStatus
	}
	return IfStatus_IF_STATUS_UNSPECIFIED
}

func (m *InterfaceStatus) GetIfstatus() isInterfaceStatus_Ifstatus {
	if m != nil {
		return m.Ifstatus
	}
	return nil
}

func (x *InterfaceStatus) GetUplinkIfStatus() *UplinkIfStatus {
	if x, ok := x.GetIfstatus().(*InterfaceStatus_UplinkIfStatus); ok {
		return x.UplinkIfStatus
	}
	return nil
}

func (x *InterfaceStatus) GetLoopbackIfStatus() *LoopbackIfStatus {
	if x, ok := x.GetIfstatus().(*InterfaceStatus_LoopbackIfStatus); ok {
		return x.LoopbackIfStatus
	}
	return nil
}

func (x *InterfaceStatus) GetHostIfStatus() *HostIfStatus {
	if x, ok := x.GetIfstatus().(*InterfaceStatus_HostIfStatus); ok {
		return x.HostIfStatus
	}
	return nil
}

type isInterfaceStatus_Ifstatus interface {
	isInterfaceStatus_Ifstatus()
}

type InterfaceStatus_UplinkIfStatus struct {
	// uplink specific status
	UplinkIfStatus *UplinkIfStatus `protobuf:"bytes,3,opt,name=uplink_if_status,json=uplinkIfStatus,proto3,oneof"`
}

type InterfaceStatus_LoopbackIfStatus struct {
	// loopback interface specific status
	LoopbackIfStatus *LoopbackIfStatus `protobuf:"bytes,4,opt,name=loopback_if_status,json=loopbackIfStatus,proto3,oneof"`
}

type InterfaceStatus_HostIfStatus struct {
	// host interface specific status
	HostIfStatus *HostIfStatus `protobuf:"bytes,5,opt,name=host_if_status,json=hostIfStatus,proto3,oneof"`
}

func (*InterfaceStatus_UplinkIfStatus) isInterfaceStatus_Ifstatus() {}

func (*InterfaceStatus_LoopbackIfStatus) isInterfaceStatus_Ifstatus() {}

func (*InterfaceStatus_HostIfStatus) isInterfaceStatus_Ifstatus() {}

var File_interface_proto protoreflect.FileDescriptor

var file_interface_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x1e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x1a, 0x10, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x12, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x74, 0x79, 0x70, 0x65,
	0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x97, 0x01, 0x0a, 0x09, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x66, 0x61, 0x63, 0x65, 0x12, 0x41, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x53, 0x70,
	0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x47, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61,
	0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66,
	0x61, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x22, 0x9c, 0x05, 0x0a, 0x0d, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x53,
	0x70, 0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x02, 0x69,
	0x64, 0x12, 0x12, 0x0a, 0x04, 0x69, 0x66, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x04, 0x69, 0x66, 0x69, 0x64, 0x12, 0x4b, 0x0a, 0x0c, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x5f, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x66, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0b, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x4d, 0x0a, 0x0b, 0x75, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x73, 0x70, 0x65,
	0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x55, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x53,
	0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x0a, 0x75, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x53, 0x70, 0x65,
	0x63, 0x12, 0x54, 0x0a, 0x0e, 0x75, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x70, 0x63, 0x5f, 0x73,
	0x70, 0x65, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x55, 0x70, 0x6c, 0x69, 0x6e,
	0x6b, 0x50, 0x43, 0x53, 0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x0c, 0x75, 0x70, 0x6c, 0x69, 0x6e,
	0x6b, 0x50, 0x63, 0x53, 0x70, 0x65, 0x63, 0x12, 0x48, 0x0a, 0x0a, 0x6c, 0x33, 0x5f, 0x69, 0x66,
	0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x33, 0x49,
	0x66, 0x53, 0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x08, 0x6c, 0x33, 0x49, 0x66, 0x53, 0x70, 0x65,
	0x63, 0x12, 0x5a, 0x0a, 0x10, 0x6c, 0x6f, 0x6f, 0x70, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x69, 0x66,
	0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x6f,
	0x70, 0x62, 0x61, 0x63, 0x6b, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x0e, 0x6c,
	0x6f, 0x6f, 0x70, 0x62, 0x61, 0x63, 0x6b, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x57, 0x0a,
	0x0f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x69, 0x66, 0x5f, 0x73, 0x70, 0x65, 0x63,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49,
	0x66, 0x53, 0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c,
	0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x4e, 0x0a, 0x0c, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x69,
	0x66, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x48, 0x6f,
	0x73, 0x74, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x48, 0x00, 0x52, 0x0a, 0x68, 0x6f, 0x73, 0x74,
	0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x42, 0x08, 0x0a, 0x06, 0x69, 0x66, 0x69, 0x6e, 0x66, 0x6f,
	0x22, 0x68, 0x0a, 0x0a, 0x55, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x53, 0x70, 0x65, 0x63, 0x12, 0x35,
	0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x06, 0x70,
	0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f,
	0x76, 0x6c, 0x61, 0x6e, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x6e, 0x61,
	0x74, 0x69, 0x76, 0x65, 0x56, 0x6c, 0x61, 0x6e, 0x69, 0x64, 0x22, 0x63, 0x0a, 0x0c, 0x55, 0x70,
	0x6c, 0x69, 0x6e, 0x6b, 0x50, 0x43, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2e, 0x0a, 0x13, 0x6d, 0x65,
	0x6d, 0x62, 0x65, 0x72, 0x5f, 0x69, 0x66, 0x69, 0x64, 0x73, 0x5f, 0x62, 0x69, 0x74, 0x6d, 0x61,
	0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x49,
	0x66, 0x69, 0x64, 0x73, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x12, 0x23, 0x0a, 0x0d, 0x6e, 0x61,
	0x74, 0x69, 0x76, 0x65, 0x5f, 0x76, 0x6c, 0x61, 0x6e, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0c, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x56, 0x6c, 0x61, 0x6e, 0x69, 0x64, 0x22,
	0xa4, 0x02, 0x0a, 0x08, 0x4c, 0x33, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x33, 0x0a, 0x06,
	0x76, 0x70, 0x63, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x05, 0x76, 0x70, 0x63, 0x49,
	0x64, 0x12, 0x35, 0x0a, 0x07, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79,
	0x52, 0x06, 0x70, 0x6f, 0x72, 0x74, 0x49, 0x64, 0x12, 0x47, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66,
	0x69, 0x78, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61,
	0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65,
	0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x49, 0x50, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69,
	0x78, 0x12, 0x42, 0x0a, 0x05, 0x65, 0x6e, 0x63, 0x61, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x45, 0x6e, 0x63, 0x61, 0x70, 0x52, 0x05,
	0x65, 0x6e, 0x63, 0x61, 0x70, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x6d, 0x61, 0x63, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x3e, 0x0a, 0x0c, 0x42, 0x47, 0x50, 0x43, 0x6f, 0x6d,
	0x6d, 0x75, 0x6e, 0x69, 0x74, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x73, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x03, 0x61, 0x73, 0x6e, 0x12, 0x1c, 0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x6d,
	0x75, 0x6e, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x63, 0x6f, 0x6d,
	0x6d, 0x75, 0x6e, 0x69, 0x74, 0x79, 0x22, 0xa9, 0x01, 0x0a, 0x0e, 0x4c, 0x6f, 0x6f, 0x70, 0x62,
	0x61, 0x63, 0x6b, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x47, 0x0a, 0x06, 0x70, 0x72, 0x65,
	0x66, 0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e,
	0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x49, 0x50, 0x50, 0x72, 0x65, 0x66, 0x69, 0x78, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66,
	0x69, 0x78, 0x12, 0x4e, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x42, 0x47, 0x50, 0x43, 0x6f, 0x6d, 0x6d,
	0x75, 0x6e, 0x69, 0x74, 0x79, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x74, 0x69,
	0x65, 0x73, 0x22, 0x79, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x49, 0x66, 0x53,
	0x70, 0x65, 0x63, 0x12, 0x47, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x50, 0x72,
	0x65, 0x66, 0x69, 0x78, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x1f, 0x0a, 0x0b,
	0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x0a, 0x6d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x93, 0x01,
	0x0a, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x49, 0x66, 0x53, 0x70, 0x65, 0x63, 0x12, 0x0e, 0x0a, 0x02,
	0x76, 0x66, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x02, 0x76, 0x66, 0x12, 0x3c, 0x0a, 0x1a,
	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x18, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61,
	0x63, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x0a, 0x6d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x69,
	0x66, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x69, 0x66, 0x6e,
	0x61, 0x6d, 0x65, 0x22, 0x52, 0x0a, 0x0e, 0x55, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x49, 0x66, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x09, 0x68, 0x77, 0x5f, 0x69, 0x66, 0x5f, 0x69,
	0x64, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x68, 0x77, 0x49, 0x66, 0x49, 0x64,
	0x78, 0x12, 0x24, 0x0a, 0x0e, 0x68, 0x77, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x6e, 0x75, 0x6d,
	0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x68, 0x77, 0x50, 0x6f, 0x72,
	0x74, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x22, 0x2a, 0x0a, 0x10, 0x4c, 0x6f, 0x6f, 0x70, 0x62,
	0x61, 0x63, 0x6b, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x69,
	0x66, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x69, 0x66, 0x6e,
	0x61, 0x6d, 0x65, 0x22, 0xa9, 0x01, 0x0a, 0x0c, 0x48, 0x6f, 0x73, 0x74, 0x49, 0x66, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x1e, 0x0a, 0x0b, 0x68, 0x77, 0x5f, 0x69, 0x66, 0x5f, 0x69, 0x64,
	0x78, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x09, 0x68, 0x77, 0x49, 0x66, 0x49,
	0x64, 0x78, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x6d, 0x61, 0x63, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x40, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52,
	0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x69, 0x66, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x69, 0x66, 0x6e, 0x61, 0x6d, 0x65, 0x22,
	0x97, 0x03, 0x0a, 0x0f, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x66, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x69, 0x66, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x49,
	0x0a, 0x0b, 0x6f, 0x70, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0a, 0x6f,
	0x70, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x5a, 0x0a, 0x10, 0x75, 0x70, 0x6c,
	0x69, 0x6e, 0x6b, 0x5f, 0x69, 0x66, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x55, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x49, 0x66, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x0e, 0x75, 0x70, 0x6c, 0x69, 0x6e, 0x6b, 0x49, 0x66, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x60, 0x0a, 0x12, 0x6c, 0x6f, 0x6f, 0x70, 0x62, 0x61, 0x63,
	0x6b, 0x5f, 0x69, 0x66, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x6f, 0x70, 0x62, 0x61, 0x63, 0x6b, 0x49, 0x66, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x48, 0x00, 0x52, 0x10, 0x6c, 0x6f, 0x6f, 0x70, 0x62, 0x61, 0x63, 0x6b, 0x49,
	0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x54, 0x0a, 0x0e, 0x68, 0x6f, 0x73, 0x74, 0x5f,
	0x69, 0x66, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x48, 0x6f, 0x73, 0x74, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x48, 0x00, 0x52,
	0x0c, 0x68, 0x6f, 0x73, 0x74, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x42, 0x0a, 0x0a,
	0x08, 0x69, 0x66, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2a, 0x99, 0x01, 0x0a, 0x06, 0x49, 0x66,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x17, 0x0a, 0x13, 0x49, 0x46, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x12, 0x0a,
	0x0e, 0x49, 0x46, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x50, 0x4c, 0x49, 0x4e, 0x4b, 0x10,
	0x01, 0x12, 0x15, 0x0a, 0x11, 0x49, 0x46, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x50, 0x4c,
	0x49, 0x4e, 0x4b, 0x5f, 0x50, 0x43, 0x10, 0x02, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x46, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x4c, 0x33, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x49, 0x46, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x4c, 0x4f, 0x4f, 0x50, 0x42, 0x41, 0x43, 0x4b, 0x10, 0x04, 0x12, 0x13,
	0x0a, 0x0f, 0x49, 0x46, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f,
	0x4c, 0x10, 0x05, 0x12, 0x10, 0x0a, 0x0c, 0x49, 0x46, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48,
	0x4f, 0x53, 0x54, 0x10, 0x06, 0x2a, 0x4b, 0x0a, 0x08, 0x49, 0x66, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x19, 0x0a, 0x15, 0x49, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c,
	0x49, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x50, 0x10, 0x01, 0x12, 0x12,
	0x0a, 0x0e, 0x49, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x44, 0x4f, 0x57, 0x4e,
	0x10, 0x02, 0x42, 0x6f, 0x0a, 0x1e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x42, 0x0e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x6f, 0x70, 0x69, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6f, 0x70,
	0x69, 0x2d, 0x61, 0x70, 0x69, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2f, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2f, 0x67, 0x65, 0x6e,
	0x2f, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_interface_proto_rawDescOnce sync.Once
	file_interface_proto_rawDescData = file_interface_proto_rawDesc
)

func file_interface_proto_rawDescGZIP() []byte {
	file_interface_proto_rawDescOnce.Do(func() {
		file_interface_proto_rawDescData = protoimpl.X.CompressGZIP(file_interface_proto_rawDescData)
	})
	return file_interface_proto_rawDescData
}

var file_interface_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_interface_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_interface_proto_goTypes = []interface{}{
	(IfType)(0),              // 0: opi_api.network.cloud.v1alpha1.IfType
	(IfStatus)(0),            // 1: opi_api.network.cloud.v1alpha1.IfStatus
	(*Interface)(nil),        // 2: opi_api.network.cloud.v1alpha1.Interface
	(*InterfaceSpec)(nil),    // 3: opi_api.network.cloud.v1alpha1.InterfaceSpec
	(*UplinkSpec)(nil),       // 4: opi_api.network.cloud.v1alpha1.UplinkSpec
	(*UplinkPCSpec)(nil),     // 5: opi_api.network.cloud.v1alpha1.UplinkPCSpec
	(*L3IfSpec)(nil),         // 6: opi_api.network.cloud.v1alpha1.L3IfSpec
	(*BGPCommunity)(nil),     // 7: opi_api.network.cloud.v1alpha1.BGPCommunity
	(*LoopbackIfSpec)(nil),   // 8: opi_api.network.cloud.v1alpha1.LoopbackIfSpec
	(*ControlIfSpec)(nil),    // 9: opi_api.network.cloud.v1alpha1.ControlIfSpec
	(*HostIfSpec)(nil),       // 10: opi_api.network.cloud.v1alpha1.HostIfSpec
	(*UplinkIfStatus)(nil),   // 11: opi_api.network.cloud.v1alpha1.UplinkIfStatus
	(*LoopbackIfStatus)(nil), // 12: opi_api.network.cloud.v1alpha1.LoopbackIfStatus
	(*HostIfStatus)(nil),     // 13: opi_api.network.cloud.v1alpha1.HostIfStatus
	(*InterfaceStatus)(nil),  // 14: opi_api.network.cloud.v1alpha1.InterfaceStatus
	(*_go.ObjectKey)(nil),    // 15: opi_api.common.v1.ObjectKey
	(*_go1.IPPrefix)(nil),    // 16: opi_api.network.opinetcommon.v1alpha1.IPPrefix
	(*_go1.Encap)(nil),       // 17: opi_api.network.opinetcommon.v1alpha1.Encap
}
var file_interface_proto_depIdxs = []int32{
	3,  // 0: opi_api.network.cloud.v1alpha1.Interface.spec:type_name -> opi_api.network.cloud.v1alpha1.InterfaceSpec
	14, // 1: opi_api.network.cloud.v1alpha1.Interface.status:type_name -> opi_api.network.cloud.v1alpha1.InterfaceStatus
	15, // 2: opi_api.network.cloud.v1alpha1.InterfaceSpec.id:type_name -> opi_api.common.v1.ObjectKey
	1,  // 3: opi_api.network.cloud.v1alpha1.InterfaceSpec.admin_status:type_name -> opi_api.network.cloud.v1alpha1.IfStatus
	4,  // 4: opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec:type_name -> opi_api.network.cloud.v1alpha1.UplinkSpec
	5,  // 5: opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec:type_name -> opi_api.network.cloud.v1alpha1.UplinkPCSpec
	6,  // 6: opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec:type_name -> opi_api.network.cloud.v1alpha1.L3IfSpec
	8,  // 7: opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec:type_name -> opi_api.network.cloud.v1alpha1.LoopbackIfSpec
	9,  // 8: opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec:type_name -> opi_api.network.cloud.v1alpha1.ControlIfSpec
	10, // 9: opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec:type_name -> opi_api.network.cloud.v1alpha1.HostIfSpec
	15, // 10: opi_api.network.cloud.v1alpha1.UplinkSpec.port_id:type_name -> opi_api.common.v1.ObjectKey
	15, // 11: opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_id:type_name -> opi_api.common.v1.ObjectKey
	15, // 12: opi_api.network.cloud.v1alpha1.L3IfSpec.port_id:type_name -> opi_api.common.v1.ObjectKey
	16, // 13: opi_api.network.cloud.v1alpha1.L3IfSpec.prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	17, // 14: opi_api.network.cloud.v1alpha1.L3IfSpec.encap:type_name -> opi_api.network.opinetcommon.v1alpha1.Encap
	16, // 15: opi_api.network.cloud.v1alpha1.LoopbackIfSpec.prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	7,  // 16: opi_api.network.cloud.v1alpha1.LoopbackIfSpec.communities:type_name -> opi_api.network.cloud.v1alpha1.BGPCommunity
	16, // 17: opi_api.network.cloud.v1alpha1.ControlIfSpec.prefix:type_name -> opi_api.network.opinetcommon.v1alpha1.IPPrefix
	1,  // 18: opi_api.network.cloud.v1alpha1.HostIfStatus.status:type_name -> opi_api.network.cloud.v1alpha1.IfStatus
	1,  // 19: opi_api.network.cloud.v1alpha1.InterfaceStatus.oper_status:type_name -> opi_api.network.cloud.v1alpha1.IfStatus
	11, // 20: opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status:type_name -> opi_api.network.cloud.v1alpha1.UplinkIfStatus
	12, // 21: opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status:type_name -> opi_api.network.cloud.v1alpha1.LoopbackIfStatus
	13, // 22: opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status:type_name -> opi_api.network.cloud.v1alpha1.HostIfStatus
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_interface_proto_init() }
func file_interface_proto_init() {
	if File_interface_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_interface_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Interface); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InterfaceSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UplinkSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UplinkPCSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*L3IfSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BGPCommunity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoopbackIfSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ControlIfSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HostIfSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UplinkIfStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoopbackIfStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HostIfStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_interface_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InterfaceStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_interface_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*InterfaceSpec_UplinkSpec)(nil),
		(*InterfaceSpec_UplinkPcSpec)(nil),
		(*InterfaceSpec_L3IfSpec)(nil),
		(*InterfaceSpec_LoopbackIfSpec)(nil),
		(*InterfaceSpec_ControlIfSpec)(nil),
		(*InterfaceSpec_HostIfSpec)(nil),
	}
	file_interface_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*InterfaceStatus_UplinkIfStatus)(nil),
		(*InterfaceStatus_LoopbackIfStatus)(nil),
		(*InterfaceStatus_HostIfStatus)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_interface_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_interface_proto_goTypes,
		DependencyIndexes: file_interface_proto_depIdxs,
		EnumInfos:         file_interface_proto_enumTypes,
		MessageInfos:      file_interface_proto_msgTypes,
	}.Build()
	File_interface_proto = out.File
	file_interface_proto_rawDesc = nil
	file_interface_proto_goTypes = nil
	file_interface_proto_depIdxs = nil
}
