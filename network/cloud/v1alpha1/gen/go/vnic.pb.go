// Copyright (c) 2023 Pensando, AMD Inc, or its subsidiaries.
// protobuf specification for virtual nics

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: vnic.proto

package _go

import (
	_go "github.com/opiproject/opi-api/common/v1/gen/go"
	_go1 "github.com/opiproject/opi-api/network/opinetcommon/v1alpha1/gen/go"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// vnic is a generic abstraction representing tenant workload's interface
// tenant workload could be a VM, container or bare-metal.  VNIC is identified
// using various mechanisms to ensure it can be abstractly represented on the DPU.
// VNIC represents a different abstraction from that of a port or interface object
type Vnic struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// vnic configuration
	Spec *VnicSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// vnic status
	Status *VnicStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *Vnic) Reset() {
	*x = Vnic{}
	if protoimpl.UnsafeEnabled {
		mi := &file_vnic_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Vnic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Vnic) ProtoMessage() {}

func (x *Vnic) ProtoReflect() protoreflect.Message {
	mi := &file_vnic_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Vnic.ProtoReflect.Descriptor instead.
func (*Vnic) Descriptor() ([]byte, []int) {
	return file_vnic_proto_rawDescGZIP(), []int{0}
}

func (x *Vnic) GetSpec() *VnicSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Vnic) GetStatus() *VnicStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// vnic configuration
type VnicSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// unique vnic id
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// id of the subnet this vnic belongs to
	SubnetId *_go.ObjectKey `protobuf:"bytes,2,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// vnic encap information to be used while sending packets to this vnic
	VnicEncap *_go1.Encap `protobuf:"bytes,3,opt,name=vnic_encap,json=vnicEncap,proto3" json:"vnic_encap,omitempty"`
	// overlay MAC of this VNIC
	MacAddress []byte `protobuf:"bytes,4,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// enable or disable reverse path checks while rx/tx traffic from/to this vnic
	SourceGuardEnable bool `protobuf:"varint,5,opt,name=source_guard_enable,json=sourceGuardEnable,proto3" json:"source_guard_enable,omitempty"`
	// fabric encap information to be used for traffic originated from this vnic
	FabricEncap *_go1.Encap `protobuf:"bytes,6,opt,name=fabric_encap,json=fabricEncap,proto3" json:"fabric_encap,omitempty"`
	// VNFs (virtual network functions are workloads that implement network
	// features such as firewalls, virtual switches/bridges, security monitoring, etc.
	// since VNFs are devices in the middle, they can rx/tx traffic on behalf of other
	// workloads to allow for source/destination checks, and exceptions that of a mapping
	Vnf bool `protobuf:"varint,7,opt,name=vnf,proto3" json:"vnf,omitempty"`
	// identifier of ingress IPv4 security policy to be enforced
	IngressV4SecurityPolicyId []*_go.ObjectKey `protobuf:"bytes,8,rep,name=ingress_v4_security_policy_id,json=ingressV4SecurityPolicyId,proto3" json:"ingress_v4_security_policy_id,omitempty"`
	// identifier of ingress IPv6 security policy to be enforced
	IngressV6SecurityPolicyId []*_go.ObjectKey `protobuf:"bytes,9,rep,name=ingress_v6_security_policy_id,json=ingressV6SecurityPolicyId,proto3" json:"ingress_v6_security_policy_id,omitempty"`
	// identifier of egress IPv4 security policy to be enforced
	EgressV4SecurityPolicyId []*_go.ObjectKey `protobuf:"bytes,10,rep,name=egress_v4_security_policy_id,json=egressV4SecurityPolicyId,proto3" json:"egress_v4_security_policy_id,omitempty"`
	// identifier of egress IPv6 security policy to be enforced
	EgressV6SecurityPolicyId []*_go.ObjectKey `protobuf:"bytes,11,rep,name=egress_v6_security_policy_id,json=egressV6SecurityPolicyId,proto3" json:"egress_v6_security_policy_id,omitempty"`
	// Types that are assignable to Ifinfo:
	//	*VnicSpec_HostIfId
	//	*VnicSpec_TunnelId
	Ifinfo isVnicSpec_Ifinfo `protobuf_oneof:"ifinfo"`
	// max_sessions, if set, is total number of active sessions (across all
	// protocols) allowed from/to this vnic; zero means unlimited
	MaxSessions int32 `protobuf:"varint,20,opt,name=max_sessions,json=maxSessions,proto3" json:"max_sessions,omitempty"`
	// guest workload's MAC in rx/tx direction is rewritten with this mac if non zero
	PublicMacAddress []byte `protobuf:"bytes,25,opt,name=public_mac_address,json=publicMacAddress,proto3" json:"public_mac_address,omitempty"`
	// if allow_internet_access is set to false and traffic from the vnic hits a
	// route of class ROUTE_CLASS_INTERNET, then traffic is dropped. To allow
	// Internet connectivity for the vnic, AllowInternetAccess must be set to
	// true
	AllowInternetAccess bool `protobuf:"varint,28,opt,name=allow_internet_access,json=allowInternetAccess,proto3" json:"allow_internet_access,omitempty"`
	// max_cps, if non-zero, is the maximum no. of connections per second (cps)
	// allowed for this vnic and if cps exceeds this configured limit all
	// new connections will get dropped; zero means unlimited
	MaxCps int32 `protobuf:"varint,29,opt,name=max_cps,json=maxCps,proto3" json:"max_cps,omitempty"`
	// CPS burst to be absorbed when CPS exceeds MaxCPS; zero means
	// no burst is allowed
	CpsBurst int32 `protobuf:"varint,30,opt,name=cps_burst,json=cpsBurst,proto3" json:"cps_burst,omitempty"`
	// multiple vnics can be created with same MAC but only of them can be primary
	// VNIC and all 2nd-ary vnics refer to the primary vnic, both primary and
	// secondary vnic can have one or more local IP mappings behind them
	PrimaryVnicId *_go.ObjectKey `protobuf:"bytes,32,opt,name=primary_vnic_id,json=primaryVnicId,proto3" json:"primary_vnic_id,omitempty"`
	// identifier of the IPv4 route table to be used
	V4RouteTableId *_go.ObjectKey `protobuf:"bytes,33,opt,name=v4_route_table_id,json=v4RouteTableId,proto3" json:"v4_route_table_id,omitempty"`
	// identifier of the IPv6 route table to be used, if any
	V6RouteTableId *_go.ObjectKey `protobuf:"bytes,34,opt,name=v6_route_table_id,json=v6RouteTableId,proto3" json:"v6_route_table_id,omitempty"`
	// vnic if assigned a VIP in the underlay, can be used as
	// outer encap source IP, if configured, for traffic going to certain vpc
	// private service endpoints
	ServiceIp *_go1.IPAddress `protobuf:"bytes,36,opt,name=service_ip,json=serviceIp,proto3" json:"service_ip,omitempty"`
	// max_tcp_sessions is the maximum number of TCP sessions allowed from/to this
	// vnic, if it is non-zero; zero implies no limit
	MaxTcpSessions int32 `protobuf:"varint,38,opt,name=max_tcp_sessions,json=maxTcpSessions,proto3" json:"max_tcp_sessions,omitempty"`
	// max_udp_sessions is the maximum number of UDP sessions allowed from/to this
	// vnic, if it is non-zero; zero implies no limit
	MaxUdpSessions int32 `protobuf:"varint,39,opt,name=max_udp_sessions,json=maxUdpSessions,proto3" json:"max_udp_sessions,omitempty"`
	// max_icmp_sessions is the maximum number of ICMP sessions allowed from/to this
	// vnic, if it is non-zero; zero implies no limit
	MaxIcmpSessions int32 `protobuf:"varint,40,opt,name=max_icmp_sessions,json=maxIcmpSessions,proto3" json:"max_icmp_sessions,omitempty"`
	// max other session is the maximum number of non-TCP/UDP/ICMP sessions allowed
	// from/to this vnic; zero implies no limit
	MaxOtherSessions int32 `protobuf:"varint,41,opt,name=max_other_sessions,json=maxOtherSessions,proto3" json:"max_other_sessions,omitempty"`
}

func (x *VnicSpec) Reset() {
	*x = VnicSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_vnic_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VnicSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VnicSpec) ProtoMessage() {}

func (x *VnicSpec) ProtoReflect() protoreflect.Message {
	mi := &file_vnic_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VnicSpec.ProtoReflect.Descriptor instead.
func (*VnicSpec) Descriptor() ([]byte, []int) {
	return file_vnic_proto_rawDescGZIP(), []int{1}
}

func (x *VnicSpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *VnicSpec) GetSubnetId() *_go.ObjectKey {
	if x != nil {
		return x.SubnetId
	}
	return nil
}

func (x *VnicSpec) GetVnicEncap() *_go1.Encap {
	if x != nil {
		return x.VnicEncap
	}
	return nil
}

func (x *VnicSpec) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

func (x *VnicSpec) GetSourceGuardEnable() bool {
	if x != nil {
		return x.SourceGuardEnable
	}
	return false
}

func (x *VnicSpec) GetFabricEncap() *_go1.Encap {
	if x != nil {
		return x.FabricEncap
	}
	return nil
}

func (x *VnicSpec) GetVnf() bool {
	if x != nil {
		return x.Vnf
	}
	return false
}

func (x *VnicSpec) GetIngressV4SecurityPolicyId() []*_go.ObjectKey {
	if x != nil {
		return x.IngressV4SecurityPolicyId
	}
	return nil
}

func (x *VnicSpec) GetIngressV6SecurityPolicyId() []*_go.ObjectKey {
	if x != nil {
		return x.IngressV6SecurityPolicyId
	}
	return nil
}

func (x *VnicSpec) GetEgressV4SecurityPolicyId() []*_go.ObjectKey {
	if x != nil {
		return x.EgressV4SecurityPolicyId
	}
	return nil
}

func (x *VnicSpec) GetEgressV6SecurityPolicyId() []*_go.ObjectKey {
	if x != nil {
		return x.EgressV6SecurityPolicyId
	}
	return nil
}

func (m *VnicSpec) GetIfinfo() isVnicSpec_Ifinfo {
	if m != nil {
		return m.Ifinfo
	}
	return nil
}

func (x *VnicSpec) GetHostIfId() *_go.ObjectKey {
	if x, ok := x.GetIfinfo().(*VnicSpec_HostIfId); ok {
		return x.HostIfId
	}
	return nil
}

func (x *VnicSpec) GetTunnelId() *_go.ObjectKey {
	if x, ok := x.GetIfinfo().(*VnicSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (x *VnicSpec) GetMaxSessions() int32 {
	if x != nil {
		return x.MaxSessions
	}
	return 0
}

func (x *VnicSpec) GetPublicMacAddress() []byte {
	if x != nil {
		return x.PublicMacAddress
	}
	return nil
}

func (x *VnicSpec) GetAllowInternetAccess() bool {
	if x != nil {
		return x.AllowInternetAccess
	}
	return false
}

func (x *VnicSpec) GetMaxCps() int32 {
	if x != nil {
		return x.MaxCps
	}
	return 0
}

func (x *VnicSpec) GetCpsBurst() int32 {
	if x != nil {
		return x.CpsBurst
	}
	return 0
}

func (x *VnicSpec) GetPrimaryVnicId() *_go.ObjectKey {
	if x != nil {
		return x.PrimaryVnicId
	}
	return nil
}

func (x *VnicSpec) GetV4RouteTableId() *_go.ObjectKey {
	if x != nil {
		return x.V4RouteTableId
	}
	return nil
}

func (x *VnicSpec) GetV6RouteTableId() *_go.ObjectKey {
	if x != nil {
		return x.V6RouteTableId
	}
	return nil
}

func (x *VnicSpec) GetServiceIp() *_go1.IPAddress {
	if x != nil {
		return x.ServiceIp
	}
	return nil
}

func (x *VnicSpec) GetMaxTcpSessions() int32 {
	if x != nil {
		return x.MaxTcpSessions
	}
	return 0
}

func (x *VnicSpec) GetMaxUdpSessions() int32 {
	if x != nil {
		return x.MaxUdpSessions
	}
	return 0
}

func (x *VnicSpec) GetMaxIcmpSessions() int32 {
	if x != nil {
		return x.MaxIcmpSessions
	}
	return 0
}

func (x *VnicSpec) GetMaxOtherSessions() int32 {
	if x != nil {
		return x.MaxOtherSessions
	}
	return 0
}

type isVnicSpec_Ifinfo interface {
	isVnicSpec_Ifinfo()
}

type VnicSpec_HostIfId struct {
	// if VNIC Is attahced to a PF/VF, this identifies the corresponding interface object
	HostIfId *_go.ObjectKey `protobuf:"bytes,12,opt,name=host_if_id,json=hostIfId,proto3,oneof"`
}

type VnicSpec_TunnelId struct {
	// when operating in DEVICE_OPER_MODE_SMART_SWITCH, vnic can be behind a
	// tunnel between the host and the DSC
	TunnelId *_go.ObjectKey `protobuf:"bytes,15,opt,name=tunnel_id,json=tunnelId,proto3,oneof"`
}

func (*VnicSpec_HostIfId) isVnicSpec_Ifinfo() {}

func (*VnicSpec_TunnelId) isVnicSpec_Ifinfo() {}

// operational status of Vnic, if any
type VnicStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// true if vnic's configured total session limit is hit
	MaxSessionLimitHit bool `protobuf:"varint,13,opt,name=max_session_limit_hit,json=maxSessionLimitHit,proto3" json:"max_session_limit_hit,omitempty"`
	// true if vnic's configured TCP session limit is hit
	MaxTcpSessionLimitHit bool `protobuf:"varint,14,opt,name=max_tcp_session_limit_hit,json=maxTcpSessionLimitHit,proto3" json:"max_tcp_session_limit_hit,omitempty"`
	// true if vnic's configured UDP session limit is hit
	MaxUdpSessionLimitHit bool `protobuf:"varint,15,opt,name=max_udp_session_limit_hit,json=maxUdpSessionLimitHit,proto3" json:"max_udp_session_limit_hit,omitempty"`
	// true if vnic's configured ICMP session limit is hit
	MaxIcmpSessionLimitHit bool `protobuf:"varint,16,opt,name=max_icmp_session_limit_hit,json=maxIcmpSessionLimitHit,proto3" json:"max_icmp_session_limit_hit,omitempty"`
	// true if vnic's configured non-TCP/UDP/ICMP session limit is hit
	MaxOtherSessionLimitHit bool `protobuf:"varint,17,opt,name=max_other_session_limit_hit,json=maxOtherSessionLimitHit,proto3" json:"max_other_session_limit_hit,omitempty"`
	// h/w id of the vnic
	HwIdx int32 `protobuf:"varint,1,opt,name=hw_idx,json=hwIdx,proto3" json:"hw_idx,omitempty"`
	// nexthop h/w id
	NexthopHwIdx int32 `protobuf:"varint,2,opt,name=nexthop_hw_idx,json=nexthopHwIdx,proto3" json:"nexthop_hw_idx,omitempty"`
	// ARM cpu bound policer hw_idx for CPS rate limiting
	CpsCoppHwIdx int32 `protobuf:"varint,10,opt,name=cps_copp_hw_idx,json=cpsCoppHwIdx,proto3" json:"cps_copp_hw_idx,omitempty"`
	// secondary vnic of (primary) vnic
	SecondaryVnicId *_go.ObjectKey `protobuf:"bytes,11,opt,name=secondary_vnic_id,json=secondaryVnicId,proto3" json:"secondary_vnic_id,omitempty"`
}

func (x *VnicStatus) Reset() {
	*x = VnicStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_vnic_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *VnicStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VnicStatus) ProtoMessage() {}

func (x *VnicStatus) ProtoReflect() protoreflect.Message {
	mi := &file_vnic_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VnicStatus.ProtoReflect.Descriptor instead.
func (*VnicStatus) Descriptor() ([]byte, []int) {
	return file_vnic_proto_rawDescGZIP(), []int{2}
}

func (x *VnicStatus) GetMaxSessionLimitHit() bool {
	if x != nil {
		return x.MaxSessionLimitHit
	}
	return false
}

func (x *VnicStatus) GetMaxTcpSessionLimitHit() bool {
	if x != nil {
		return x.MaxTcpSessionLimitHit
	}
	return false
}

func (x *VnicStatus) GetMaxUdpSessionLimitHit() bool {
	if x != nil {
		return x.MaxUdpSessionLimitHit
	}
	return false
}

func (x *VnicStatus) GetMaxIcmpSessionLimitHit() bool {
	if x != nil {
		return x.MaxIcmpSessionLimitHit
	}
	return false
}

func (x *VnicStatus) GetMaxOtherSessionLimitHit() bool {
	if x != nil {
		return x.MaxOtherSessionLimitHit
	}
	return false
}

func (x *VnicStatus) GetHwIdx() int32 {
	if x != nil {
		return x.HwIdx
	}
	return 0
}

func (x *VnicStatus) GetNexthopHwIdx() int32 {
	if x != nil {
		return x.NexthopHwIdx
	}
	return 0
}

func (x *VnicStatus) GetCpsCoppHwIdx() int32 {
	if x != nil {
		return x.CpsCoppHwIdx
	}
	return 0
}

func (x *VnicStatus) GetSecondaryVnicId() *_go.ObjectKey {
	if x != nil {
		return x.SecondaryVnicId
	}
	return nil
}

var File_vnic_proto protoreflect.FileDescriptor

var file_vnic_proto_rawDesc = []byte{
	0x0a, 0x0a, 0x76, 0x6e, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x1a, 0x10, 0x6f, 0x62,
	0x6a, 0x65, 0x63, 0x74, 0x5f, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x12,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0x88, 0x01, 0x0a, 0x04, 0x56, 0x6e, 0x69, 0x63, 0x12, 0x3c, 0x0a, 0x04, 0x73,
	0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x56, 0x6e, 0x69, 0x63, 0x53,
	0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x42, 0x0a, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x56, 0x6e, 0x69, 0x63, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x87, 0x0c,
	0x0a, 0x08, 0x56, 0x6e, 0x69, 0x63, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63,
	0x74, 0x4b, 0x65, 0x79, 0x52, 0x02, 0x69, 0x64, 0x12, 0x39, 0x0a, 0x09, 0x73, 0x75, 0x62, 0x6e,
	0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x08, 0x73, 0x75, 0x62, 0x6e, 0x65,
	0x74, 0x49, 0x64, 0x12, 0x4b, 0x0a, 0x0a, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x65, 0x6e, 0x63, 0x61,
	0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x45, 0x6e, 0x63, 0x61, 0x70, 0x52, 0x09, 0x76, 0x6e, 0x69, 0x63, 0x45, 0x6e, 0x63, 0x61, 0x70,
	0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x6d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x2e, 0x0a, 0x13, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x67, 0x75, 0x61, 0x72,
	0x64, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x11,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x47, 0x75, 0x61, 0x72, 0x64, 0x45, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x12, 0x4f, 0x0a, 0x0c, 0x66, 0x61, 0x62, 0x72, 0x69, 0x63, 0x5f, 0x65, 0x6e, 0x63, 0x61,
	0x70, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x45, 0x6e, 0x63, 0x61, 0x70, 0x52, 0x0b, 0x66, 0x61, 0x62, 0x72, 0x69, 0x63, 0x45, 0x6e, 0x63,
	0x61, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x6e, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x03, 0x76, 0x6e, 0x66, 0x12, 0x5e, 0x0a, 0x1d, 0x69, 0x6e, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f,
	0x76, 0x34, 0x5f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x19, 0x69, 0x6e, 0x67, 0x72, 0x65,
	0x73, 0x73, 0x56, 0x34, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x49, 0x64, 0x12, 0x5e, 0x0a, 0x1d, 0x69, 0x6e, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f,
	0x76, 0x36, 0x5f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x19, 0x69, 0x6e, 0x67, 0x72, 0x65,
	0x73, 0x73, 0x56, 0x36, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x49, 0x64, 0x12, 0x5c, 0x0a, 0x1c, 0x65, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x76,
	0x34, 0x5f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x5f, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f,
	0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x18, 0x65, 0x67, 0x72, 0x65, 0x73, 0x73,
	0x56, 0x34, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x49, 0x64, 0x12, 0x5c, 0x0a, 0x1c, 0x65, 0x67, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x76, 0x36, 0x5f,
	0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f,
	0x69, 0x64, 0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61,
	0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x18, 0x65, 0x67, 0x72, 0x65, 0x73, 0x73, 0x56, 0x36,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x64,
	0x12, 0x3c, 0x0a, 0x0a, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x69, 0x66, 0x5f, 0x69, 0x64, 0x18, 0x0c,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b,
	0x65, 0x79, 0x48, 0x00, 0x52, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x49, 0x66, 0x49, 0x64, 0x12, 0x3b,
	0x0a, 0x09, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x0f, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x48,
	0x00, 0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x6d,
	0x61, 0x78, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x14, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0b, 0x6d, 0x61, 0x78, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2c,
	0x0a, 0x12, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x70, 0x75, 0x62, 0x6c,
	0x69, 0x63, 0x4d, 0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x32, 0x0a, 0x15,
	0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x5f, 0x61,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x61, 0x6c, 0x6c,
	0x6f, 0x77, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x12, 0x17, 0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f, 0x63, 0x70, 0x73, 0x18, 0x1d, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x06, 0x6d, 0x61, 0x78, 0x43, 0x70, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x70, 0x73,
	0x5f, 0x62, 0x75, 0x72, 0x73, 0x74, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x63, 0x70,
	0x73, 0x42, 0x75, 0x72, 0x73, 0x74, 0x12, 0x44, 0x0a, 0x0f, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72,
	0x79, 0x5f, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x69, 0x64, 0x18, 0x20, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x0d, 0x70,
	0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x56, 0x6e, 0x69, 0x63, 0x49, 0x64, 0x12, 0x47, 0x0a, 0x11,
	0x76, 0x34, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x69,
	0x64, 0x18, 0x21, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65,
	0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x0e, 0x76, 0x34, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x54, 0x61,
	0x62, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x47, 0x0a, 0x11, 0x76, 0x36, 0x5f, 0x72, 0x6f, 0x75, 0x74,
	0x65, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x22, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x0e,
	0x76, 0x36, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x4f,
	0x0a, 0x0a, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x24, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x09, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x70, 0x12,
	0x28, 0x0a, 0x10, 0x6d, 0x61, 0x78, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x73, 0x18, 0x26, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x6d, 0x61, 0x78, 0x54, 0x63,
	0x70, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x6d, 0x61, 0x78,
	0x5f, 0x75, 0x64, 0x70, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x27, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x0e, 0x6d, 0x61, 0x78, 0x55, 0x64, 0x70, 0x53, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x73, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x63, 0x6d, 0x70, 0x5f,
	0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x28, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f,
	0x6d, 0x61, 0x78, 0x49, 0x63, 0x6d, 0x70, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12,
	0x2c, 0x0a, 0x12, 0x6d, 0x61, 0x78, 0x5f, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x73, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x29, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x6d, 0x61, 0x78,
	0x4f, 0x74, 0x68, 0x65, 0x72, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x08, 0x0a,
	0x06, 0x69, 0x66, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0xdb, 0x03, 0x0a, 0x0a, 0x56, 0x6e, 0x69, 0x63,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x31, 0x0a, 0x15, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x12, 0x38, 0x0a, 0x19, 0x6d, 0x61, 0x78,
	0x5f, 0x74, 0x63, 0x70, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x69, 0x6d,
	0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x6d, 0x61,
	0x78, 0x54, 0x63, 0x70, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x48, 0x69, 0x74, 0x12, 0x38, 0x0a, 0x19, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x64, 0x70, 0x5f, 0x73,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74,
	0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x6d, 0x61, 0x78, 0x55, 0x64, 0x70, 0x53, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x12, 0x3a, 0x0a,
	0x1a, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x10, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x16, 0x6d, 0x61, 0x78, 0x49, 0x63, 0x6d, 0x70, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x12, 0x3c, 0x0a, 0x1b, 0x6d, 0x61, 0x78,
	0x5f, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6c,
	0x69, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x11, 0x20, 0x01, 0x28, 0x08, 0x52, 0x17,
	0x6d, 0x61, 0x78, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x4c,
	0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x12, 0x15, 0x0a, 0x06, 0x68, 0x77, 0x5f, 0x69, 0x64,
	0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x68, 0x77, 0x49, 0x64, 0x78, 0x12, 0x24,
	0x0a, 0x0e, 0x6e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x5f, 0x68, 0x77, 0x5f, 0x69, 0x64, 0x78,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x6e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x48,
	0x77, 0x49, 0x64, 0x78, 0x12, 0x25, 0x0a, 0x0f, 0x63, 0x70, 0x73, 0x5f, 0x63, 0x6f, 0x70, 0x70,
	0x5f, 0x68, 0x77, 0x5f, 0x69, 0x64, 0x78, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x63,
	0x70, 0x73, 0x43, 0x6f, 0x70, 0x70, 0x48, 0x77, 0x49, 0x64, 0x78, 0x12, 0x48, 0x0a, 0x11, 0x73,
	0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x5f, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x69, 0x64,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63,
	0x74, 0x4b, 0x65, 0x79, 0x52, 0x0f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x56,
	0x6e, 0x69, 0x63, 0x49, 0x64, 0x42, 0x6a, 0x0a, 0x1e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x42, 0x09, 0x56, 0x6e, 0x69, 0x63, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x50, 0x01, 0x5a, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x6f, 0x70, 0x69, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6f, 0x70, 0x69, 0x2d,
	0x61, 0x70, 0x69, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2f, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67,
	0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_vnic_proto_rawDescOnce sync.Once
	file_vnic_proto_rawDescData = file_vnic_proto_rawDesc
)

func file_vnic_proto_rawDescGZIP() []byte {
	file_vnic_proto_rawDescOnce.Do(func() {
		file_vnic_proto_rawDescData = protoimpl.X.CompressGZIP(file_vnic_proto_rawDescData)
	})
	return file_vnic_proto_rawDescData
}

var file_vnic_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_vnic_proto_goTypes = []interface{}{
	(*Vnic)(nil),           // 0: opi_api.network.cloud.v1alpha1.Vnic
	(*VnicSpec)(nil),       // 1: opi_api.network.cloud.v1alpha1.VnicSpec
	(*VnicStatus)(nil),     // 2: opi_api.network.cloud.v1alpha1.VnicStatus
	(*_go.ObjectKey)(nil),  // 3: opi_api.common.v1.ObjectKey
	(*_go1.Encap)(nil),     // 4: opi_api.network.opinetcommon.v1alpha1.Encap
	(*_go1.IPAddress)(nil), // 5: opi_api.network.opinetcommon.v1alpha1.IPAddress
}
var file_vnic_proto_depIdxs = []int32{
	1,  // 0: opi_api.network.cloud.v1alpha1.Vnic.spec:type_name -> opi_api.network.cloud.v1alpha1.VnicSpec
	2,  // 1: opi_api.network.cloud.v1alpha1.Vnic.status:type_name -> opi_api.network.cloud.v1alpha1.VnicStatus
	3,  // 2: opi_api.network.cloud.v1alpha1.VnicSpec.id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 3: opi_api.network.cloud.v1alpha1.VnicSpec.subnet_id:type_name -> opi_api.common.v1.ObjectKey
	4,  // 4: opi_api.network.cloud.v1alpha1.VnicSpec.vnic_encap:type_name -> opi_api.network.opinetcommon.v1alpha1.Encap
	4,  // 5: opi_api.network.cloud.v1alpha1.VnicSpec.fabric_encap:type_name -> opi_api.network.opinetcommon.v1alpha1.Encap
	3,  // 6: opi_api.network.cloud.v1alpha1.VnicSpec.ingress_v4_security_policy_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 7: opi_api.network.cloud.v1alpha1.VnicSpec.ingress_v6_security_policy_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 8: opi_api.network.cloud.v1alpha1.VnicSpec.egress_v4_security_policy_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 9: opi_api.network.cloud.v1alpha1.VnicSpec.egress_v6_security_policy_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 10: opi_api.network.cloud.v1alpha1.VnicSpec.host_if_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 11: opi_api.network.cloud.v1alpha1.VnicSpec.tunnel_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 12: opi_api.network.cloud.v1alpha1.VnicSpec.primary_vnic_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 13: opi_api.network.cloud.v1alpha1.VnicSpec.v4_route_table_id:type_name -> opi_api.common.v1.ObjectKey
	3,  // 14: opi_api.network.cloud.v1alpha1.VnicSpec.v6_route_table_id:type_name -> opi_api.common.v1.ObjectKey
	5,  // 15: opi_api.network.cloud.v1alpha1.VnicSpec.service_ip:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	3,  // 16: opi_api.network.cloud.v1alpha1.VnicStatus.secondary_vnic_id:type_name -> opi_api.common.v1.ObjectKey
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_vnic_proto_init() }
func file_vnic_proto_init() {
	if File_vnic_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_vnic_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Vnic); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_vnic_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VnicSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_vnic_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*VnicStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_vnic_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*VnicSpec_HostIfId)(nil),
		(*VnicSpec_TunnelId)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_vnic_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vnic_proto_goTypes,
		DependencyIndexes: file_vnic_proto_depIdxs,
		MessageInfos:      file_vnic_proto_msgTypes,
	}.Build()
	File_vnic_proto = out.File
	file_vnic_proto_rawDesc = nil
	file_vnic_proto_goTypes = nil
	file_vnic_proto_depIdxs = nil
}
