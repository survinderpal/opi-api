// Copyright (c) 2023 Pensando, AMD Inc, or its subsidiaries.
// protobuf specification for ip mappings of tenant workloads

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: mapping.proto

package _go

import (
	_go "github.com/opiproject/opi-api/common/v1/gen/go"
	_go1 "github.com/opiproject/opi-api/network/opinetcommon/v1alpha1/gen/go"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MappingType captures the type of the mapping
type MappingType int32

const (
	// unspecified
	MappingType_MAPPING_TYPE_UNSPECIFIED MappingType = 0
	// MAPPING_TYPE_VPC is used for regular VPC endpoints and is the default
	MappingType_MAPPING_TYPE_VPC MappingType = 1
	// MAPPING_TYPE_SERVICE is used for mappings that represent service endpoints
	MappingType_MAPPING_TYPE_SERVICE MappingType = 2
	// MAPPING_TYPE_LB_VIP is used for mappings that represent load balancer service VIP
	MappingType_MAPPING_TYPE_LB_VIP MappingType = 3
)

// Enum value maps for MappingType.
var (
	MappingType_name = map[int32]string{
		0: "MAPPING_TYPE_UNSPECIFIED",
		1: "MAPPING_TYPE_VPC",
		2: "MAPPING_TYPE_SERVICE",
		3: "MAPPING_TYPE_LB_VIP",
	}
	MappingType_value = map[string]int32{
		"MAPPING_TYPE_UNSPECIFIED": 0,
		"MAPPING_TYPE_VPC":         1,
		"MAPPING_TYPE_SERVICE":     2,
		"MAPPING_TYPE_LB_VIP":      3,
	}
)

func (x MappingType) Enum() *MappingType {
	p := new(MappingType)
	*p = x
	return p
}

func (x MappingType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MappingType) Descriptor() protoreflect.EnumDescriptor {
	return file_mapping_proto_enumTypes[0].Descriptor()
}

func (MappingType) Type() protoreflect.EnumType {
	return &file_mapping_proto_enumTypes[0]
}

func (x MappingType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MappingType.Descriptor instead.
func (MappingType) EnumDescriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{0}
}

// mapping key type can be L2 or L3
type MappingKeyType int32

const (
	// unspecified
	MappingKeyType_MAPPING_KEY_TYPE_UNSPECIFIED MappingKeyType = 0
	// l2 mapping
	MappingKeyType_MAPPING_KEY_TYPE_L2 MappingKeyType = 1
	// l3 mapping
	MappingKeyType_MAPPING_KEY_TYPE_L3 MappingKeyType = 2
)

// Enum value maps for MappingKeyType.
var (
	MappingKeyType_name = map[int32]string{
		0: "MAPPING_KEY_TYPE_UNSPECIFIED",
		1: "MAPPING_KEY_TYPE_L2",
		2: "MAPPING_KEY_TYPE_L3",
	}
	MappingKeyType_value = map[string]int32{
		"MAPPING_KEY_TYPE_UNSPECIFIED": 0,
		"MAPPING_KEY_TYPE_L2":          1,
		"MAPPING_KEY_TYPE_L3":          2,
	}
)

func (x MappingKeyType) Enum() *MappingKeyType {
	p := new(MappingKeyType)
	*p = x
	return p
}

func (x MappingKeyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MappingKeyType) Descriptor() protoreflect.EnumDescriptor {
	return file_mapping_proto_enumTypes[1].Descriptor()
}

func (MappingKeyType) Type() protoreflect.EnumType {
	return &file_mapping_proto_enumTypes[1]
}

func (x MappingKeyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MappingKeyType.Descriptor instead.
func (MappingKeyType) EnumDescriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{1}
}

// mapping object
type Mapping struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// configuration
	Spec *MappingSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// status
	Status *MappingStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *Mapping) Reset() {
	*x = Mapping{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Mapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Mapping) ProtoMessage() {}

func (x *Mapping) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Mapping.ProtoReflect.Descriptor instead.
func (*Mapping) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{0}
}

func (x *Mapping) GetSpec() *MappingSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Mapping) GetStatus() *MappingStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// MappingSpec captures configuration of each mapping
// NOTE: Mapping is either on the local host/TEP or remote TEP
type MappingSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// unique mapping id
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// along with uuid, either IPKey or MACKey attrs
	//
	// Types that are assignable to MacOrIp:
	//	*MappingSpec_IpKey
	//	*MappingSpec_MacKey
	MacOrIp isMappingSpec_MacOrIp `protobuf_oneof:"mac_or_ip"`
	// subnet this mapping is in
	SubnetId *_go.ObjectKey `protobuf:"bytes,4,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// mapping's destination information
	//
	// Types that are assignable to Dstinfo:
	//	*MappingSpec_VnicId
	//	*MappingSpec_TunnelId
	//	*MappingSpec_NhGroupId
	Dstinfo isMappingSpec_Dstinfo `protobuf_oneof:"dstinfo"`
	// overlay MAC address of this mapping
	MacAddr []byte `protobuf:"bytes,8,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
	// fabric encap information specific to this mapping, if any
	Encap *_go1.Encap `protobuf:"bytes,9,opt,name=encap,proto3" json:"encap,omitempty"`
	// public IP, if overlay IP has corresponding public IP
	PublicIp *_go1.IPAddress `protobuf:"bytes,10,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	// tag/label/security group of this IP mapping, these tags/labels/SGs can be
	// used in defining security policy rules
	// range: 1 - 4294967294
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: the allowed values need it to be uint32. --)
	Tags []uint32 `protobuf:"varint,11,rep,packed,name=tags,proto3" json:"tags,omitempty"`
	// type of the IP mapping endpoint, default is vpc mapping
	Type MappingType `protobuf:"varint,12,opt,name=type,proto3,enum=opi_api.network.cloud.v1alpha1.MappingType" json:"type,omitempty"`
}

func (x *MappingSpec) Reset() {
	*x = MappingSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MappingSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MappingSpec) ProtoMessage() {}

func (x *MappingSpec) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MappingSpec.ProtoReflect.Descriptor instead.
func (*MappingSpec) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{1}
}

func (x *MappingSpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (m *MappingSpec) GetMacOrIp() isMappingSpec_MacOrIp {
	if m != nil {
		return m.MacOrIp
	}
	return nil
}

func (x *MappingSpec) GetIpKey() *L3MappingKey {
	if x, ok := x.GetMacOrIp().(*MappingSpec_IpKey); ok {
		return x.IpKey
	}
	return nil
}

func (x *MappingSpec) GetMacKey() *L2MappingKey {
	if x, ok := x.GetMacOrIp().(*MappingSpec_MacKey); ok {
		return x.MacKey
	}
	return nil
}

func (x *MappingSpec) GetSubnetId() *_go.ObjectKey {
	if x != nil {
		return x.SubnetId
	}
	return nil
}

func (m *MappingSpec) GetDstinfo() isMappingSpec_Dstinfo {
	if m != nil {
		return m.Dstinfo
	}
	return nil
}

func (x *MappingSpec) GetVnicId() *_go.ObjectKey {
	if x, ok := x.GetDstinfo().(*MappingSpec_VnicId); ok {
		return x.VnicId
	}
	return nil
}

func (x *MappingSpec) GetTunnelId() *_go.ObjectKey {
	if x, ok := x.GetDstinfo().(*MappingSpec_TunnelId); ok {
		return x.TunnelId
	}
	return nil
}

func (x *MappingSpec) GetNhGroupId() *_go.ObjectKey {
	if x, ok := x.GetDstinfo().(*MappingSpec_NhGroupId); ok {
		return x.NhGroupId
	}
	return nil
}

func (x *MappingSpec) GetMacAddr() []byte {
	if x != nil {
		return x.MacAddr
	}
	return nil
}

func (x *MappingSpec) GetEncap() *_go1.Encap {
	if x != nil {
		return x.Encap
	}
	return nil
}

func (x *MappingSpec) GetPublicIp() *_go1.IPAddress {
	if x != nil {
		return x.PublicIp
	}
	return nil
}

func (x *MappingSpec) GetTags() []uint32 {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *MappingSpec) GetType() MappingType {
	if x != nil {
		return x.Type
	}
	return MappingType_MAPPING_TYPE_UNSPECIFIED
}

type isMappingSpec_MacOrIp interface {
	isMappingSpec_MacOrIp()
}

type MappingSpec_IpKey struct {
	// IP mapping key
	IpKey *L3MappingKey `protobuf:"bytes,2,opt,name=ip_key,json=ipKey,proto3,oneof"`
}

type MappingSpec_MacKey struct {
	// MAC mapping key
	MacKey *L2MappingKey `protobuf:"bytes,3,opt,name=mac_key,json=macKey,proto3,oneof"`
}

func (*MappingSpec_IpKey) isMappingSpec_MacOrIp() {}

func (*MappingSpec_MacKey) isMappingSpec_MacOrIp() {}

type isMappingSpec_Dstinfo interface {
	isMappingSpec_Dstinfo()
}

type MappingSpec_VnicId struct {
	// if IP is that of local vnic, corresponding vnic id
	// this is mandatory attribute for local IP mappings
	VnicId *_go.ObjectKey `protobuf:"bytes,5,opt,name=vnic_id,json=vnicId,proto3,oneof"`
}

type MappingSpec_TunnelId struct {
	// Tunnel ID of the remote TEP for remote mapping
	// this is mandatory attribute for remote MAC/IP mappings for
	// non-ECMP cases
	TunnelId *_go.ObjectKey `protobuf:"bytes,6,opt,name=tunnel_id,json=tunnelId,proto3,oneof"`
}

type MappingSpec_NhGroupId struct {
	// overlay nexthop/TEP group for remote mappings
	// this is mandatory attribute for remote MAC/IP mappings for ECMP cases
	NhGroupId *_go.ObjectKey `protobuf:"bytes,7,opt,name=nh_group_id,json=nhGroupId,proto3,oneof"`
}

func (*MappingSpec_VnicId) isMappingSpec_Dstinfo() {}

func (*MappingSpec_TunnelId) isMappingSpec_Dstinfo() {}

func (*MappingSpec_NhGroupId) isMappingSpec_Dstinfo() {}

// operational status of a mapping
type MappingStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// private to public IP xlation nat index
	PublicNatIndex int32 `protobuf:"varint,1,opt,name=public_nat_index,json=publicNatIndex,proto3" json:"public_nat_index,omitempty"`
	// public to private IP xlation nat index
	PrivateNatIndex int32 `protobuf:"varint,2,opt,name=private_nat_index,json=privateNatIndex,proto3" json:"private_nat_index,omitempty"`
	// tunnel IP address
	TunnelIp []*_go1.IPAddress `protobuf:"bytes,3,rep,name=tunnel_ip,json=tunnelIp,proto3" json:"tunnel_ip,omitempty"`
	// service to backend port mapping hw handle
	SvcPortMapHwHandle *_go1.HwHandle `protobuf:"bytes,4,opt,name=svc_port_map_hw_handle,json=svcPortMapHwHandle,proto3" json:"svc_port_map_hw_handle,omitempty"`
	// VNF tunnel hw handle
	VnfTunnelHwHandle *_go1.HwHandle `protobuf:"bytes,5,opt,name=vnf_tunnel_hw_handle,json=vnfTunnelHwHandle,proto3" json:"vnf_tunnel_hw_handle,omitempty"`
	// rewrite index
	RewriteIndex int32 `protobuf:"varint,6,opt,name=rewrite_index,json=rewriteIndex,proto3" json:"rewrite_index,omitempty"`
}

func (x *MappingStatus) Reset() {
	*x = MappingStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MappingStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MappingStatus) ProtoMessage() {}

func (x *MappingStatus) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MappingStatus.ProtoReflect.Descriptor instead.
func (*MappingStatus) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{2}
}

func (x *MappingStatus) GetPublicNatIndex() int32 {
	if x != nil {
		return x.PublicNatIndex
	}
	return 0
}

func (x *MappingStatus) GetPrivateNatIndex() int32 {
	if x != nil {
		return x.PrivateNatIndex
	}
	return 0
}

func (x *MappingStatus) GetTunnelIp() []*_go1.IPAddress {
	if x != nil {
		return x.TunnelIp
	}
	return nil
}

func (x *MappingStatus) GetSvcPortMapHwHandle() *_go1.HwHandle {
	if x != nil {
		return x.SvcPortMapHwHandle
	}
	return nil
}

func (x *MappingStatus) GetVnfTunnelHwHandle() *_go1.HwHandle {
	if x != nil {
		return x.VnfTunnelHwHandle
	}
	return nil
}

func (x *MappingStatus) GetRewriteIndex() int32 {
	if x != nil {
		return x.RewriteIndex
	}
	return 0
}

// L3MappingKey is the 2nd-ary key of the remote IP mapping
type L3MappingKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// virtual private cloud of the IP mapping
	VpcId *_go.ObjectKey `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// private/overlay IP of the mapping
	IpAddress *_go1.IPAddress `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (x *L3MappingKey) Reset() {
	*x = L3MappingKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *L3MappingKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L3MappingKey) ProtoMessage() {}

func (x *L3MappingKey) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L3MappingKey.ProtoReflect.Descriptor instead.
func (*L3MappingKey) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{3}
}

func (x *L3MappingKey) GetVpcId() *_go.ObjectKey {
	if x != nil {
		return x.VpcId
	}
	return nil
}

func (x *L3MappingKey) GetIpAddress() *_go1.IPAddress {
	if x != nil {
		return x.IpAddress
	}
	return nil
}

// L2MappingKey is the 2nd-ary key of the remote MAC mapping
type L2MappingKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// subnet id of this MAC
	SubnetId *_go.ObjectKey `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// MAC address of this mapping
	MacAddress []byte `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (x *L2MappingKey) Reset() {
	*x = L2MappingKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *L2MappingKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*L2MappingKey) ProtoMessage() {}

func (x *L2MappingKey) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use L2MappingKey.ProtoReflect.Descriptor instead.
func (*L2MappingKey) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{4}
}

func (x *L2MappingKey) GetSubnetId() *_go.ObjectKey {
	if x != nil {
		return x.SubnetId
	}
	return nil
}

func (x *L2MappingKey) GetMacAddress() []byte {
	if x != nil {
		return x.MacAddress
	}
	return nil
}

// Filter criteria for a mapping lookup api
type MappingLookupFilter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Local is set to true for local mappings or else false
	Local bool `protobuf:"varint,1,opt,name=local,proto3" json:"local,omitempty"`
	// KeyType is used for query based on L3 or L2 without specifically
	// providing exact key (i.e. list all L2/L3 mappings)
	KeyType MappingKeyType `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3,enum=opi_api.network.cloud.v1alpha1.MappingKeyType" json:"key_type,omitempty"`
	// Type is used to specify the type of mapping
	Type MappingType `protobuf:"varint,3,opt,name=type,proto3,enum=opi_api.network.cloud.v1alpha1.MappingType" json:"type,omitempty"`
	// Types that are assignable to IpOrMac:
	//	*MappingLookupFilter_IpKey
	//	*MappingLookupFilter_MacKey
	//	*MappingLookupFilter_IpAddress
	//	*MappingLookupFilter_MacAddress
	//	*MappingLookupFilter_VpcId
	IpOrMac isMappingLookupFilter_IpOrMac `protobuf_oneof:"ip_or_mac"`
}

func (x *MappingLookupFilter) Reset() {
	*x = MappingLookupFilter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mapping_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MappingLookupFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MappingLookupFilter) ProtoMessage() {}

func (x *MappingLookupFilter) ProtoReflect() protoreflect.Message {
	mi := &file_mapping_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MappingLookupFilter.ProtoReflect.Descriptor instead.
func (*MappingLookupFilter) Descriptor() ([]byte, []int) {
	return file_mapping_proto_rawDescGZIP(), []int{5}
}

func (x *MappingLookupFilter) GetLocal() bool {
	if x != nil {
		return x.Local
	}
	return false
}

func (x *MappingLookupFilter) GetKeyType() MappingKeyType {
	if x != nil {
		return x.KeyType
	}
	return MappingKeyType_MAPPING_KEY_TYPE_UNSPECIFIED
}

func (x *MappingLookupFilter) GetType() MappingType {
	if x != nil {
		return x.Type
	}
	return MappingType_MAPPING_TYPE_UNSPECIFIED
}

func (m *MappingLookupFilter) GetIpOrMac() isMappingLookupFilter_IpOrMac {
	if m != nil {
		return m.IpOrMac
	}
	return nil
}

func (x *MappingLookupFilter) GetIpKey() *L3MappingKey {
	if x, ok := x.GetIpOrMac().(*MappingLookupFilter_IpKey); ok {
		return x.IpKey
	}
	return nil
}

func (x *MappingLookupFilter) GetMacKey() *L2MappingKey {
	if x, ok := x.GetIpOrMac().(*MappingLookupFilter_MacKey); ok {
		return x.MacKey
	}
	return nil
}

func (x *MappingLookupFilter) GetIpAddress() *_go1.IPAddress {
	if x, ok := x.GetIpOrMac().(*MappingLookupFilter_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (x *MappingLookupFilter) GetMacAddress() []byte {
	if x, ok := x.GetIpOrMac().(*MappingLookupFilter_MacAddress); ok {
		return x.MacAddress
	}
	return nil
}

func (x *MappingLookupFilter) GetVpcId() *_go.ObjectKey {
	if x, ok := x.GetIpOrMac().(*MappingLookupFilter_VpcId); ok {
		return x.VpcId
	}
	return nil
}

type isMappingLookupFilter_IpOrMac interface {
	isMappingLookupFilter_IpOrMac()
}

type MappingLookupFilter_IpKey struct {
	// IP mapping key
	IpKey *L3MappingKey `protobuf:"bytes,4,opt,name=ip_key,json=ipKey,proto3,oneof"`
}

type MappingLookupFilter_MacKey struct {
	// MAC mapping key
	MacKey *L2MappingKey `protobuf:"bytes,5,opt,name=mac_key,json=macKey,proto3,oneof"`
}

type MappingLookupFilter_IpAddress struct {
	// IP address
	IpAddress *_go1.IPAddress `protobuf:"bytes,6,opt,name=ip_address,json=ipAddress,proto3,oneof"`
}

type MappingLookupFilter_MacAddress struct {
	// MAC address
	MacAddress []byte `protobuf:"bytes,7,opt,name=mac_address,json=macAddress,proto3,oneof"`
}

type MappingLookupFilter_VpcId struct {
	// VPC id
	VpcId *_go.ObjectKey `protobuf:"bytes,8,opt,name=vpc_id,json=vpcId,proto3,oneof"`
}

func (*MappingLookupFilter_IpKey) isMappingLookupFilter_IpOrMac() {}

func (*MappingLookupFilter_MacKey) isMappingLookupFilter_IpOrMac() {}

func (*MappingLookupFilter_IpAddress) isMappingLookupFilter_IpOrMac() {}

func (*MappingLookupFilter_MacAddress) isMappingLookupFilter_IpOrMac() {}

func (*MappingLookupFilter_VpcId) isMappingLookupFilter_IpOrMac() {}

var File_mapping_proto protoreflect.FileDescriptor

var file_mapping_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x1a,
	0x10, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x12, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x91, 0x01, 0x0a, 0x07, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e,
	0x67, 0x12, 0x3f, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2b, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70,
	0x65, 0x63, 0x12, 0x45, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xd7, 0x05, 0x0a, 0x0b, 0x4d, 0x61,
	0x70, 0x70, 0x69, 0x6e, 0x67, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x4b, 0x65, 0x79, 0x52, 0x02, 0x69, 0x64, 0x12, 0x45, 0x0a, 0x06, 0x69, 0x70, 0x5f, 0x6b, 0x65,
	0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x33, 0x4d, 0x61, 0x70, 0x70, 0x69,
	0x6e, 0x67, 0x4b, 0x65, 0x79, 0x48, 0x00, 0x52, 0x05, 0x69, 0x70, 0x4b, 0x65, 0x79, 0x12, 0x47,
	0x0a, 0x07, 0x6d, 0x61, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x4c, 0x32, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65, 0x79, 0x48, 0x00, 0x52,
	0x06, 0x6d, 0x61, 0x63, 0x4b, 0x65, 0x79, 0x12, 0x39, 0x0a, 0x09, 0x73, 0x75, 0x62, 0x6e, 0x65,
	0x74, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f,
	0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x08, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74,
	0x49, 0x64, 0x12, 0x37, 0x0a, 0x07, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65,
	0x79, 0x48, 0x01, 0x52, 0x06, 0x76, 0x6e, 0x69, 0x63, 0x49, 0x64, 0x12, 0x3b, 0x0a, 0x09, 0x74,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x48, 0x01, 0x52, 0x08,
	0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x64, 0x12, 0x3e, 0x0a, 0x0b, 0x6e, 0x68, 0x5f, 0x67,
	0x72, 0x6f, 0x75, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x48, 0x01, 0x52, 0x09, 0x6e,
	0x68, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x6d, 0x61, 0x63, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x41,
	0x64, 0x64, 0x72, 0x12, 0x42, 0x0a, 0x05, 0x65, 0x6e, 0x63, 0x61, 0x70, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x45, 0x6e, 0x63, 0x61, 0x70,
	0x52, 0x05, 0x65, 0x6e, 0x63, 0x61, 0x70, 0x12, 0x4d, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69,
	0x63, 0x5f, 0x69, 0x70, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69,
	0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x08, 0x70, 0x75,
	0x62, 0x6c, 0x69, 0x63, 0x49, 0x70, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x0b,
	0x20, 0x03, 0x28, 0x0d, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x3f, 0x0a, 0x04, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61,
	0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e,
	0x67, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x6d,
	0x61, 0x63, 0x5f, 0x6f, 0x72, 0x5f, 0x69, 0x70, 0x42, 0x09, 0x0a, 0x07, 0x64, 0x73, 0x74, 0x69,
	0x6e, 0x66, 0x6f, 0x22, 0xa0, 0x03, 0x0a, 0x0d, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f,
	0x6e, 0x61, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0e, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4e, 0x61, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12,
	0x2a, 0x0a, 0x11, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x5f, 0x6e, 0x61, 0x74, 0x5f, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x70, 0x72, 0x69, 0x76,
	0x61, 0x74, 0x65, 0x4e, 0x61, 0x74, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x4d, 0x0a, 0x09, 0x74,
	0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x70, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x52, 0x08, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x49, 0x70, 0x12, 0x63, 0x0a, 0x16, 0x73, 0x76,
	0x63, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x5f, 0x6d, 0x61, 0x70, 0x5f, 0x68, 0x77, 0x5f, 0x68, 0x61,
	0x6e, 0x64, 0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69,
	0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x52, 0x12, 0x73, 0x76, 0x63,
	0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x12,
	0x60, 0x0a, 0x14, 0x76, 0x6e, 0x66, 0x5f, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x68, 0x77,
	0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
	0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x52, 0x11,
	0x76, 0x6e, 0x66, 0x54, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c,
	0x65, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x72, 0x65, 0x77, 0x72, 0x69, 0x74,
	0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x22, 0x94, 0x01, 0x0a, 0x0c, 0x4c, 0x33, 0x4d, 0x61, 0x70,
	0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x33, 0x0a, 0x06, 0x76, 0x70, 0x63, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65,
	0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x05, 0x76, 0x70, 0x63, 0x49, 0x64, 0x12, 0x4f, 0x0a, 0x0a,
	0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x09, 0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x6a, 0x0a,
	0x0c, 0x4c, 0x32, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65, 0x79, 0x12, 0x39, 0x0a,
	0x09, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x08,
	0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0a, 0x6d,
	0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0x81, 0x04, 0x0a, 0x13, 0x4d, 0x61,
	0x70, 0x70, 0x69, 0x6e, 0x67, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x46, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x12, 0x49, 0x0a, 0x08, 0x6b, 0x65, 0x79, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x61, 0x70, 0x70, 0x69,
	0x6e, 0x67, 0x4b, 0x65, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x07, 0x6b, 0x65, 0x79, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x3f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x2b, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
	0x79, 0x70, 0x65, 0x12, 0x45, 0x0a, 0x06, 0x69, 0x70, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x33, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65,
	0x79, 0x48, 0x00, 0x52, 0x05, 0x69, 0x70, 0x4b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x07, 0x6d, 0x61,
	0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x32, 0x4d,
	0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65, 0x79, 0x48, 0x00, 0x52, 0x06, 0x6d, 0x61, 0x63,
	0x4b, 0x65, 0x79, 0x12, 0x51, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x48, 0x00, 0x52, 0x09, 0x69, 0x70, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x21, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x5f, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x0a, 0x6d,
	0x61, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x35, 0x0a, 0x06, 0x76, 0x70, 0x63,
	0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62,
	0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x48, 0x00, 0x52, 0x05, 0x76, 0x70, 0x63, 0x49, 0x64,
	0x42, 0x0b, 0x0a, 0x09, 0x69, 0x70, 0x5f, 0x6f, 0x72, 0x5f, 0x6d, 0x61, 0x63, 0x2a, 0x74, 0x0a,
	0x0b, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1c, 0x0a, 0x18,
	0x4d, 0x41, 0x50, 0x50, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x41,
	0x50, 0x50, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x50, 0x43, 0x10, 0x01,
	0x12, 0x18, 0x0a, 0x14, 0x4d, 0x41, 0x50, 0x50, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x10, 0x02, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x41,
	0x50, 0x50, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x42, 0x5f, 0x56, 0x49,
	0x50, 0x10, 0x03, 0x2a, 0x64, 0x0a, 0x0e, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x4b, 0x65,
	0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x4d, 0x41, 0x50, 0x50, 0x49, 0x4e, 0x47,
	0x5f, 0x4b, 0x45, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x41, 0x50, 0x50, 0x49,
	0x4e, 0x47, 0x5f, 0x4b, 0x45, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x32, 0x10, 0x01,
	0x12, 0x17, 0x0a, 0x13, 0x4d, 0x41, 0x50, 0x50, 0x49, 0x4e, 0x47, 0x5f, 0x4b, 0x45, 0x59, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x4c, 0x33, 0x10, 0x02, 0x42, 0x6d, 0x0a, 0x1e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x42, 0x0c, 0x4d, 0x61, 0x70,
	0x70, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x3b, 0x67, 0x69, 0x74,
	0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x70, 0x69, 0x70, 0x72, 0x6f, 0x6a, 0x65,
	0x63, 0x74, 0x2f, 0x6f, 0x70, 0x69, 0x2d, 0x61, 0x70, 0x69, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_mapping_proto_rawDescOnce sync.Once
	file_mapping_proto_rawDescData = file_mapping_proto_rawDesc
)

func file_mapping_proto_rawDescGZIP() []byte {
	file_mapping_proto_rawDescOnce.Do(func() {
		file_mapping_proto_rawDescData = protoimpl.X.CompressGZIP(file_mapping_proto_rawDescData)
	})
	return file_mapping_proto_rawDescData
}

var file_mapping_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_mapping_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_mapping_proto_goTypes = []interface{}{
	(MappingType)(0),            // 0: opi_api.network.cloud.v1alpha1.MappingType
	(MappingKeyType)(0),         // 1: opi_api.network.cloud.v1alpha1.MappingKeyType
	(*Mapping)(nil),             // 2: opi_api.network.cloud.v1alpha1.Mapping
	(*MappingSpec)(nil),         // 3: opi_api.network.cloud.v1alpha1.MappingSpec
	(*MappingStatus)(nil),       // 4: opi_api.network.cloud.v1alpha1.MappingStatus
	(*L3MappingKey)(nil),        // 5: opi_api.network.cloud.v1alpha1.L3MappingKey
	(*L2MappingKey)(nil),        // 6: opi_api.network.cloud.v1alpha1.L2MappingKey
	(*MappingLookupFilter)(nil), // 7: opi_api.network.cloud.v1alpha1.MappingLookupFilter
	(*_go.ObjectKey)(nil),       // 8: opi_api.common.v1.ObjectKey
	(*_go1.Encap)(nil),          // 9: opi_api.network.opinetcommon.v1alpha1.Encap
	(*_go1.IPAddress)(nil),      // 10: opi_api.network.opinetcommon.v1alpha1.IPAddress
	(*_go1.HwHandle)(nil),       // 11: opi_api.network.opinetcommon.v1alpha1.HwHandle
}
var file_mapping_proto_depIdxs = []int32{
	3,  // 0: opi_api.network.cloud.v1alpha1.Mapping.spec:type_name -> opi_api.network.cloud.v1alpha1.MappingSpec
	4,  // 1: opi_api.network.cloud.v1alpha1.Mapping.status:type_name -> opi_api.network.cloud.v1alpha1.MappingStatus
	8,  // 2: opi_api.network.cloud.v1alpha1.MappingSpec.id:type_name -> opi_api.common.v1.ObjectKey
	5,  // 3: opi_api.network.cloud.v1alpha1.MappingSpec.ip_key:type_name -> opi_api.network.cloud.v1alpha1.L3MappingKey
	6,  // 4: opi_api.network.cloud.v1alpha1.MappingSpec.mac_key:type_name -> opi_api.network.cloud.v1alpha1.L2MappingKey
	8,  // 5: opi_api.network.cloud.v1alpha1.MappingSpec.subnet_id:type_name -> opi_api.common.v1.ObjectKey
	8,  // 6: opi_api.network.cloud.v1alpha1.MappingSpec.vnic_id:type_name -> opi_api.common.v1.ObjectKey
	8,  // 7: opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_id:type_name -> opi_api.common.v1.ObjectKey
	8,  // 8: opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_id:type_name -> opi_api.common.v1.ObjectKey
	9,  // 9: opi_api.network.cloud.v1alpha1.MappingSpec.encap:type_name -> opi_api.network.opinetcommon.v1alpha1.Encap
	10, // 10: opi_api.network.cloud.v1alpha1.MappingSpec.public_ip:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	0,  // 11: opi_api.network.cloud.v1alpha1.MappingSpec.type:type_name -> opi_api.network.cloud.v1alpha1.MappingType
	10, // 12: opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	11, // 13: opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle:type_name -> opi_api.network.opinetcommon.v1alpha1.HwHandle
	11, // 14: opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle:type_name -> opi_api.network.opinetcommon.v1alpha1.HwHandle
	8,  // 15: opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_id:type_name -> opi_api.common.v1.ObjectKey
	10, // 16: opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	8,  // 17: opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_id:type_name -> opi_api.common.v1.ObjectKey
	1,  // 18: opi_api.network.cloud.v1alpha1.MappingLookupFilter.key_type:type_name -> opi_api.network.cloud.v1alpha1.MappingKeyType
	0,  // 19: opi_api.network.cloud.v1alpha1.MappingLookupFilter.type:type_name -> opi_api.network.cloud.v1alpha1.MappingType
	5,  // 20: opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key:type_name -> opi_api.network.cloud.v1alpha1.L3MappingKey
	6,  // 21: opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key:type_name -> opi_api.network.cloud.v1alpha1.L2MappingKey
	10, // 22: opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	8,  // 23: opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_id:type_name -> opi_api.common.v1.ObjectKey
	24, // [24:24] is the sub-list for method output_type
	24, // [24:24] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_mapping_proto_init() }
func file_mapping_proto_init() {
	if File_mapping_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_mapping_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Mapping); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mapping_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MappingSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mapping_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MappingStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mapping_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*L3MappingKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mapping_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*L2MappingKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mapping_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MappingLookupFilter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_mapping_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*MappingSpec_IpKey)(nil),
		(*MappingSpec_MacKey)(nil),
		(*MappingSpec_VnicId)(nil),
		(*MappingSpec_TunnelId)(nil),
		(*MappingSpec_NhGroupId)(nil),
	}
	file_mapping_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*MappingLookupFilter_IpKey)(nil),
		(*MappingLookupFilter_MacKey)(nil),
		(*MappingLookupFilter_IpAddress)(nil),
		(*MappingLookupFilter_MacAddress)(nil),
		(*MappingLookupFilter_VpcId)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_mapping_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mapping_proto_goTypes,
		DependencyIndexes: file_mapping_proto_depIdxs,
		EnumInfos:         file_mapping_proto_enumTypes,
		MessageInfos:      file_mapping_proto_msgTypes,
	}.Build()
	File_mapping_proto = out.File
	file_mapping_proto_rawDesc = nil
	file_mapping_proto_goTypes = nil
	file_mapping_proto_depIdxs = nil
}
