// Copyright (c) 2023 Pensando, AMD Inc, or its subsidiaries.
// protobuf specification for network security policies

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: networkpolicy.proto

package _go

import (
	_go "github.com/opiproject/opi-api/common/v1/gen/go"
	_go1 "github.com/opiproject/opi-api/network/opinetcommon/v1alpha1/gen/go"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// types of security policies
type SecurityPolicyType int32

const (
	// unspecified
	SecurityPolicyType_SECURITY_POLICY_TYPE_UNSPECIFIED SecurityPolicyType = 0
	// UNDERLAY security policy object is singleton object per DSC
	SecurityPolicyType_SECURITY_POLICY_TYPE_UNDERLAY SecurityPolicyType = 1
	/// TENANT security policy objects are attached to tenant VPCs
	SecurityPolicyType_SECURITY_POLICY_TYPE_TENANT SecurityPolicyType = 2
)

// Enum value maps for SecurityPolicyType.
var (
	SecurityPolicyType_name = map[int32]string{
		0: "SECURITY_POLICY_TYPE_UNSPECIFIED",
		1: "SECURITY_POLICY_TYPE_UNDERLAY",
		2: "SECURITY_POLICY_TYPE_TENANT",
	}
	SecurityPolicyType_value = map[string]int32{
		"SECURITY_POLICY_TYPE_UNSPECIFIED": 0,
		"SECURITY_POLICY_TYPE_UNDERLAY":    1,
		"SECURITY_POLICY_TYPE_TENANT":      2,
	}
)

func (x SecurityPolicyType) Enum() *SecurityPolicyType {
	p := new(SecurityPolicyType)
	*p = x
	return p
}

func (x SecurityPolicyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SecurityPolicyType) Descriptor() protoreflect.EnumDescriptor {
	return file_networkpolicy_proto_enumTypes[0].Descriptor()
}

func (SecurityPolicyType) Type() protoreflect.EnumType {
	return &file_networkpolicy_proto_enumTypes[0]
}

func (x SecurityPolicyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SecurityPolicyType.Descriptor instead.
func (SecurityPolicyType) EnumDescriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{0}
}

// ALG specifices with Application Level Gateway (ALG) should be invoked
// when a rule match happens. This ALG will also be reported in the flow logs.
// Any platform specific limitations may result into errors during configuration
type ALGType int32

const (
	// unspecified
	ALGType_ALG_TYPE_UNSPECIFIED ALGType = 0
	// TFTP ALG
	ALGType_ALG_TYPE_TFTP ALGType = 1
	// FTP ALG
	ALGType_ALG_TYPE_FTP ALGType = 2
	// DNS ALG
	ALGType_ALG_TYPE_DNS ALGType = 3
	// SUNRPC ALG
	ALGType_ALG_TYPE_SUNRPC ALGType = 4
	// MSRPC ALG
	ALGType_ALG_TYPE_MSRPC ALGType = 5
	// RTSP ALG
	ALGType_ALG_TYPE_RTSP ALGType = 6
)

// Enum value maps for ALGType.
var (
	ALGType_name = map[int32]string{
		0: "ALG_TYPE_UNSPECIFIED",
		1: "ALG_TYPE_TFTP",
		2: "ALG_TYPE_FTP",
		3: "ALG_TYPE_DNS",
		4: "ALG_TYPE_SUNRPC",
		5: "ALG_TYPE_MSRPC",
		6: "ALG_TYPE_RTSP",
	}
	ALGType_value = map[string]int32{
		"ALG_TYPE_UNSPECIFIED": 0,
		"ALG_TYPE_TFTP":        1,
		"ALG_TYPE_FTP":         2,
		"ALG_TYPE_DNS":         3,
		"ALG_TYPE_SUNRPC":      4,
		"ALG_TYPE_MSRPC":       5,
		"ALG_TYPE_RTSP":        6,
	}
)

func (x ALGType) Enum() *ALGType {
	p := new(ALGType)
	*p = x
	return p
}

func (x ALGType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ALGType) Descriptor() protoreflect.EnumDescriptor {
	return file_networkpolicy_proto_enumTypes[1].Descriptor()
}

func (ALGType) Type() protoreflect.EnumType {
	return &file_networkpolicy_proto_enumTypes[1]
}

func (x ALGType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ALGType.Descriptor instead.
func (ALGType) EnumDescriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{1}
}

// PolicyRuleFormat captures what format is used for the rules in a given
// SecurityPolicySpec object
type PolicyRuleFormat int32

const (
	// POLICY_RULE_FORMAT_UNSPECIFIED indicates that user has not set format
	// explicitly, in which case POLICY_RULE_FORMAT_FLATTENED is assumed
	// for an implementation is agnostic to flattened or compressed rules
	PolicyRuleFormat_POLICY_RULE_FORMAT_UNSPECIFIED PolicyRuleFormat = 0
	// POLICY_RULE_FORMAT_FLATTENED is used when xPU expands the
	// user configured rules so that each rule has only single source
	// IP address/prefix/range, destination IP address/prefix/range,
	// source port range, destination port range as match conditions
	// In this format none of the rules must use SrcIPList,
	// DstIPList, PortList, ICMPMatchList attributes, wherever applicable
	PolicyRuleFormat_POLICY_RULE_FORMAT_FLATTENED PolicyRuleFormat = 1
	// POLICY_RULE_FORMAT_COMPACT is used when rules contain list of
	// source IP, destination IP, src port range, destination port ranges
	// as match conditions
	// In this format, ALL the rules must use SrcIPList, DstIPList,
	// PortList, ICMPMatchList attributes only, whereever applicable
	PolicyRuleFormat_POLICY_RULE_FORMAT_COMPACT PolicyRuleFormat = 2
)

// Enum value maps for PolicyRuleFormat.
var (
	PolicyRuleFormat_name = map[int32]string{
		0: "POLICY_RULE_FORMAT_UNSPECIFIED",
		1: "POLICY_RULE_FORMAT_FLATTENED",
		2: "POLICY_RULE_FORMAT_COMPACT",
	}
	PolicyRuleFormat_value = map[string]int32{
		"POLICY_RULE_FORMAT_UNSPECIFIED": 0,
		"POLICY_RULE_FORMAT_FLATTENED":   1,
		"POLICY_RULE_FORMAT_COMPACT":     2,
	}
)

func (x PolicyRuleFormat) Enum() *PolicyRuleFormat {
	p := new(PolicyRuleFormat)
	*p = x
	return p
}

func (x PolicyRuleFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyRuleFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_networkpolicy_proto_enumTypes[2].Descriptor()
}

func (PolicyRuleFormat) Type() protoreflect.EnumType {
	return &file_networkpolicy_proto_enumTypes[2]
}

func (x PolicyRuleFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyRuleFormat.Descriptor instead.
func (PolicyRuleFormat) EnumDescriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{2}
}

// security policy object
type SecurityPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// configuration
	Spec *SecurityPolicySpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// status
	Status *SecurityPolicyStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SecurityPolicy) Reset() {
	*x = SecurityPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityPolicy) ProtoMessage() {}

func (x *SecurityPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityPolicy.ProtoReflect.Descriptor instead.
func (*SecurityPolicy) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{0}
}

func (x *SecurityPolicy) GetSpec() *SecurityPolicySpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *SecurityPolicy) GetStatus() *SecurityPolicyStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// security policy configuration
type SecurityPolicySpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// unique identifier of security policy
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// SecurityPolicyType is either TENANT or UNDERLAY (aka. infra) policy
	// - only one instance of UNDERLAY policy is allowed (or makes sense)
	// - if Type is not specified, policy type defaults to TENANT policy
	Type SecurityPolicyType `protobuf:"varint,2,opt,name=type,proto3,enum=opi_api.network.cloud.v1alpha1.SecurityPolicyType" json:"type,omitempty"`
	// IPv4 or IPv6 policy
	AddressFamily _go1.IpAf `protobuf:"varint,3,opt,name=address_family,json=addressFamily,proto3,enum=opi_api.network.opinetcommon.v1alpha1.IpAf" json:"address_family,omitempty"`
	// when Stateless attribute is set on a policy, the policy is applied for
	// traffic in both directions before deciding the final action of the flow
	// when Stateless is set to false, the policy behavior is same as Network
	// Security Group (NSG) construct whereas if Stateless is set to true, the
	// behavior is same as ACL construct
	Stateless bool `protobuf:"varint,4,opt,name=stateless,proto3" json:"stateless,omitempty"`
	// DefaultFWAction is the action taken by the firewall when security policies are
	// configured on vnic but no rule is hit. Similarly, when NACLs are configured
	// on a subnet and no rule is hit, this action is taken by the firewall.
	// if this attribute is not set, it will inherit from security profile and if
	// that is also not set then  default "deny" action is enforced
	// When no policy is configured on subnet and vnic, this knob doesn't
	// apply and traffic is allowed in that case
	DefaultSecurityAction _go1.SecurityRuleAction `protobuf:"varint,5,opt,name=default_security_action,json=defaultSecurityAction,proto3,enum=opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction" json:"default_security_action,omitempty"`
	// list of security rules
	Rules []*SecurityRuleInfo `protobuf:"bytes,6,rep,name=rules,proto3" json:"rules,omitempty"`
	// PolicyRuleFormat indicates whether the policy is set of flattened rules
	// or whether they are aggregated (DPU can be efficient based ont his hint)
	RuleFormat PolicyRuleFormat `protobuf:"varint,7,opt,name=rule_format,json=ruleFormat,proto3,enum=opi_api.network.cloud.v1alpha1.PolicyRuleFormat" json:"rule_format,omitempty"`
}

func (x *SecurityPolicySpec) Reset() {
	*x = SecurityPolicySpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityPolicySpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityPolicySpec) ProtoMessage() {}

func (x *SecurityPolicySpec) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityPolicySpec.ProtoReflect.Descriptor instead.
func (*SecurityPolicySpec) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{1}
}

func (x *SecurityPolicySpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SecurityPolicySpec) GetType() SecurityPolicyType {
	if x != nil {
		return x.Type
	}
	return SecurityPolicyType_SECURITY_POLICY_TYPE_UNSPECIFIED
}

func (x *SecurityPolicySpec) GetAddressFamily() _go1.IpAf {
	if x != nil {
		return x.AddressFamily
	}
	return _go1.IpAf(0)
}

func (x *SecurityPolicySpec) GetStateless() bool {
	if x != nil {
		return x.Stateless
	}
	return false
}

func (x *SecurityPolicySpec) GetDefaultSecurityAction() _go1.SecurityRuleAction {
	if x != nil {
		return x.DefaultSecurityAction
	}
	return _go1.SecurityRuleAction(0)
}

func (x *SecurityPolicySpec) GetRules() []*SecurityRuleInfo {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *SecurityPolicySpec) GetRuleFormat() PolicyRuleFormat {
	if x != nil {
		return x.RuleFormat
	}
	return PolicyRuleFormat_POLICY_RULE_FORMAT_UNSPECIFIED
}

// SecurityRuleInfo is a single rule in the security policy
type SecurityRuleInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// rule id needed if incremental rule ADD/DEL/UPD functionality is needed
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// rule attributes
	Attrs *SecurityRuleAttrs `protobuf:"bytes,2,opt,name=attrs,proto3" json:"attrs,omitempty"`
}

func (x *SecurityRuleInfo) Reset() {
	*x = SecurityRuleInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityRuleInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRuleInfo) ProtoMessage() {}

func (x *SecurityRuleInfo) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRuleInfo.ProtoReflect.Descriptor instead.
func (*SecurityRuleInfo) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{2}
}

func (x *SecurityRuleInfo) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SecurityRuleInfo) GetAttrs() *SecurityRuleAttrs {
	if x != nil {
		return x.Attrs
	}
	return nil
}

// security rule attributes
type SecurityRuleAttrs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// priority of this rule (lower the numeric value, higher the priority is)
	// if there are multiple rules with same highest priority that match the
	// packet, the first such matching rule in the policy is picked (i.e., based
	// on the order, first in the list of such matching rules)
	// range:0-65534
	Priority int32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
	// rule match criteria
	Match *_go1.RuleMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// action to take when this rule is matched
	Action _go1.SecurityRuleAction `protobuf:"varint,3,opt,name=action,proto3,enum=opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction" json:"action,omitempty"`
	// when a rule marked as terminating is picked (based on the priority) as the
	// matching rule from a policy, then the action of such rule will prevail or
	// stick over the matching rules picked from already evaluated policies and
	// the search for other matching rules in policies yet to be evaluated for
	// that packet will stop (i.e., packet hitting terminating rule will pick
	// corresponding action irrespective any other matching rules across all
	// policies)
	Terminating bool `protobuf:"varint,4,opt,name=terminating,proto3" json:"terminating,omitempty"`
	// ALGSpec, if specified contains ALG specific behavior
	AlgSpec *ALGSpec `protobuf:"bytes,5,opt,name=alg_spec,json=algSpec,proto3" json:"alg_spec,omitempty"`
}

func (x *SecurityRuleAttrs) Reset() {
	*x = SecurityRuleAttrs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityRuleAttrs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRuleAttrs) ProtoMessage() {}

func (x *SecurityRuleAttrs) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRuleAttrs.ProtoReflect.Descriptor instead.
func (*SecurityRuleAttrs) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{3}
}

func (x *SecurityRuleAttrs) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *SecurityRuleAttrs) GetMatch() *_go1.RuleMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *SecurityRuleAttrs) GetAction() _go1.SecurityRuleAction {
	if x != nil {
		return x.Action
	}
	return _go1.SecurityRuleAction(0)
}

func (x *SecurityRuleAttrs) GetTerminating() bool {
	if x != nil {
		return x.Terminating
	}
	return false
}

func (x *SecurityRuleAttrs) GetAlgSpec() *ALGSpec {
	if x != nil {
		return x.AlgSpec
	}
	return nil
}

// FTP ALG specific options
type FTPOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// allow FTP data sessions with IP address that is different from control sessions
	AllowIpMismatch bool `protobuf:"varint,1,opt,name=allow_ip_mismatch,json=allowIpMismatch,proto3" json:"allow_ip_mismatch,omitempty"`
}

func (x *FTPOptions) Reset() {
	*x = FTPOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FTPOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FTPOptions) ProtoMessage() {}

func (x *FTPOptions) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FTPOptions.ProtoReflect.Descriptor instead.
func (*FTPOptions) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{4}
}

func (x *FTPOptions) GetAllowIpMismatch() bool {
	if x != nil {
		return x.AllowIpMismatch
	}
	return false
}

// DNS ALG specific options
// these options are applicable to DNS request messages only
type DNSOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//  when DropMultiQueryMessage is set, drop DNS query messages that contain
	//  more than one DNS query in same packet
	DropMultiQueryMessages bool `protobuf:"varint,1,opt,name=drop_multi_query_messages,json=dropMultiQueryMessages,proto3" json:"drop_multi_query_messages,omitempty"`
	// when DropLargeDomainNameMessage is set, DNS mwessages containing domain
	// name exceeding 255 bytes are dropped
	DropLargeDomainNameMessages bool `protobuf:"varint,2,opt,name=drop_large_domain_name_messages,json=dropLargeDomainNameMessages,proto3" json:"drop_large_domain_name_messages,omitempty"`
	// when DropLongLabelMessage is set, DNS messages containing labels
	// exceeding 63 bytes are dropped
	DropLongLabelMessages bool `protobuf:"varint,3,opt,name=drop_long_label_messages,json=dropLongLabelMessages,proto3" json:"drop_long_label_messages,omitempty"`
	// when DropMultiZoneMessagesis set, DNS messages containing more than one
	// zone are dropped
	DropMultiZoneMessages bool `protobuf:"varint,4,opt,name=drop_multi_zone_messages,json=dropMultiZoneMessages,proto3" json:"drop_multi_zone_messages,omitempty"`
	// DNS session will be closed if response is not seen for a DNS query within
	// ResponseTimeout seconds, default 60
	ResponseTimeout int32 `protobuf:"varint,5,opt,name=response_timeout,json=responseTimeout,proto3" json:"response_timeout,omitempty"`
	// MaxMessageLength defines the maximum length of the DNS query/response
	// message the ALG will handle range:512-8192,default=512
	MaxMessageLength int32 `protobuf:"varint,6,opt,name=max_message_length,json=maxMessageLength,proto3" json:"max_message_length,omitempty"`
}

func (x *DNSOptions) Reset() {
	*x = DNSOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DNSOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSOptions) ProtoMessage() {}

func (x *DNSOptions) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSOptions.ProtoReflect.Descriptor instead.
func (*DNSOptions) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{5}
}

func (x *DNSOptions) GetDropMultiQueryMessages() bool {
	if x != nil {
		return x.DropMultiQueryMessages
	}
	return false
}

func (x *DNSOptions) GetDropLargeDomainNameMessages() bool {
	if x != nil {
		return x.DropLargeDomainNameMessages
	}
	return false
}

func (x *DNSOptions) GetDropLongLabelMessages() bool {
	if x != nil {
		return x.DropLongLabelMessages
	}
	return false
}

func (x *DNSOptions) GetDropMultiZoneMessages() bool {
	if x != nil {
		return x.DropMultiZoneMessages
	}
	return false
}

func (x *DNSOptions) GetResponseTimeout() int32 {
	if x != nil {
		return x.ResponseTimeout
	}
	return 0
}

func (x *DNSOptions) GetMaxMessageLength() int32 {
	if x != nil {
		return x.MaxMessageLength
	}
	return 0
}

// MSRPC ALG specific options
type MSRPCOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// RPC program uuids
	ProgramId [][]byte `protobuf:"bytes,1,rep,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
}

func (x *MSRPCOptions) Reset() {
	*x = MSRPCOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MSRPCOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MSRPCOptions) ProtoMessage() {}

func (x *MSRPCOptions) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MSRPCOptions.ProtoReflect.Descriptor instead.
func (*MSRPCOptions) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{6}
}

func (x *MSRPCOptions) GetProgramId() [][]byte {
	if x != nil {
		return x.ProgramId
	}
	return nil
}

// SunRPC ALG specific options
type SunRPCOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// RPC program identifiers
	ProgramId [][]byte `protobuf:"bytes,1,rep,name=program_id,json=programId,proto3" json:"program_id,omitempty"`
}

func (x *SunRPCOptions) Reset() {
	*x = SunRPCOptions{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SunRPCOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SunRPCOptions) ProtoMessage() {}

func (x *SunRPCOptions) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SunRPCOptions.ProtoReflect.Descriptor instead.
func (*SunRPCOptions) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{7}
}

func (x *SunRPCOptions) GetProgramId() [][]byte {
	if x != nil {
		return x.ProgramId
	}
	return nil
}

// ALC configuration
type ALGSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ALG to invoke (if set to ALG_TYPE_UNSPECIFIED, no ALG is invoked)
	AlgType ALGType `protobuf:"varint,1,opt,name=alg_type,json=algType,proto3,enum=opi_api.network.cloud.v1alpha1.ALGType" json:"alg_type,omitempty"`
	// IdleTimeout indicates ALG specific session timeout in seconds
	// if IdleTimeout is not set, timeout from SecurityProfile object
	// is applied on both control and data sessions of the ALG
	IdleTimeout int32 `protobuf:"varint,2,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// ALG specific options, if any
	//
	// Types that are assignable to AlgOptions:
	//	*ALGSpec_FtpOptions
	//	*ALGSpec_DnsOptions
	//	*ALGSpec_MsrpcOptions
	//	*ALGSpec_SunrpcOptions
	AlgOptions isALGSpec_AlgOptions `protobuf_oneof:"alg_options"`
}

func (x *ALGSpec) Reset() {
	*x = ALGSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ALGSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ALGSpec) ProtoMessage() {}

func (x *ALGSpec) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ALGSpec.ProtoReflect.Descriptor instead.
func (*ALGSpec) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{8}
}

func (x *ALGSpec) GetAlgType() ALGType {
	if x != nil {
		return x.AlgType
	}
	return ALGType_ALG_TYPE_UNSPECIFIED
}

func (x *ALGSpec) GetIdleTimeout() int32 {
	if x != nil {
		return x.IdleTimeout
	}
	return 0
}

func (m *ALGSpec) GetAlgOptions() isALGSpec_AlgOptions {
	if m != nil {
		return m.AlgOptions
	}
	return nil
}

func (x *ALGSpec) GetFtpOptions() *FTPOptions {
	if x, ok := x.GetAlgOptions().(*ALGSpec_FtpOptions); ok {
		return x.FtpOptions
	}
	return nil
}

func (x *ALGSpec) GetDnsOptions() *DNSOptions {
	if x, ok := x.GetAlgOptions().(*ALGSpec_DnsOptions); ok {
		return x.DnsOptions
	}
	return nil
}

func (x *ALGSpec) GetMsrpcOptions() *MSRPCOptions {
	if x, ok := x.GetAlgOptions().(*ALGSpec_MsrpcOptions); ok {
		return x.MsrpcOptions
	}
	return nil
}

func (x *ALGSpec) GetSunrpcOptions() *SunRPCOptions {
	if x, ok := x.GetAlgOptions().(*ALGSpec_SunrpcOptions); ok {
		return x.SunrpcOptions
	}
	return nil
}

type isALGSpec_AlgOptions interface {
	isALGSpec_AlgOptions()
}

type ALGSpec_FtpOptions struct {
	// ftp alg options
	FtpOptions *FTPOptions `protobuf:"bytes,3,opt,name=ftp_options,json=ftpOptions,proto3,oneof"`
}

type ALGSpec_DnsOptions struct {
	// dns alg options
	DnsOptions *DNSOptions `protobuf:"bytes,4,opt,name=dns_options,json=dnsOptions,proto3,oneof"`
}

type ALGSpec_MsrpcOptions struct {
	// msrpc options
	MsrpcOptions *MSRPCOptions `protobuf:"bytes,5,opt,name=msrpc_options,json=msrpcOptions,proto3,oneof"`
}

type ALGSpec_SunrpcOptions struct {
	// sunrpc options
	SunrpcOptions *SunRPCOptions `protobuf:"bytes,6,opt,name=sunrpc_options,json=sunrpcOptions,proto3,oneof"`
}

func (*ALGSpec_FtpOptions) isALGSpec_AlgOptions() {}

func (*ALGSpec_DnsOptions) isALGSpec_AlgOptions() {}

func (*ALGSpec_MsrpcOptions) isALGSpec_AlgOptions() {}

func (*ALGSpec_SunrpcOptions) isALGSpec_AlgOptions() {}

// operational status of security policy, if any
type SecurityPolicyStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// no.of unique rules in h/w
	RuleCount int32 `protobuf:"varint,1,opt,name=rule_count,json=ruleCount,proto3" json:"rule_count,omitempty"`
	// no. of VPCs using the policy
	VpcCount int32 `protobuf:"varint,2,opt,name=vpc_count,json=vpcCount,proto3" json:"vpc_count,omitempty"`
	// no. of subnets using the policy
	SubnetCount int32 `protobuf:"varint,3,opt,name=subnet_count,json=subnetCount,proto3" json:"subnet_count,omitempty"`
	// no. of vnics using the policy
	VnicCount int32 `protobuf:"varint,4,opt,name=vnic_count,json=vnicCount,proto3" json:"vnic_count,omitempty"`
	// security policy h/w pool handle, if any
	HwPoolHandle *_go1.HwHandle `protobuf:"bytes,5,opt,name=hw_pool_handle,json=hwPoolHandle,proto3" json:"hw_pool_handle,omitempty"`
	// security-policy h/w handle
	HwHandle *_go1.HwHandle `protobuf:"bytes,6,opt,name=hw_handle,json=hwHandle,proto3" json:"hw_handle,omitempty"`
	// security-policy base address
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: this is the actual 64bit memory address. --)
	PolicyBaseAddress uint64 `protobuf:"varint,7,opt,name=policy_base_address,json=policyBaseAddress,proto3" json:"policy_base_address,omitempty"`
}

func (x *SecurityPolicyStatus) Reset() {
	*x = SecurityPolicyStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityPolicyStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityPolicyStatus) ProtoMessage() {}

func (x *SecurityPolicyStatus) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityPolicyStatus.ProtoReflect.Descriptor instead.
func (*SecurityPolicyStatus) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{9}
}

func (x *SecurityPolicyStatus) GetRuleCount() int32 {
	if x != nil {
		return x.RuleCount
	}
	return 0
}

func (x *SecurityPolicyStatus) GetVpcCount() int32 {
	if x != nil {
		return x.VpcCount
	}
	return 0
}

func (x *SecurityPolicyStatus) GetSubnetCount() int32 {
	if x != nil {
		return x.SubnetCount
	}
	return 0
}

func (x *SecurityPolicyStatus) GetVnicCount() int32 {
	if x != nil {
		return x.VnicCount
	}
	return 0
}

func (x *SecurityPolicyStatus) GetHwPoolHandle() *_go1.HwHandle {
	if x != nil {
		return x.HwPoolHandle
	}
	return nil
}

func (x *SecurityPolicyStatus) GetHwHandle() *_go1.HwHandle {
	if x != nil {
		return x.HwHandle
	}
	return nil
}

func (x *SecurityPolicyStatus) GetPolicyBaseAddress() uint64 {
	if x != nil {
		return x.PolicyBaseAddress
	}
	return 0
}

// security rule object
type SecurityRule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// configuration
	Spec *SecurityRuleSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// status
	Status *SecurityRuleStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SecurityRule) Reset() {
	*x = SecurityRule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRule) ProtoMessage() {}

func (x *SecurityRule) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRule.ProtoReflect.Descriptor instead.
func (*SecurityRule) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{10}
}

func (x *SecurityRule) GetSpec() *SecurityRuleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *SecurityRule) GetStatus() *SecurityRuleStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// security rule configuration
type SecurityRuleSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// unique identifier of security rule
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// security policy this rule belongs to
	SecurityPolicyId *_go.ObjectKey `protobuf:"bytes,2,opt,name=security_policy_id,json=securityPolicyId,proto3" json:"security_policy_id,omitempty"`
	// rule information
	Attrs *SecurityRuleAttrs `protobuf:"bytes,3,opt,name=attrs,proto3" json:"attrs,omitempty"`
}

func (x *SecurityRuleSpec) Reset() {
	*x = SecurityRuleSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityRuleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRuleSpec) ProtoMessage() {}

func (x *SecurityRuleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRuleSpec.ProtoReflect.Descriptor instead.
func (*SecurityRuleSpec) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{11}
}

func (x *SecurityRuleSpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SecurityRuleSpec) GetSecurityPolicyId() *_go.ObjectKey {
	if x != nil {
		return x.SecurityPolicyId
	}
	return nil
}

func (x *SecurityRuleSpec) GetAttrs() *SecurityRuleAttrs {
	if x != nil {
		return x.Attrs
	}
	return nil
}

// operational status of the security rule, if any
type SecurityRuleStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SecurityRuleStatus) Reset() {
	*x = SecurityRuleStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityRuleStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityRuleStatus) ProtoMessage() {}

func (x *SecurityRuleStatus) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityRuleStatus.ProtoReflect.Descriptor instead.
func (*SecurityRuleStatus) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{12}
}

// security profile object
type SecurityProfile struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// configuration
	Spec *SecurityProfileSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// status
	Status *SecurityProfileStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *SecurityProfile) Reset() {
	*x = SecurityProfile{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityProfile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityProfile) ProtoMessage() {}

func (x *SecurityProfile) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityProfile.ProtoReflect.Descriptor instead.
func (*SecurityProfile) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{13}
}

func (x *SecurityProfile) GetSpec() *SecurityProfileSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *SecurityProfile) GetStatus() *SecurityProfileStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// security profile - defaults for network security behavior
// - currently security profile object is global and only a singleton object,
//   any attempt to create multiple objects will be treated as an error
// - if no object is created, indicated default values will be used
// - all timeouts specified in this object are in seconds
type SecurityProfileSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// unique identifier of security profile
	Id *_go.ObjectKey `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ConnTrackEn, if set to true, will enable full connection tracking
	// if connection_tracking_enable is modified on the fly, it will take affect only
	// on sessions created thereafter and doesn't affect existing sessions
	ConnectionTrackingEnable bool `protobuf:"varint,2,opt,name=connection_tracking_enable,json=connectionTrackingEnable,proto3" json:"connection_tracking_enable,omitempty"`
	// rule_stats_enable, if set to true, will enable per security policy rule
	// statistics feature in the datapath (by default rule stats functionality is
	// turned off and can be enabled on the fly for debugging)
	RuleStatsEnable bool `protobuf:"varint,3,opt,name=rule_stats_enable,json=ruleStatsEnable,proto3" json:"rule_stats_enable,omitempty"`
	// default_firewall_action is the action taken by the smartnic when policies are
	// configured on the subnet or vnic, no rule matches and default action for policy is none
	// this will have effect iff policy is attached on either vnic or subnet.
	// if no action is specified  in security profile, default action is "deny"
	DefaultFirewallAction _go1.SecurityRuleAction `protobuf:"varint,4,opt,name=default_firewall_action,json=defaultFirewallAction,proto3,enum=opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction" json:"default_firewall_action,omitempty"`
	// timeouts for established sessions per TCP/UDP/ICMP and other protocols
	// range:1-86400, default=600
	TcpIdleTimeout int32 `protobuf:"varint,5,opt,name=tcp_idle_timeout,json=tcpIdleTimeout,proto3" json:"tcp_idle_timeout,omitempty"`
	// range:1-86400, default=120
	UdpIdleTimeout int32 `protobuf:"varint,6,opt,name=udp_idle_timeout,json=udpIdleTimeout,proto3" json:"udp_idle_timeout,omitempty"`
	// range:1-86400, default=15
	IcmpIdleTimeout int32 `protobuf:"varint,7,opt,name=icmp_idle_timeout,json=icmpIdleTimeout,proto3" json:"icmp_idle_timeout,omitempty"`
	// range:1-86400, default=90
	OtherIdleTimeout int32 `protobuf:"varint,8,opt,name=other_idle_timeout,json=otherIdleTimeout,proto3" json:"other_idle_timeout,omitempty"`
	// TCP specific timeouts
	// tcp_connection_setup_timeout is the maximum allowed time since first SYN seen to
	// 3-way handshake completion, session gets cleaned up if 3-way handshake is
	// not completed and session moves to ESTABLISHED state by then.  range:1-60, default=10
	TcpConnectionSetupTimeout int32 `protobuf:"varint,9,opt,name=tcp_connection_setup_timeout,json=tcpConnectionSetupTimeout,proto3" json:"tcp_connection_setup_timeout,omitempty"`
	// tcp_half_close_timeout is the maximum allowed time since first FIN seen to
	// 3/4way close, session gets cleaned up if this timer elapses. range:1-172800, default=120
	TcpHalfCloseTimeout int32 `protobuf:"varint,10,opt,name=tcp_half_close_timeout,json=tcpHalfCloseTimeout,proto3" json:"tcp_half_close_timeout,omitempty"`
	// tcp_close_timeout is wait time since FIN is seen from *both* sides (or RST)
	// before cleaning up the session range:1-300, default=15
	TcpCloseTimeout int32 `protobuf:"varint,11,opt,name=tcp_close_timeout,json=tcpCloseTimeout,proto3" json:"tcp_close_timeout,omitempty"`
	// timeouts applicable to sessions installed with drop action
	// range:1-300, default=90
	TcpDorpTimeout int32 `protobuf:"varint,12,opt,name=tcp_dorp_timeout,json=tcpDorpTimeout,proto3" json:"tcp_dorp_timeout,omitempty"`
	// range:1-172800, default=60
	UdpDropTimeout int32 `protobuf:"varint,13,opt,name=udp_drop_timeout,json=udpDropTimeout,proto3" json:"udp_drop_timeout,omitempty"`
	// range:1-300, default=30
	IcmpDropTimeout int32 `protobuf:"varint,14,opt,name=icmp_drop_timeout,json=icmpDropTimeout,proto3" json:"icmp_drop_timeout,omitempty"`
	// range:1-300, default=60
	OtherDropTimeout int32 `protobuf:"varint,15,opt,name=other_drop_timeout,json=otherDropTimeout,proto3" json:"other_drop_timeout,omitempty"`
}

func (x *SecurityProfileSpec) Reset() {
	*x = SecurityProfileSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityProfileSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityProfileSpec) ProtoMessage() {}

func (x *SecurityProfileSpec) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityProfileSpec.ProtoReflect.Descriptor instead.
func (*SecurityProfileSpec) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{14}
}

func (x *SecurityProfileSpec) GetId() *_go.ObjectKey {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SecurityProfileSpec) GetConnectionTrackingEnable() bool {
	if x != nil {
		return x.ConnectionTrackingEnable
	}
	return false
}

func (x *SecurityProfileSpec) GetRuleStatsEnable() bool {
	if x != nil {
		return x.RuleStatsEnable
	}
	return false
}

func (x *SecurityProfileSpec) GetDefaultFirewallAction() _go1.SecurityRuleAction {
	if x != nil {
		return x.DefaultFirewallAction
	}
	return _go1.SecurityRuleAction(0)
}

func (x *SecurityProfileSpec) GetTcpIdleTimeout() int32 {
	if x != nil {
		return x.TcpIdleTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetUdpIdleTimeout() int32 {
	if x != nil {
		return x.UdpIdleTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetIcmpIdleTimeout() int32 {
	if x != nil {
		return x.IcmpIdleTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetOtherIdleTimeout() int32 {
	if x != nil {
		return x.OtherIdleTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetTcpConnectionSetupTimeout() int32 {
	if x != nil {
		return x.TcpConnectionSetupTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetTcpHalfCloseTimeout() int32 {
	if x != nil {
		return x.TcpHalfCloseTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetTcpCloseTimeout() int32 {
	if x != nil {
		return x.TcpCloseTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetTcpDorpTimeout() int32 {
	if x != nil {
		return x.TcpDorpTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetUdpDropTimeout() int32 {
	if x != nil {
		return x.UdpDropTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetIcmpDropTimeout() int32 {
	if x != nil {
		return x.IcmpDropTimeout
	}
	return 0
}

func (x *SecurityProfileSpec) GetOtherDropTimeout() int32 {
	if x != nil {
		return x.OtherDropTimeout
	}
	return 0
}

// operational status of security profile, if any
type SecurityProfileStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SecurityProfileStatus) Reset() {
	*x = SecurityProfileStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityProfileStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityProfileStatus) ProtoMessage() {}

func (x *SecurityProfileStatus) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityProfileStatus.ProtoReflect.Descriptor instead.
func (*SecurityProfileStatus) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{15}
}

// PolicyLookupMatch captures all the policy lookup match conditions
type PolicyLookupMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// source IP address
	SourceIp *_go1.IPAddress `protobuf:"bytes,1,opt,name=source_ip,json=sourceIp,proto3" json:"source_ip,omitempty"`
	// tags corresponding to the source; an implementation may limit the maximum number of tags
	// range:1-4294967294
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: tags are 32bit values. --)
	SourceTags []uint32 `protobuf:"varint,2,rep,packed,name=source_tags,json=sourceTags,proto3" json:"source_tags,omitempty"`
	// destination IP address
	DestinationIp *_go1.IPAddress `protobuf:"bytes,3,opt,name=destination_ip,json=destinationIp,proto3" json:"destination_ip,omitempty"`
	// tags corresponding to the destination; an implementation may limit the maximum number of tags
	// range:1-4294967294
	// (-- api-linter: core::0141::forbidden-types=disabled
	//     aip.dev/not-precedent: tags are 32bit values. --)
	DestinationTags []uint32 `protobuf:"varint,4,rep,packed,name=destination_tags,json=destinationTags,proto3" json:"destination_tags,omitempty"`
	// IP protocol
	Protocol int32 `protobuf:"varint,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// source port, valid only for TCP and UDP
	SourcePort int32 `protobuf:"varint,6,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
	// destination port, valid only for TCP and UDP
	DestinationPort int32 `protobuf:"varint,7,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	// valid only for ICMPv4 and ICMPv6
	IcmpType int32 `protobuf:"varint,8,opt,name=icmp_type,json=icmpType,proto3" json:"icmp_type,omitempty"`
	// valid only for ICMPv4 and ICMPv6
	IcmpCode int32 `protobuf:"varint,9,opt,name=icmp_code,json=icmpCode,proto3" json:"icmp_code,omitempty"`
}

func (x *PolicyLookupMatch) Reset() {
	*x = PolicyLookupMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PolicyLookupMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyLookupMatch) ProtoMessage() {}

func (x *PolicyLookupMatch) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyLookupMatch.ProtoReflect.Descriptor instead.
func (*PolicyLookupMatch) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{16}
}

func (x *PolicyLookupMatch) GetSourceIp() *_go1.IPAddress {
	if x != nil {
		return x.SourceIp
	}
	return nil
}

func (x *PolicyLookupMatch) GetSourceTags() []uint32 {
	if x != nil {
		return x.SourceTags
	}
	return nil
}

func (x *PolicyLookupMatch) GetDestinationIp() *_go1.IPAddress {
	if x != nil {
		return x.DestinationIp
	}
	return nil
}

func (x *PolicyLookupMatch) GetDestinationTags() []uint32 {
	if x != nil {
		return x.DestinationTags
	}
	return nil
}

func (x *PolicyLookupMatch) GetProtocol() int32 {
	if x != nil {
		return x.Protocol
	}
	return 0
}

func (x *PolicyLookupMatch) GetSourcePort() int32 {
	if x != nil {
		return x.SourcePort
	}
	return 0
}

func (x *PolicyLookupMatch) GetDestinationPort() int32 {
	if x != nil {
		return x.DestinationPort
	}
	return 0
}

func (x *PolicyLookupMatch) GetIcmpType() int32 {
	if x != nil {
		return x.IcmpType
	}
	return 0
}

func (x *PolicyLookupMatch) GetIcmpCode() int32 {
	if x != nil {
		return x.IcmpCode
	}
	return 0
}

// SecurityPolicyLookup is used to fetch security policy based on various
// lookup criteria
type SecurityPolicyLookupRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// lookup_info is mandatory
	//
	// Types that are assignable to LookupInfo:
	//	*SecurityPolicyLookupRequest_PolicyId
	//	*SecurityPolicyLookupRequest_VnicLookupInfo_
	LookupInfo isSecurityPolicyLookupRequest_LookupInfo `protobuf_oneof:"lookup_info"`
	// packet match fields
	MatchFields *PolicyLookupMatch `protobuf:"bytes,3,opt,name=match_fields,json=matchFields,proto3" json:"match_fields,omitempty"`
}

func (x *SecurityPolicyLookupRequest) Reset() {
	*x = SecurityPolicyLookupRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityPolicyLookupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityPolicyLookupRequest) ProtoMessage() {}

func (x *SecurityPolicyLookupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityPolicyLookupRequest.ProtoReflect.Descriptor instead.
func (*SecurityPolicyLookupRequest) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{17}
}

func (m *SecurityPolicyLookupRequest) GetLookupInfo() isSecurityPolicyLookupRequest_LookupInfo {
	if m != nil {
		return m.LookupInfo
	}
	return nil
}

func (x *SecurityPolicyLookupRequest) GetPolicyId() *_go.ObjectKey {
	if x, ok := x.GetLookupInfo().(*SecurityPolicyLookupRequest_PolicyId); ok {
		return x.PolicyId
	}
	return nil
}

func (x *SecurityPolicyLookupRequest) GetVnicLookupInfo() *SecurityPolicyLookupRequest_VnicLookupInfo {
	if x, ok := x.GetLookupInfo().(*SecurityPolicyLookupRequest_VnicLookupInfo_); ok {
		return x.VnicLookupInfo
	}
	return nil
}

func (x *SecurityPolicyLookupRequest) GetMatchFields() *PolicyLookupMatch {
	if x != nil {
		return x.MatchFields
	}
	return nil
}

type isSecurityPolicyLookupRequest_LookupInfo interface {
	isSecurityPolicyLookupRequest_LookupInfo()
}

type SecurityPolicyLookupRequest_PolicyId struct {
	// security policy uuid to do the lookup in
	PolicyId *_go.ObjectKey `protobuf:"bytes,1,opt,name=policy_id,json=policyId,proto3,oneof"`
}

type SecurityPolicyLookupRequest_VnicLookupInfo_ struct {
	// vnic specific policies will be evaluated when vnic info is provided
	VnicLookupInfo *SecurityPolicyLookupRequest_VnicLookupInfo `protobuf:"bytes,2,opt,name=vnic_lookup_info,json=vnicLookupInfo,proto3,oneof"`
}

func (*SecurityPolicyLookupRequest_PolicyId) isSecurityPolicyLookupRequest_LookupInfo() {}

func (*SecurityPolicyLookupRequest_VnicLookupInfo_) isSecurityPolicyLookupRequest_LookupInfo() {}

// PolicyLookupResult captures the results of one security policy lookup
type PolicyLookupResult struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// h/w id of the rule that matched
	RuleHwHandle *_go1.HwHandle `protobuf:"bytes,1,opt,name=rule_hw_handle,json=ruleHwHandle,proto3" json:"rule_hw_handle,omitempty"`
	// priority of the rule that matched
	Priority int32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	// action associated with the rule
	Action _go1.SecurityRuleAction `protobuf:"varint,3,opt,name=action,proto3,enum=opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction" json:"action,omitempty"`
	// ALG associated with the rule, if any
	AlgType ALGType `protobuf:"varint,4,opt,name=alg_type,json=algType,proto3,enum=opi_api.network.cloud.v1alpha1.ALGType" json:"alg_type,omitempty"`
	// terminating is set to true, if this rule is configured as terminating
	Terminating bool `protobuf:"varint,5,opt,name=terminating,proto3" json:"terminating,omitempty"`
}

func (x *PolicyLookupResult) Reset() {
	*x = PolicyLookupResult{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PolicyLookupResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyLookupResult) ProtoMessage() {}

func (x *PolicyLookupResult) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyLookupResult.ProtoReflect.Descriptor instead.
func (*PolicyLookupResult) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{18}
}

func (x *PolicyLookupResult) GetRuleHwHandle() *_go1.HwHandle {
	if x != nil {
		return x.RuleHwHandle
	}
	return nil
}

func (x *PolicyLookupResult) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

func (x *PolicyLookupResult) GetAction() _go1.SecurityRuleAction {
	if x != nil {
		return x.Action
	}
	return _go1.SecurityRuleAction(0)
}

func (x *PolicyLookupResult) GetAlgType() ALGType {
	if x != nil {
		return x.AlgType
	}
	return ALGType_ALG_TYPE_UNSPECIFIED
}

func (x *PolicyLookupResult) GetTerminating() bool {
	if x != nil {
		return x.Terminating
	}
	return false
}

// given a vnic and policy direction (ingress/egress) and packet fields,
// evaluate all the policies and return the results
type SecurityPolicyLookupRequest_VnicLookupInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// vnic uuid
	VnicId *_go.ObjectKey `protobuf:"bytes,1,opt,name=vnic_id,json=vnicId,proto3" json:"vnic_id,omitempty"`
	// policy evaluation direction
	PolicyDirection _go1.PolicyDir `protobuf:"varint,2,opt,name=policy_direction,json=policyDirection,proto3,enum=opi_api.network.opinetcommon.v1alpha1.PolicyDir" json:"policy_direction,omitempty"`
	// IPv4 or IPv6 policy
	AddressFamily _go1.IpAf `protobuf:"varint,3,opt,name=address_family,json=addressFamily,proto3,enum=opi_api.network.opinetcommon.v1alpha1.IpAf" json:"address_family,omitempty"`
}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) Reset() {
	*x = SecurityPolicyLookupRequest_VnicLookupInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_networkpolicy_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecurityPolicyLookupRequest_VnicLookupInfo) ProtoMessage() {}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) ProtoReflect() protoreflect.Message {
	mi := &file_networkpolicy_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecurityPolicyLookupRequest_VnicLookupInfo.ProtoReflect.Descriptor instead.
func (*SecurityPolicyLookupRequest_VnicLookupInfo) Descriptor() ([]byte, []int) {
	return file_networkpolicy_proto_rawDescGZIP(), []int{17, 0}
}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) GetVnicId() *_go.ObjectKey {
	if x != nil {
		return x.VnicId
	}
	return nil
}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) GetPolicyDirection() _go1.PolicyDir {
	if x != nil {
		return x.PolicyDirection
	}
	return _go1.PolicyDir(0)
}

func (x *SecurityPolicyLookupRequest_VnicLookupInfo) GetAddressFamily() _go1.IpAf {
	if x != nil {
		return x.AddressFamily
	}
	return _go1.IpAf(0)
}

var File_networkpolicy_proto protoreflect.FileDescriptor

var file_networkpolicy_proto_rawDesc = []byte{
	0x0a, 0x13, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x1a, 0x10, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x6b, 0x65,
	0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x12, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa6, 0x01, 0x0a, 0x0e,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x46,
	0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65,
	0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x53, 0x70, 0x65, 0x63,
	0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x4c, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69,
	0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x22, 0x8a, 0x04, 0x0a, 0x12, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65,
	0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x02, 0x69, 0x64, 0x12, 0x46, 0x0a, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x12, 0x52, 0x0a, 0x0e, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x66, 0x61, 0x6d,
	0x69, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6f, 0x70, 0x69, 0x5f,
	0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e,
	0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x49, 0x70, 0x41, 0x66, 0x52, 0x0d, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x46,
	0x61, 0x6d, 0x69, 0x6c, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6c, 0x65,
	0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6c,
	0x65, 0x73, 0x73, 0x12, 0x71, 0x0a, 0x17, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x73,
	0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x39, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63,
	0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x15, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x46, 0x0a, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x18,
	0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e,
	0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52,
	0x75, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x51,
	0x0a, 0x0b, 0x72, 0x75, 0x6c, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0a, 0x72, 0x75, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61,
	0x74, 0x22, 0x89, 0x01, 0x0a, 0x10, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75,
	0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x47, 0x0a, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c,
	0x65, 0x41, 0x74, 0x74, 0x72, 0x73, 0x52, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x22, 0xb0, 0x02,
	0x0a, 0x11, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x74,
	0x74, 0x72, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12,
	0x46, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x51, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x39, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65,
	0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0b, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x42, 0x0a, 0x08,
	0x61, 0x6c, 0x67, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x41, 0x4c, 0x47, 0x53, 0x70, 0x65, 0x63, 0x52, 0x07, 0x61, 0x6c, 0x67, 0x53, 0x70, 0x65, 0x63,
	0x22, 0x38, 0x0a, 0x0a, 0x46, 0x54, 0x50, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2a,
	0x0a, 0x11, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x70, 0x5f, 0x6d, 0x69, 0x73, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
	0x49, 0x70, 0x4d, 0x69, 0x73, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x22, 0xd8, 0x02, 0x0a, 0x0a, 0x44,
	0x4e, 0x53, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x39, 0x0a, 0x19, 0x64, 0x72, 0x6f,
	0x70, 0x5f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x5f, 0x71, 0x75, 0x65, 0x72, 0x79, 0x5f, 0x6d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x16, 0x64, 0x72,
	0x6f, 0x70, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x73, 0x12, 0x44, 0x0a, 0x1f, 0x64, 0x72, 0x6f, 0x70, 0x5f, 0x6c, 0x61, 0x72,
	0x67, 0x65, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1b, 0x64,
	0x72, 0x6f, 0x70, 0x4c, 0x61, 0x72, 0x67, 0x65, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x4e, 0x61,
	0x6d, 0x65, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x18, 0x64, 0x72,
	0x6f, 0x70, 0x5f, 0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x5f, 0x6d, 0x65,
	0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x64, 0x72,
	0x6f, 0x70, 0x4c, 0x6f, 0x6e, 0x67, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x4d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x73, 0x12, 0x37, 0x0a, 0x18, 0x64, 0x72, 0x6f, 0x70, 0x5f, 0x6d, 0x75, 0x6c, 0x74,
	0x69, 0x5f, 0x7a, 0x6f, 0x6e, 0x65, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x15, 0x64, 0x72, 0x6f, 0x70, 0x4d, 0x75, 0x6c, 0x74, 0x69,
	0x5a, 0x6f, 0x6e, 0x65, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x10,
	0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x61, 0x78, 0x5f, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x10, 0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4c,
	0x65, 0x6e, 0x67, 0x74, 0x68, 0x22, 0x2d, 0x0a, 0x0c, 0x4d, 0x53, 0x52, 0x50, 0x43, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x67, 0x72,
	0x61, 0x6d, 0x49, 0x64, 0x22, 0x2e, 0x0a, 0x0d, 0x53, 0x75, 0x6e, 0x52, 0x50, 0x43, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x67, 0x72,
	0x61, 0x6d, 0x49, 0x64, 0x22, 0xca, 0x03, 0x0a, 0x07, 0x41, 0x4c, 0x47, 0x53, 0x70, 0x65, 0x63,
	0x12, 0x42, 0x0a, 0x08, 0x61, 0x6c, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x41, 0x4c, 0x47, 0x54, 0x79, 0x70, 0x65, 0x52, 0x07, 0x61, 0x6c, 0x67,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x69, 0x64, 0x6c, 0x65,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x4d, 0x0a, 0x0b, 0x66, 0x74, 0x70, 0x5f, 0x6f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x46, 0x54,
	0x50, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0a, 0x66, 0x74, 0x70, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4d, 0x0a, 0x0b, 0x64, 0x6e, 0x73, 0x5f, 0x6f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x44, 0x4e, 0x53,
	0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0a, 0x64, 0x6e, 0x73, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x53, 0x0a, 0x0d, 0x6d, 0x73, 0x72, 0x70, 0x63, 0x5f, 0x6f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x53,
	0x52, 0x50, 0x43, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x6d, 0x73,
	0x72, 0x70, 0x63, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x56, 0x0a, 0x0e, 0x73, 0x75,
	0x6e, 0x72, 0x70, 0x63, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x53, 0x75, 0x6e, 0x52, 0x50, 0x43, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x48, 0x00, 0x52, 0x0d, 0x73, 0x75, 0x6e, 0x72, 0x70, 0x63, 0x4f, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x42, 0x0d, 0x0a, 0x0b, 0x61, 0x6c, 0x67, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x22, 0xe9, 0x02, 0x0a, 0x14, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x75,
	0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09,
	0x72, 0x75, 0x6c, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x76, 0x70, 0x63,
	0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x76, 0x70,
	0x63, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74,
	0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x73, 0x75,
	0x62, 0x6e, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x76, 0x6e, 0x69,
	0x63, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09, 0x76,
	0x6e, 0x69, 0x63, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x55, 0x0a, 0x0e, 0x68, 0x77, 0x5f, 0x70,
	0x6f, 0x6f, 0x6c, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x48, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c,
	0x65, 0x52, 0x0c, 0x68, 0x77, 0x50, 0x6f, 0x6f, 0x6c, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x12,
	0x4c, 0x0a, 0x09, 0x68, 0x77, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x48, 0x77, 0x48, 0x61, 0x6e,
	0x64, 0x6c, 0x65, 0x52, 0x08, 0x68, 0x77, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x12, 0x2e, 0x0a,
	0x13, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x11, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x42, 0x61, 0x73, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0xa0, 0x01,
	0x0a, 0x0c, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x44,
	0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65,
	0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04,
	0x73, 0x70, 0x65, 0x63, 0x12, 0x4a, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75,
	0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x22, 0xd5, 0x01, 0x0a, 0x10, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c,
	0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x4a, 0x0a, 0x12, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x10, 0x73,
	0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x64, 0x12,
	0x47, 0x0a, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x41, 0x74, 0x74, 0x72,
	0x73, 0x52, 0x05, 0x61, 0x74, 0x74, 0x72, 0x73, 0x22, 0x14, 0x0a, 0x12, 0x53, 0x65, 0x63, 0x75,
	0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0xa9,
	0x01, 0x0a, 0x0f, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x66, 0x69,
	0x6c, 0x65, 0x12, 0x47, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x33, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
	0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x4d, 0x0a, 0x06, 0x73,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63,
	0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x9e, 0x06, 0x0a, 0x13, 0x53,
	0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x70,
	0x65, 0x63, 0x12, 0x2c, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
	0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x3c, 0x0a, 0x1a, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74,
	0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x18, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x54, 0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x2a,
	0x0a, 0x11, 0x72, 0x75, 0x6c, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x65, 0x6e, 0x61,
	0x62, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x72, 0x75, 0x6c, 0x65, 0x53,
	0x74, 0x61, 0x74, 0x73, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x71, 0x0a, 0x17, 0x64, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x5f, 0x61,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x39, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70,
	0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x75, 0x6c, 0x65,
	0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x15, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x46,
	0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x28, 0x0a,
	0x10, 0x74, 0x63, 0x70, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75,
	0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x74, 0x63, 0x70, 0x49, 0x64, 0x6c, 0x65,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x28, 0x0a, 0x10, 0x75, 0x64, 0x70, 0x5f, 0x69,
	0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0e, 0x75, 0x64, 0x70, 0x49, 0x64, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
	0x74, 0x12, 0x2a, 0x0a, 0x11, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x69, 0x63,
	0x6d, 0x70, 0x49, 0x64, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2c, 0x0a,
	0x12, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x6c, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x6f, 0x74, 0x68, 0x65, 0x72,
	0x49, 0x64, 0x6c, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x3f, 0x0a, 0x1c, 0x74,
	0x63, 0x70, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65,
	0x74, 0x75, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x19, 0x74, 0x63, 0x70, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x53, 0x65, 0x74, 0x75, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x33, 0x0a, 0x16,
	0x74, 0x63, 0x70, 0x5f, 0x68, 0x61, 0x6c, 0x66, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x13, 0x74, 0x63,
	0x70, 0x48, 0x61, 0x6c, 0x66, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
	0x74, 0x12, 0x2a, 0x0a, 0x11, 0x74, 0x63, 0x70, 0x5f, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x74, 0x63,
	0x70, 0x43, 0x6c, 0x6f, 0x73, 0x65, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x28, 0x0a,
	0x10, 0x74, 0x63, 0x70, 0x5f, 0x64, 0x6f, 0x72, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75,
	0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0e, 0x74, 0x63, 0x70, 0x44, 0x6f, 0x72, 0x70,
	0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x28, 0x0a, 0x10, 0x75, 0x64, 0x70, 0x5f, 0x64,
	0x72, 0x6f, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x0e, 0x75, 0x64, 0x70, 0x44, 0x72, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
	0x74, 0x12, 0x2a, 0x0a, 0x11, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x69, 0x63,
	0x6d, 0x70, 0x44, 0x72, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2c, 0x0a,
	0x12, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x6f, 0x74, 0x68, 0x65, 0x72,
	0x44, 0x72, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x22, 0x17, 0x0a, 0x15, 0x53,
	0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x22, 0xa9, 0x03, 0x0a, 0x11, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4c,
	0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x4d, 0x0a, 0x09, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e,
	0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
	0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52,
	0x08, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x49, 0x70, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x6f, 0x75,
	0x72, 0x63, 0x65, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0a,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x54, 0x61, 0x67, 0x73, 0x12, 0x57, 0x0a, 0x0e, 0x64, 0x65,
	0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x70, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x0d, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x49, 0x70, 0x12, 0x29, 0x0a, 0x10, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x0f, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x61, 0x67, 0x73, 0x12, 0x1a,
	0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0a, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6f, 0x72, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x69, 0x63, 0x6d, 0x70, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x63, 0x6f, 0x64, 0x65,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x69, 0x63, 0x6d, 0x70, 0x43, 0x6f, 0x64, 0x65,
	0x22, 0xb2, 0x04, 0x0a, 0x1b, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x3b, 0x0a, 0x09, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65,
	0x79, 0x48, 0x00, 0x52, 0x08, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x64, 0x12, 0x76, 0x0a,
	0x10, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x5f, 0x69, 0x6e, 0x66,
	0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x4a, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70,
	0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x2e, 0x56, 0x6e, 0x69, 0x63, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x49,
	0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x0e, 0x76, 0x6e, 0x69, 0x63, 0x4c, 0x6f, 0x6f, 0x6b, 0x75,
	0x70, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x54, 0x0a, 0x0c, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x66,
	0x69, 0x65, 0x6c, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x6f, 0x70,
	0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x0b,
	0x6d, 0x61, 0x74, 0x63, 0x68, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x1a, 0xf8, 0x01, 0x0a, 0x0e,
	0x56, 0x6e, 0x69, 0x63, 0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x35,
	0x0a, 0x07, 0x76, 0x6e, 0x69, 0x63, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x06, 0x76,
	0x6e, 0x69, 0x63, 0x49, 0x64, 0x12, 0x5b, 0x0a, 0x10, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f,
	0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x30, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x44, 0x69,
	0x72, 0x52, 0x0f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x52, 0x0a, 0x0e, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x66, 0x61,
	0x6d, 0x69, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6f, 0x70, 0x69,
	0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69,
	0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x31, 0x2e, 0x49, 0x70, 0x41, 0x66, 0x52, 0x0d, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x46, 0x61, 0x6d, 0x69, 0x6c, 0x79, 0x42, 0x0d, 0x0a, 0x0b, 0x6c, 0x6f, 0x6f, 0x6b, 0x75, 0x70,
	0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0xc0, 0x02, 0x0a, 0x12, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x4c, 0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x55, 0x0a, 0x0e,
	0x72, 0x75, 0x6c, 0x65, 0x5f, 0x68, 0x77, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x48, 0x77, 0x48,
	0x61, 0x6e, 0x64, 0x6c, 0x65, 0x52, 0x0c, 0x72, 0x75, 0x6c, 0x65, 0x48, 0x77, 0x48, 0x61, 0x6e,
	0x64, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12,
	0x51, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x39, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x6f, 0x70, 0x69, 0x6e, 0x65, 0x74, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
	0x52, 0x75, 0x6c, 0x65, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x42, 0x0a, 0x08, 0x61, 0x6c, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6f, 0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x41, 0x4c, 0x47, 0x54, 0x79, 0x70, 0x65, 0x52, 0x07, 0x61,
	0x6c, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e,
	0x61, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x74, 0x65, 0x72,
	0x6d, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x2a, 0x7e, 0x0a, 0x12, 0x53, 0x65, 0x63, 0x75,
	0x72, 0x69, 0x74, 0x79, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x24,
	0x0a, 0x20, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x21, 0x0a, 0x1d, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59,
	0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x44,
	0x45, 0x52, 0x4c, 0x41, 0x59, 0x10, 0x01, 0x12, 0x1f, 0x0a, 0x1b, 0x53, 0x45, 0x43, 0x55, 0x52,
	0x49, 0x54, 0x59, 0x5f, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x54, 0x45, 0x4e, 0x41, 0x4e, 0x54, 0x10, 0x02, 0x2a, 0x96, 0x01, 0x0a, 0x07, 0x41, 0x4c, 0x47,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x18, 0x0a, 0x14, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x11,
	0x0a, 0x0d, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x54, 0x46, 0x54, 0x50, 0x10,
	0x01, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x54,
	0x50, 0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x44, 0x4e, 0x53, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x53, 0x55, 0x4e, 0x52, 0x50, 0x43, 0x10, 0x04, 0x12, 0x12, 0x0a, 0x0e, 0x41, 0x4c,
	0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d, 0x53, 0x52, 0x50, 0x43, 0x10, 0x05, 0x12, 0x11,
	0x0a, 0x0d, 0x41, 0x4c, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x54, 0x53, 0x50, 0x10,
	0x06, 0x2a, 0x78, 0x0a, 0x10, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x46,
	0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x22, 0x0a, 0x1e, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f,
	0x52, 0x55, 0x4c, 0x45, 0x5f, 0x46, 0x4f, 0x52, 0x4d, 0x41, 0x54, 0x5f, 0x55, 0x4e, 0x53, 0x50,
	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x20, 0x0a, 0x1c, 0x50, 0x4f, 0x4c,
	0x49, 0x43, 0x59, 0x5f, 0x52, 0x55, 0x4c, 0x45, 0x5f, 0x46, 0x4f, 0x52, 0x4d, 0x41, 0x54, 0x5f,
	0x46, 0x4c, 0x41, 0x54, 0x54, 0x45, 0x4e, 0x45, 0x44, 0x10, 0x01, 0x12, 0x1e, 0x0a, 0x1a, 0x50,
	0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x52, 0x55, 0x4c, 0x45, 0x5f, 0x46, 0x4f, 0x52, 0x4d, 0x41,
	0x54, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x41, 0x43, 0x54, 0x10, 0x02, 0x42, 0x73, 0x0a, 0x1e, 0x6f,
	0x70, 0x69, 0x5f, 0x61, 0x70, 0x69, 0x2e, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x42, 0x12, 0x4e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x50, 0x01, 0x5a, 0x3b, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x6f, 0x70, 0x69, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2f, 0x6f, 0x70, 0x69, 0x2d, 0x61,
	0x70, 0x69, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2f, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f,
	0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_networkpolicy_proto_rawDescOnce sync.Once
	file_networkpolicy_proto_rawDescData = file_networkpolicy_proto_rawDesc
)

func file_networkpolicy_proto_rawDescGZIP() []byte {
	file_networkpolicy_proto_rawDescOnce.Do(func() {
		file_networkpolicy_proto_rawDescData = protoimpl.X.CompressGZIP(file_networkpolicy_proto_rawDescData)
	})
	return file_networkpolicy_proto_rawDescData
}

var file_networkpolicy_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_networkpolicy_proto_msgTypes = make([]protoimpl.MessageInfo, 20)
var file_networkpolicy_proto_goTypes = []interface{}{
	(SecurityPolicyType)(0),                            // 0: opi_api.network.cloud.v1alpha1.SecurityPolicyType
	(ALGType)(0),                                       // 1: opi_api.network.cloud.v1alpha1.ALGType
	(PolicyRuleFormat)(0),                              // 2: opi_api.network.cloud.v1alpha1.PolicyRuleFormat
	(*SecurityPolicy)(nil),                             // 3: opi_api.network.cloud.v1alpha1.SecurityPolicy
	(*SecurityPolicySpec)(nil),                         // 4: opi_api.network.cloud.v1alpha1.SecurityPolicySpec
	(*SecurityRuleInfo)(nil),                           // 5: opi_api.network.cloud.v1alpha1.SecurityRuleInfo
	(*SecurityRuleAttrs)(nil),                          // 6: opi_api.network.cloud.v1alpha1.SecurityRuleAttrs
	(*FTPOptions)(nil),                                 // 7: opi_api.network.cloud.v1alpha1.FTPOptions
	(*DNSOptions)(nil),                                 // 8: opi_api.network.cloud.v1alpha1.DNSOptions
	(*MSRPCOptions)(nil),                               // 9: opi_api.network.cloud.v1alpha1.MSRPCOptions
	(*SunRPCOptions)(nil),                              // 10: opi_api.network.cloud.v1alpha1.SunRPCOptions
	(*ALGSpec)(nil),                                    // 11: opi_api.network.cloud.v1alpha1.ALGSpec
	(*SecurityPolicyStatus)(nil),                       // 12: opi_api.network.cloud.v1alpha1.SecurityPolicyStatus
	(*SecurityRule)(nil),                               // 13: opi_api.network.cloud.v1alpha1.SecurityRule
	(*SecurityRuleSpec)(nil),                           // 14: opi_api.network.cloud.v1alpha1.SecurityRuleSpec
	(*SecurityRuleStatus)(nil),                         // 15: opi_api.network.cloud.v1alpha1.SecurityRuleStatus
	(*SecurityProfile)(nil),                            // 16: opi_api.network.cloud.v1alpha1.SecurityProfile
	(*SecurityProfileSpec)(nil),                        // 17: opi_api.network.cloud.v1alpha1.SecurityProfileSpec
	(*SecurityProfileStatus)(nil),                      // 18: opi_api.network.cloud.v1alpha1.SecurityProfileStatus
	(*PolicyLookupMatch)(nil),                          // 19: opi_api.network.cloud.v1alpha1.PolicyLookupMatch
	(*SecurityPolicyLookupRequest)(nil),                // 20: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest
	(*PolicyLookupResult)(nil),                         // 21: opi_api.network.cloud.v1alpha1.PolicyLookupResult
	(*SecurityPolicyLookupRequest_VnicLookupInfo)(nil), // 22: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.VnicLookupInfo
	(*_go.ObjectKey)(nil),                              // 23: opi_api.common.v1.ObjectKey
	(_go1.IpAf)(0),                                     // 24: opi_api.network.opinetcommon.v1alpha1.IpAf
	(_go1.SecurityRuleAction)(0),                       // 25: opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	(*_go1.RuleMatch)(nil),                             // 26: opi_api.network.opinetcommon.v1alpha1.RuleMatch
	(*_go1.HwHandle)(nil),                              // 27: opi_api.network.opinetcommon.v1alpha1.HwHandle
	(*_go1.IPAddress)(nil),                             // 28: opi_api.network.opinetcommon.v1alpha1.IPAddress
	(_go1.PolicyDir)(0),                                // 29: opi_api.network.opinetcommon.v1alpha1.PolicyDir
}
var file_networkpolicy_proto_depIdxs = []int32{
	4,  // 0: opi_api.network.cloud.v1alpha1.SecurityPolicy.spec:type_name -> opi_api.network.cloud.v1alpha1.SecurityPolicySpec
	12, // 1: opi_api.network.cloud.v1alpha1.SecurityPolicy.status:type_name -> opi_api.network.cloud.v1alpha1.SecurityPolicyStatus
	23, // 2: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.id:type_name -> opi_api.common.v1.ObjectKey
	0,  // 3: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.type:type_name -> opi_api.network.cloud.v1alpha1.SecurityPolicyType
	24, // 4: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.address_family:type_name -> opi_api.network.opinetcommon.v1alpha1.IpAf
	25, // 5: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.default_security_action:type_name -> opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	5,  // 6: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.rules:type_name -> opi_api.network.cloud.v1alpha1.SecurityRuleInfo
	2,  // 7: opi_api.network.cloud.v1alpha1.SecurityPolicySpec.rule_format:type_name -> opi_api.network.cloud.v1alpha1.PolicyRuleFormat
	23, // 8: opi_api.network.cloud.v1alpha1.SecurityRuleInfo.id:type_name -> opi_api.common.v1.ObjectKey
	6,  // 9: opi_api.network.cloud.v1alpha1.SecurityRuleInfo.attrs:type_name -> opi_api.network.cloud.v1alpha1.SecurityRuleAttrs
	26, // 10: opi_api.network.cloud.v1alpha1.SecurityRuleAttrs.match:type_name -> opi_api.network.opinetcommon.v1alpha1.RuleMatch
	25, // 11: opi_api.network.cloud.v1alpha1.SecurityRuleAttrs.action:type_name -> opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	11, // 12: opi_api.network.cloud.v1alpha1.SecurityRuleAttrs.alg_spec:type_name -> opi_api.network.cloud.v1alpha1.ALGSpec
	1,  // 13: opi_api.network.cloud.v1alpha1.ALGSpec.alg_type:type_name -> opi_api.network.cloud.v1alpha1.ALGType
	7,  // 14: opi_api.network.cloud.v1alpha1.ALGSpec.ftp_options:type_name -> opi_api.network.cloud.v1alpha1.FTPOptions
	8,  // 15: opi_api.network.cloud.v1alpha1.ALGSpec.dns_options:type_name -> opi_api.network.cloud.v1alpha1.DNSOptions
	9,  // 16: opi_api.network.cloud.v1alpha1.ALGSpec.msrpc_options:type_name -> opi_api.network.cloud.v1alpha1.MSRPCOptions
	10, // 17: opi_api.network.cloud.v1alpha1.ALGSpec.sunrpc_options:type_name -> opi_api.network.cloud.v1alpha1.SunRPCOptions
	27, // 18: opi_api.network.cloud.v1alpha1.SecurityPolicyStatus.hw_pool_handle:type_name -> opi_api.network.opinetcommon.v1alpha1.HwHandle
	27, // 19: opi_api.network.cloud.v1alpha1.SecurityPolicyStatus.hw_handle:type_name -> opi_api.network.opinetcommon.v1alpha1.HwHandle
	14, // 20: opi_api.network.cloud.v1alpha1.SecurityRule.spec:type_name -> opi_api.network.cloud.v1alpha1.SecurityRuleSpec
	15, // 21: opi_api.network.cloud.v1alpha1.SecurityRule.status:type_name -> opi_api.network.cloud.v1alpha1.SecurityRuleStatus
	23, // 22: opi_api.network.cloud.v1alpha1.SecurityRuleSpec.id:type_name -> opi_api.common.v1.ObjectKey
	23, // 23: opi_api.network.cloud.v1alpha1.SecurityRuleSpec.security_policy_id:type_name -> opi_api.common.v1.ObjectKey
	6,  // 24: opi_api.network.cloud.v1alpha1.SecurityRuleSpec.attrs:type_name -> opi_api.network.cloud.v1alpha1.SecurityRuleAttrs
	17, // 25: opi_api.network.cloud.v1alpha1.SecurityProfile.spec:type_name -> opi_api.network.cloud.v1alpha1.SecurityProfileSpec
	18, // 26: opi_api.network.cloud.v1alpha1.SecurityProfile.status:type_name -> opi_api.network.cloud.v1alpha1.SecurityProfileStatus
	23, // 27: opi_api.network.cloud.v1alpha1.SecurityProfileSpec.id:type_name -> opi_api.common.v1.ObjectKey
	25, // 28: opi_api.network.cloud.v1alpha1.SecurityProfileSpec.default_firewall_action:type_name -> opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	28, // 29: opi_api.network.cloud.v1alpha1.PolicyLookupMatch.source_ip:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	28, // 30: opi_api.network.cloud.v1alpha1.PolicyLookupMatch.destination_ip:type_name -> opi_api.network.opinetcommon.v1alpha1.IPAddress
	23, // 31: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.policy_id:type_name -> opi_api.common.v1.ObjectKey
	22, // 32: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.vnic_lookup_info:type_name -> opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.VnicLookupInfo
	19, // 33: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.match_fields:type_name -> opi_api.network.cloud.v1alpha1.PolicyLookupMatch
	27, // 34: opi_api.network.cloud.v1alpha1.PolicyLookupResult.rule_hw_handle:type_name -> opi_api.network.opinetcommon.v1alpha1.HwHandle
	25, // 35: opi_api.network.cloud.v1alpha1.PolicyLookupResult.action:type_name -> opi_api.network.opinetcommon.v1alpha1.SecurityRuleAction
	1,  // 36: opi_api.network.cloud.v1alpha1.PolicyLookupResult.alg_type:type_name -> opi_api.network.cloud.v1alpha1.ALGType
	23, // 37: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.VnicLookupInfo.vnic_id:type_name -> opi_api.common.v1.ObjectKey
	29, // 38: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.VnicLookupInfo.policy_direction:type_name -> opi_api.network.opinetcommon.v1alpha1.PolicyDir
	24, // 39: opi_api.network.cloud.v1alpha1.SecurityPolicyLookupRequest.VnicLookupInfo.address_family:type_name -> opi_api.network.opinetcommon.v1alpha1.IpAf
	40, // [40:40] is the sub-list for method output_type
	40, // [40:40] is the sub-list for method input_type
	40, // [40:40] is the sub-list for extension type_name
	40, // [40:40] is the sub-list for extension extendee
	0,  // [0:40] is the sub-list for field type_name
}

func init() { file_networkpolicy_proto_init() }
func file_networkpolicy_proto_init() {
	if File_networkpolicy_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_networkpolicy_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityPolicySpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityRuleInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityRuleAttrs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FTPOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DNSOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MSRPCOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SunRPCOptions); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ALGSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityPolicyStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityRule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityRuleSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityRuleStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityProfile); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityProfileSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityProfileStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PolicyLookupMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityPolicyLookupRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PolicyLookupResult); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_networkpolicy_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SecurityPolicyLookupRequest_VnicLookupInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_networkpolicy_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*ALGSpec_FtpOptions)(nil),
		(*ALGSpec_DnsOptions)(nil),
		(*ALGSpec_MsrpcOptions)(nil),
		(*ALGSpec_SunrpcOptions)(nil),
	}
	file_networkpolicy_proto_msgTypes[17].OneofWrappers = []interface{}{
		(*SecurityPolicyLookupRequest_PolicyId)(nil),
		(*SecurityPolicyLookupRequest_VnicLookupInfo_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_networkpolicy_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   20,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_networkpolicy_proto_goTypes,
		DependencyIndexes: file_networkpolicy_proto_depIdxs,
		EnumInfos:         file_networkpolicy_proto_enumTypes,
		MessageInfos:      file_networkpolicy_proto_msgTypes,
	}.Build()
	File_networkpolicy_proto = out.File
	file_networkpolicy_proto_rawDesc = nil
	file_networkpolicy_proto_goTypes = nil
	file_networkpolicy_proto_depIdxs = nil
}
