// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: subnet.proto

package opi_api.network.cloud.v1alpha1;

public interface SubnetSpecOrBuilder extends
    // @@protoc_insertion_point(interface_extends:opi_api.network.cloud.v1alpha1.SubnetSpec)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * unique identifier of the subnet
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey id = 1;</code>
   * @return Whether the id field is set.
   */
  boolean hasId();
  /**
   * <pre>
   * unique identifier of the subnet
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey id = 1;</code>
   * @return The id.
   */
  opi_api.common.v1.ObjectKey getId();
  /**
   * <pre>
   * unique identifier of the subnet
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey id = 1;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getIdOrBuilder();

  /**
   * <pre>
   * virtual private cloud this subnet is belongs to
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey vpc_id = 2;</code>
   * @return Whether the vpcId field is set.
   */
  boolean hasVpcId();
  /**
   * <pre>
   * virtual private cloud this subnet is belongs to
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey vpc_id = 2;</code>
   * @return The vpcId.
   */
  opi_api.common.v1.ObjectKey getVpcId();
  /**
   * <pre>
   * virtual private cloud this subnet is belongs to
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey vpc_id = 2;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getVpcIdOrBuilder();

  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 3;</code>
   * @return Whether the v4Prefix field is set.
   */
  boolean hasV4Prefix();
  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 3;</code>
   * @return The v4Prefix.
   */
  opi_api.network.opinetcommon.v1alpha1.IPv4Prefix getV4Prefix();
  /**
   * <pre>
   * IPv4 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv4Prefix v4_prefix = 3;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.IPv4PrefixOrBuilder getV4PrefixOrBuilder();

  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 4;</code>
   * @return Whether the v6Prefix field is set.
   */
  boolean hasV6Prefix();
  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 4;</code>
   * @return The v6Prefix.
   */
  opi_api.network.opinetcommon.v1alpha1.IPv6Prefix getV6Prefix();
  /**
   * <pre>
   * IPv6 prefix of this subnet, this must be a sub prefix of VPC's prefix
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.IPv6Prefix v6_prefix = 4;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.IPv6PrefixOrBuilder getV6PrefixOrBuilder();

  /**
   * <pre>
   * IPv4 Virtual Router (VR) IP of this subnet, this IP is owned by the device
   * and packets originated by this device carry this IP as source IP
   * (-- api-linter: core::0141::forbidden-types=disabled
   *     aip.dev/not-precedent: ipv4 address is unsigned. --)
   * </pre>
   *
   * <code>uint32 ipv4_virtual_router_ip = 5;</code>
   * @return The ipv4VirtualRouterIp.
   */
  int getIpv4VirtualRouterIp();

  /**
   * <pre>
   * Ipv6 Virtual Router (VR) IP of this subnet, this IP is owned by the device
   * and packets originated by this device carry this IP as source IP
   * </pre>
   *
   * <code>bytes ipv6_virtual_router_ip = 6;</code>
   * @return The ipv6VirtualRouterIp.
   */
  com.google.protobuf.ByteString getIpv6VirtualRouterIp();

  /**
   * <pre>
   * Virtual Router (VR) MAC address, any packets originated or routed by
   * the device carry this MAC as source MAC
   * </pre>
   *
   * <code>bytes virtual_router_mac = 7;</code>
   * @return The virtualRouterMac.
   */
  com.google.protobuf.ByteString getVirtualRouterMac();

  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v4_route_table_id = 8;</code>
   * @return Whether the v4RouteTableId field is set.
   */
  boolean hasV4RouteTableId();
  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v4_route_table_id = 8;</code>
   * @return The v4RouteTableId.
   */
  opi_api.common.v1.ObjectKey getV4RouteTableId();
  /**
   * <pre>
   * identifier of the IPv4 route table to be used
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v4_route_table_id = 8;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getV4RouteTableIdOrBuilder();

  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v6_router_table_id = 9;</code>
   * @return Whether the v6RouterTableId field is set.
   */
  boolean hasV6RouterTableId();
  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v6_router_table_id = 9;</code>
   * @return The v6RouterTableId.
   */
  opi_api.common.v1.ObjectKey getV6RouterTableId();
  /**
   * <pre>
   * identifier of the IPv6 route table to be used, if any
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey v6_router_table_id = 9;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getV6RouterTableIdOrBuilder();

  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingess_v4_security_policy_id = 10;</code>
   */
  java.util.List<opi_api.common.v1.ObjectKey> 
      getIngessV4SecurityPolicyIdList();
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingess_v4_security_policy_id = 10;</code>
   */
  opi_api.common.v1.ObjectKey getIngessV4SecurityPolicyId(int index);
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingess_v4_security_policy_id = 10;</code>
   */
  int getIngessV4SecurityPolicyIdCount();
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingess_v4_security_policy_id = 10;</code>
   */
  java.util.List<? extends opi_api.common.v1.ObjectKeyOrBuilder> 
      getIngessV4SecurityPolicyIdOrBuilderList();
  /**
   * <pre>
   * security policies per subnet:
   * - all vnics in this subnet will inherit the policies configured under subnet
   * - multiple policies per vnic per direction (ingress/egress) can be specified
   * - an implementation may limit the #policies per subnet in each direction
   * identifier of ingress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingess_v4_security_policy_id = 10;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getIngessV4SecurityPolicyIdOrBuilder(
      int index);

  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingress_v6_security_policy_id = 11;</code>
   */
  java.util.List<opi_api.common.v1.ObjectKey> 
      getIngressV6SecurityPolicyIdList();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingress_v6_security_policy_id = 11;</code>
   */
  opi_api.common.v1.ObjectKey getIngressV6SecurityPolicyId(int index);
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingress_v6_security_policy_id = 11;</code>
   */
  int getIngressV6SecurityPolicyIdCount();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingress_v6_security_policy_id = 11;</code>
   */
  java.util.List<? extends opi_api.common.v1.ObjectKeyOrBuilder> 
      getIngressV6SecurityPolicyIdOrBuilderList();
  /**
   * <pre>
   * identifier of ingress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey ingress_v6_security_policy_id = 11;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getIngressV6SecurityPolicyIdOrBuilder(
      int index);

  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v4_security_policy_id = 12;</code>
   */
  java.util.List<opi_api.common.v1.ObjectKey> 
      getEgressV4SecurityPolicyIdList();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v4_security_policy_id = 12;</code>
   */
  opi_api.common.v1.ObjectKey getEgressV4SecurityPolicyId(int index);
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v4_security_policy_id = 12;</code>
   */
  int getEgressV4SecurityPolicyIdCount();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v4_security_policy_id = 12;</code>
   */
  java.util.List<? extends opi_api.common.v1.ObjectKeyOrBuilder> 
      getEgressV4SecurityPolicyIdOrBuilderList();
  /**
   * <pre>
   * identifier of egress IPv4 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v4_security_policy_id = 12;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getEgressV4SecurityPolicyIdOrBuilder(
      int index);

  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v6_security_policy_id = 13;</code>
   */
  java.util.List<opi_api.common.v1.ObjectKey> 
      getEgressV6SecurityPolicyIdList();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v6_security_policy_id = 13;</code>
   */
  opi_api.common.v1.ObjectKey getEgressV6SecurityPolicyId(int index);
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v6_security_policy_id = 13;</code>
   */
  int getEgressV6SecurityPolicyIdCount();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v6_security_policy_id = 13;</code>
   */
  java.util.List<? extends opi_api.common.v1.ObjectKeyOrBuilder> 
      getEgressV6SecurityPolicyIdOrBuilderList();
  /**
   * <pre>
   * identifier of egress IPv6 security policy to be enforced
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey egress_v6_security_policy_id = 13;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getEgressV6SecurityPolicyIdOrBuilder(
      int index);

  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 14;</code>
   * @return Whether the accessEncap field is set.
   */
  boolean hasAccessEncap();
  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 14;</code>
   * @return The accessEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getAccessEncap();
  /**
   * <pre>
   * AccessEncap is either ENCAP_TYPE_NONE (untagged) or ENCAP_TYPE_DOT1Q
   * and when AccessEncap is ENCAP_TYPE_DOT1Q, multiple vnics can send
   * traffic with same DOT1Q tag, in which case vnics are identified with
   * their MAC or IP based on the datapath in addition to the DOT1Q tag
   * - when subnet's AccessEncap is ENCAP_TYPE_NONE, vnics can also be
   *   identified by the encap of their own (e.g. VLAN as VNIC or QinQ as
   *   VNIC etc.)
   * - when subnet's AccessEncap is ENCAP_TYPE_DOT1Q, it is expected that
   *   all traffic from vnics in that subnet is transmitted with this encap
   *   (so vnics can be configured with VnicEncap as ENCAP_TYPE_NONE, so they
   *   inherit the subnet's encap)
   * - it is also possible to have subnet encap as ENCAP_TYPE_DOT1Q with
   *   certain tag value but some vnic's in that subnet to have different
   *   DOT1Q encap than that of subnet
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap access_encap = 14;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getAccessEncapOrBuilder();

  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 15;</code>
   * @return Whether the fabricEncap field is set.
   */
  boolean hasFabricEncap();
  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 15;</code>
   * @return The fabricEncap.
   */
  opi_api.network.opinetcommon.v1alpha1.Encap getFabricEncap();
  /**
   * <pre>
   * encapped traffic coming with the specified encap from fabric side will be
   * mapped to this subnet and traffic from workloads in this subnet will carry
   * this encap towards the fabric side
   * </pre>
   *
   * <code>.opi_api.network.opinetcommon.v1alpha1.Encap fabric_encap = 15;</code>
   */
  opi_api.network.opinetcommon.v1alpha1.EncapOrBuilder getFabricEncapOrBuilder();

  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey host_interface_id = 16;</code>
   */
  java.util.List<opi_api.common.v1.ObjectKey> 
      getHostInterfaceIdList();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey host_interface_id = 16;</code>
   */
  opi_api.common.v1.ObjectKey getHostInterfaceId(int index);
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey host_interface_id = 16;</code>
   */
  int getHostInterfaceIdCount();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey host_interface_id = 16;</code>
   */
  java.util.List<? extends opi_api.common.v1.ObjectKeyOrBuilder> 
      getHostInterfaceIdOrBuilderList();
  /**
   * <pre>
   * when operating in DEVICE_OPER_MODE_HOST mode with multiple host PFs/VFs
   * present, subnet needs to be attached to a PF/VF (aka. host interface),
   * HostIf is list of such VF/PFs
   * </pre>
   *
   * <code>repeated .opi_api.common.v1.ObjectKey host_interface_id = 16;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getHostInterfaceIdOrBuilder(
      int index);

  /**
   * <pre>
   * ToS field is 1 byte value that is populated in the DSCP field of IPv4 outer
   * header or in the Traffic Class field of IPv6 outer header, this value, if
   * non-zero, will be used as-is (i.e., not interpreted) during encap time by
   * the dataplane; tunnel objects, if configured with ToS, will override this
   * </pre>
   *
   * <code>int32 tos = 18;</code>
   * @return The tos.
   */
  int getTos();

  /**
   * <pre>
   * a subnet is marked connected if vnics in this subnet can communicate with
   * external endpoints via routes with some kind of NAT (e.g. 1:1 NAT, NAPT)
   * </pre>
   *
   * <code>bool connected = 19;</code>
   * @return The connected.
   */
  boolean getConnected();

  /**
   * <pre>
   * default ingress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security policies on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey ingress_default_sg_policy = 20;</code>
   * @return Whether the ingressDefaultSgPolicy field is set.
   */
  boolean hasIngressDefaultSgPolicy();
  /**
   * <pre>
   * default ingress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security policies on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey ingress_default_sg_policy = 20;</code>
   * @return The ingressDefaultSgPolicy.
   */
  opi_api.common.v1.ObjectKey getIngressDefaultSgPolicy();
  /**
   * <pre>
   * default ingress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security policies on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey ingress_default_sg_policy = 20;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getIngressDefaultSgPolicyOrBuilder();

  /**
   * <pre>
   * default egress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security polices on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey egress_default_sg_policy = 21;</code>
   * @return Whether the egressDefaultSgPolicy field is set.
   */
  boolean hasEgressDefaultSgPolicy();
  /**
   * <pre>
   * default egress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security polices on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey egress_default_sg_policy = 21;</code>
   * @return The egressDefaultSgPolicy.
   */
  opi_api.common.v1.ObjectKey getEgressDefaultSgPolicy();
  /**
   * <pre>
   * default egress stateful security policy for this subnet
   * if configured, is the 1st policy evaluated before other security polices on a given vnic
   * </pre>
   *
   * <code>.opi_api.common.v1.ObjectKey egress_default_sg_policy = 21;</code>
   */
  opi_api.common.v1.ObjectKeyOrBuilder getEgressDefaultSgPolicyOrBuilder();

  /**
   * <pre>
   * remote_subnet, if set, indicates that the subnet does not have any IP
   * mappings in local pod and such subnets are used to program all remote
   * pod IP mappings behind it
   * </pre>
   *
   * <code>bool remote_subnet = 22;</code>
   * @return The remoteSubnet.
   */
  boolean getRemoteSubnet();
}
